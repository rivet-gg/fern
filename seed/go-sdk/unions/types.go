// This file was auto-generated by Fern from our API Definition.

package unions

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/fern-api/unions-go/core"
	time "time"
)

type Bar struct {
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *Bar) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Bar) UnmarshalJSON(data []byte) error {
	type unmarshaler Bar
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Bar(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *Bar) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Foo struct {
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *Foo) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Foo) UnmarshalJSON(data []byte) error {
	type unmarshaler Foo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Foo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *Foo) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is a simple union.
type Union struct {
	Type string
	Foo  *Foo
	Bar  *Bar
}

func (u *Union) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "foo":
		var valueUnmarshaler struct {
			Foo *Foo `json:"foo,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Foo = valueUnmarshaler.Foo
	case "bar":
		var valueUnmarshaler struct {
			Bar *Bar `json:"bar,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Bar = valueUnmarshaler.Bar
	}
	return nil
}

func (u Union) MarshalJSON() ([]byte, error) {
	if u.Foo != nil {
		var marshaler = struct {
			Type string `json:"type"`
			Foo  *Foo   `json:"foo,omitempty"`
		}{
			Type: "foo",
			Foo:  u.Foo,
		}
		return json.Marshal(marshaler)
	}
	if u.Bar != nil {
		var marshaler = struct {
			Type string `json:"type"`
			Bar  *Bar   `json:"bar,omitempty"`
		}{
			Type: "bar",
			Bar:  u.Bar,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionVisitor interface {
	VisitFoo(*Foo) error
	VisitBar(*Bar) error
}

func (u *Union) Accept(visitor UnionVisitor) error {
	if u.Foo != nil {
		return visitor.VisitFoo(u.Foo)
	}
	if u.Bar != nil {
		return visitor.VisitBar(u.Bar)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithBaseProperties struct {
	Type    string
	Id      string
	Integer int
	String  string
	Foo     *Foo
}

func (u *UnionWithBaseProperties) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
		Id   string `json:"id"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	u.Id = unmarshaler.Id
	switch unmarshaler.Type {
	case "integer":
		var valueUnmarshaler struct {
			Integer int `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Integer = valueUnmarshaler.Integer
	case "string":
		var valueUnmarshaler struct {
			String string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.String = valueUnmarshaler.String
	case "foo":
		value := new(Foo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Foo = value
	}
	return nil
}

func (u UnionWithBaseProperties) MarshalJSON() ([]byte, error) {
	if u.Integer != 0 {
		var marshaler = struct {
			Type    string `json:"type"`
			Id      string `json:"id"`
			Integer int    `json:"value"`
		}{
			Type:    "integer",
			Id:      u.Id,
			Integer: u.Integer,
		}
		return json.Marshal(marshaler)
	}
	if u.String != "" {
		var marshaler = struct {
			Type   string `json:"type"`
			Id     string `json:"id"`
			String string `json:"value"`
		}{
			Type:   "string",
			Id:     u.Id,
			String: u.String,
		}
		return json.Marshal(marshaler)
	}
	if u.Foo != nil {
		return core.MarshalJSONWithExtraProperty(u.Foo, "type", "foo")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithBasePropertiesVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
	VisitFoo(*Foo) error
}

func (u *UnionWithBaseProperties) Accept(visitor UnionWithBasePropertiesVisitor) error {
	if u.Integer != 0 {
		return visitor.VisitInteger(u.Integer)
	}
	if u.String != "" {
		return visitor.VisitString(u.String)
	}
	if u.Foo != nil {
		return visitor.VisitFoo(u.Foo)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithDiscriminant struct {
	Type string
	// This is a Foo field.
	Foo *Foo
	Bar *Bar
}

func (u *UnionWithDiscriminant) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "foo":
		var valueUnmarshaler struct {
			Foo *Foo `json:"foo,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Foo = valueUnmarshaler.Foo
	case "bar":
		var valueUnmarshaler struct {
			Bar *Bar `json:"bar,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Bar = valueUnmarshaler.Bar
	}
	return nil
}

func (u UnionWithDiscriminant) MarshalJSON() ([]byte, error) {
	if u.Foo != nil {
		var marshaler = struct {
			Type string `json:"_type"`
			Foo  *Foo   `json:"foo,omitempty"`
		}{
			Type: "foo",
			Foo:  u.Foo,
		}
		return json.Marshal(marshaler)
	}
	if u.Bar != nil {
		var marshaler = struct {
			Type string `json:"_type"`
			Bar  *Bar   `json:"bar,omitempty"`
		}{
			Type: "bar",
			Bar:  u.Bar,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithDiscriminantVisitor interface {
	VisitFoo(*Foo) error
	VisitBar(*Bar) error
}

func (u *UnionWithDiscriminant) Accept(visitor UnionWithDiscriminantVisitor) error {
	if u.Foo != nil {
		return visitor.VisitFoo(u.Foo)
	}
	if u.Bar != nil {
		return visitor.VisitBar(u.Bar)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithLiteral struct {
	Type string
	fern string
	base string
}

func NewUnionWithLiteralWithFern() *UnionWithLiteral {
	return &UnionWithLiteral{Type: "fern", fern: "fern"}
}

func (u *UnionWithLiteral) Base() string {
	return u.base
}

func (u *UnionWithLiteral) Fern() string {
	return u.fern
}

func (u *UnionWithLiteral) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	u.base = "base"
	switch unmarshaler.Type {
	case "fern":
		u.fern = "fern"
	}
	return nil
}

func (u UnionWithLiteral) MarshalJSON() ([]byte, error) {
	if u.fern != "" {
		var marshaler = struct {
			Type string `json:"type"`
			Base string `json:"base"`
			Fern string `json:"value,omitempty"`
		}{
			Type: "fern",
			Base: "base",
			Fern: "fern",
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithLiteralVisitor interface {
	VisitFern(string) error
}

func (u *UnionWithLiteral) Accept(visitor UnionWithLiteralVisitor) error {
	if u.fern != "" {
		return visitor.VisitFern(u.fern)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithOptionalTime struct {
	Type     string
	Date     *time.Time
	Dateimte *time.Time
}

func (u *UnionWithOptionalTime) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "date":
		var valueUnmarshaler struct {
			Date *core.Date `json:"value,omitempty" format:"date"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Date = valueUnmarshaler.Date.TimePtr()
	case "dateimte":
		var valueUnmarshaler struct {
			Dateimte *core.DateTime `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Dateimte = valueUnmarshaler.Dateimte.TimePtr()
	}
	return nil
}

func (u UnionWithOptionalTime) MarshalJSON() ([]byte, error) {
	if u.Date != nil {
		var marshaler = struct {
			Type string     `json:"type"`
			Date *core.Date `json:"value,omitempty" format:"date"`
		}{
			Type: "date",
			Date: core.NewOptionalDate(u.Date),
		}
		return json.Marshal(marshaler)
	}
	if u.Dateimte != nil {
		var marshaler = struct {
			Type     string         `json:"type"`
			Dateimte *core.DateTime `json:"value,omitempty"`
		}{
			Type:     "dateimte",
			Dateimte: core.NewOptionalDateTime(u.Dateimte),
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithOptionalTimeVisitor interface {
	VisitDate(*time.Time) error
	VisitDateimte(*time.Time) error
}

func (u *UnionWithOptionalTime) Accept(visitor UnionWithOptionalTimeVisitor) error {
	if u.Date != nil {
		return visitor.VisitDate(u.Date)
	}
	if u.Dateimte != nil {
		return visitor.VisitDateimte(u.Dateimte)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithPrimitive struct {
	Type    string
	Integer int
	String  string
}

func (u *UnionWithPrimitive) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "integer":
		var valueUnmarshaler struct {
			Integer int `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Integer = valueUnmarshaler.Integer
	case "string":
		var valueUnmarshaler struct {
			String string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.String = valueUnmarshaler.String
	}
	return nil
}

func (u UnionWithPrimitive) MarshalJSON() ([]byte, error) {
	if u.Integer != 0 {
		var marshaler = struct {
			Type    string `json:"type"`
			Integer int    `json:"value"`
		}{
			Type:    "integer",
			Integer: u.Integer,
		}
		return json.Marshal(marshaler)
	}
	if u.String != "" {
		var marshaler = struct {
			Type   string `json:"type"`
			String string `json:"value"`
		}{
			Type:   "string",
			String: u.String,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithPrimitiveVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (u *UnionWithPrimitive) Accept(visitor UnionWithPrimitiveVisitor) error {
	if u.Integer != 0 {
		return visitor.VisitInteger(u.Integer)
	}
	if u.String != "" {
		return visitor.VisitString(u.String)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithSingleElement struct {
	Type string
	Foo  *Foo
}

func (u *UnionWithSingleElement) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "foo":
		value := new(Foo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Foo = value
	}
	return nil
}

func (u UnionWithSingleElement) MarshalJSON() ([]byte, error) {
	if u.Foo != nil {
		return core.MarshalJSONWithExtraProperty(u.Foo, "type", "foo")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithSingleElementVisitor interface {
	VisitFoo(*Foo) error
}

func (u *UnionWithSingleElement) Accept(visitor UnionWithSingleElementVisitor) error {
	if u.Foo != nil {
		return visitor.VisitFoo(u.Foo)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithTime struct {
	Type     string
	Value    int
	Date     time.Time
	Datetime time.Time
}

func (u *UnionWithTime) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "value":
		var valueUnmarshaler struct {
			Value int `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Value = valueUnmarshaler.Value
	case "date":
		var valueUnmarshaler struct {
			Date *core.Date `json:"value" format:"date"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Date = valueUnmarshaler.Date.Time()
	case "datetime":
		var valueUnmarshaler struct {
			Datetime *core.DateTime `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		u.Datetime = valueUnmarshaler.Datetime.Time()
	}
	return nil
}

func (u UnionWithTime) MarshalJSON() ([]byte, error) {
	if u.Value != 0 {
		var marshaler = struct {
			Type  string `json:"type"`
			Value int    `json:"value"`
		}{
			Type:  "value",
			Value: u.Value,
		}
		return json.Marshal(marshaler)
	}
	if !u.Date.IsZero() {
		var marshaler = struct {
			Type string     `json:"type"`
			Date *core.Date `json:"value" format:"date"`
		}{
			Type: "date",
			Date: core.NewDate(u.Date),
		}
		return json.Marshal(marshaler)
	}
	if !u.Datetime.IsZero() {
		var marshaler = struct {
			Type     string         `json:"type"`
			Datetime *core.DateTime `json:"value"`
		}{
			Type:     "datetime",
			Datetime: core.NewDateTime(u.Datetime),
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithTimeVisitor interface {
	VisitValue(int) error
	VisitDate(time.Time) error
	VisitDatetime(time.Time) error
}

func (u *UnionWithTime) Accept(visitor UnionWithTimeVisitor) error {
	if u.Value != 0 {
		return visitor.VisitValue(u.Value)
	}
	if !u.Date.IsZero() {
		return visitor.VisitDate(u.Date)
	}
	if !u.Datetime.IsZero() {
		return visitor.VisitDatetime(u.Datetime)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithUnknown struct {
	Type    string
	Foo     *Foo
	Unknown interface{}
}

func (u *UnionWithUnknown) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "foo":
		value := new(Foo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Foo = value
	case "unknown":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Unknown = value
	}
	return nil
}

func (u UnionWithUnknown) MarshalJSON() ([]byte, error) {
	if u.Foo != nil {
		return core.MarshalJSONWithExtraProperty(u.Foo, "type", "foo")
	}
	if u.Unknown != nil {
		var marshaler = struct {
			Type    string      `json:"type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    "unknown",
			Unknown: u.Unknown,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithUnknownVisitor interface {
	VisitFoo(*Foo) error
	VisitUnknown(interface{}) error
}

func (u *UnionWithUnknown) Accept(visitor UnionWithUnknownVisitor) error {
	if u.Foo != nil {
		return visitor.VisitFoo(u.Foo)
	}
	if u.Unknown != nil {
		return visitor.VisitUnknown(u.Unknown)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithoutKey struct {
	Type string
	Foo  *Foo
	// This is a bar field.
	Bar *Bar
}

func (u *UnionWithoutKey) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "foo":
		value := new(Foo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Foo = value
	case "bar":
		value := new(Bar)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Bar = value
	}
	return nil
}

func (u UnionWithoutKey) MarshalJSON() ([]byte, error) {
	if u.Foo != nil {
		return core.MarshalJSONWithExtraProperty(u.Foo, "type", "foo")
	}
	if u.Bar != nil {
		return core.MarshalJSONWithExtraProperty(u.Bar, "type", "bar")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnionWithoutKeyVisitor interface {
	VisitFoo(*Foo) error
	VisitBar(*Bar) error
}

func (u *UnionWithoutKey) Accept(visitor UnionWithoutKeyVisitor) error {
	if u.Foo != nil {
		return visitor.VisitFoo(u.Foo)
	}
	if u.Bar != nil {
		return visitor.VisitBar(u.Bar)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", u)
}

type Circle struct {
	Radius float64 `json:"radius" url:"radius"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Circle) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Circle) UnmarshalJSON(data []byte) error {
	type unmarshaler Circle
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Circle(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Circle) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type GetShapeRequest struct {
	Id string `json:"id" url:"id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetShapeRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetShapeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetShapeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetShapeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetShapeRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type Square struct {
	Length float64 `json:"length" url:"length"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Square) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Square) UnmarshalJSON(data []byte) error {
	type unmarshaler Square
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Square(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Square) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}
