// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`open api parser uploadcare docs 1`] = `
{
  "definitionFiles": {
    "groups.yml": {
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "display-name": "Groups",
        "endpoints": {
          "createFilesGroup": {
            "auth": false,
            "display-name": "Create a file group",
            "docs": "Create a file group from a set of already uploaded files.

The most common use case for creating a file group is when a user uploads
multiple files at once and then wants to display them together.

**Note:** A group itself and files within it MUST belong to the same project.

**Note:** Groups are immutable and the only way to add/remove a file to a group
is to create a new one.
",
            "errors": [
              "root.CreateFilesGroupRequestBadRequestError",
              "root.CreateFilesGroupRequestForbiddenError",
            ],
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { group } from '@uploadcare/upload-client'

const result = await group(
  [
    'd6d34fa9-addd-472c-868d-2e5c105f9fcd',
    'b1026315-8116-4632-8364-607e64fca723/-/resize/x800/'
  ],
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$result = $uploader->groupFiles(['d6d34fa9-addd-472c-868d-2e5c105f9fcd', 'b1026315-8116-4632-8364-607e64fca723/-/resize/x800/']);
echo \\sprintf('Response status is %s', $result->getStatusCode());
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, File, FileGroup

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file_1 = uploadcare.file('d6d34fa9-addd-472c-868d-2e5c105f9fcd')
file_2 = uploadcare.file('b1026315-8116-4632-8364-607e64fca723/-/resize/x800/')
file_group = uploadcare.create_file_group([file_1, file_2])
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"

uuids = [
  'd6d34fa9-addd-472c-868d-2e5c105f9fcd',
  'b1026315-8116-4632-8364-607e64fca723/-/resize/x800/'
]
group = Uploadcare::Group.create(uuids)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let filesIds = ["d6d34fa9-addd-472c-868d-2e5c105f9fcd", "b1026315-8116-4632-8364-607e64fca723/-/resize/x800/"]
let group = try await uploadAPI.createFilesGroup(fileIds: filesIds)
print(group)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uuids = listOf(
    "d6d34fa9-addd-472c-868d-2e5c105f9fcd",
    "b1026315-8116-4632-8364-607e64fca723/-/resize/x800/"
)
val group = uploadcare.createGroup(fileIds = uuids)
Log.d("TAG", group.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "request": {
                  "files[]": [
                    "files[]",
                  ],
                  "pub_key": "caa9d29da887ee88ffe6",
                },
                "response": {
                  "body": {
                    "cdn_url": "https://ucarecdn.com/0d712319-b970-4602-850c-bae1ced521a6~1/",
                    "datetime_created": "2018-09-12T10:03:38Z",
                    "datetime_stored": "2024-01-15T09:30:00Z",
                    "files": [
                      {
                        "content_info": {
                          "image": {
                            "color_mode": "RGB",
                            "dpi": [
                              72,
                              72,
                            ],
                            "format": "JPEG",
                            "geo_location": {
                              "latitude": 55.62013611111111,
                              "longitude": 37.66299166666666,
                            },
                            "height": 4032,
                            "orientation": 6,
                            "sequence": false,
                            "width": 3024,
                          },
                          "mime": {
                            "mime": "image/jpeg",
                            "subtype": "jpeg",
                            "type": "image",
                          },
                        },
                        "default_effects": "resize/x800/",
                        "done": 2667636,
                        "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                        "filename": "IMG0412_123.JPG",
                        "image_info": {
                          "color_mode": "RGB",
                          "dpi": [
                            72,
                            72,
                          ],
                          "format": "JPEG",
                          "geo_location": {
                            "latitude": 55.62013611111111,
                            "longitude": 37.66299166666666,
                          },
                          "height": 4032,
                          "orientation": 6,
                          "sequence": false,
                          "width": 3024,
                        },
                        "is_image": true,
                        "is_ready": true,
                        "is_stored": true,
                        "metadata": {
                          "pet": "cat",
                          "subsystem": "uploader",
                        },
                        "mime_type": "image/jpeg",
                        "original_filename": "IMG-0412_123.JPG",
                        "size": 2667636,
                        "total": 2667636,
                        "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                      },
                    ],
                    "files_count": 1,
                    "id": "0d712319-b970-4602-850c-bae1ced521a6~1",
                    "url": "https://api.uploadcare.com/groups/0d712319-b970-4602-850c-bae1ced521a6~1/",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/group/",
            "request": {
              "body": {
                "properties": {
                  "expire": "optional<root.ExpireType>",
                  "files[]": {
                    "docs": "Set of files you want to add to the group.
Each element can be a file UUID with or without the applied image
processing operations.
",
                    "type": "list<string>",
                  },
                  "pub_key": "root.ProjectPublicKeyType",
                  "signature": "optional<root.SignatureType>",
                },
              },
              "content-type": "multipart/form-data",
              "headers": undefined,
              "name": "CreateFilesGroupRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "The group was created successfully.",
              "type": "root.GroupInfo",
            },
          },
          "filesGroupInfo": {
            "auth": false,
            "display-name": "Get information about a file group",
            "docs": "Returns a JSON object with information about a file group (when the group was created,
number of the files in the group, etc).
",
            "errors": [
              "root.FilesGroupInfoRequestBadRequestError",
              "root.FilesGroupInfoRequestForbiddenError",
              "root.FilesGroupInfoRequestNotFoundError",
            ],
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { groupInfo } from '@uploadcare/upload-client'

const result = await groupInfo(
  '0d712319-b970-4602-850c-bae1ced521a6~1',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$groupInfo = $uploader->groupInfo('0d712319-b970-4602-850c-bae1ced521a6~1');
echo $groupInfo->getBody()->getContents();
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, FileGroup

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file_group = uploadcare.file_group('0d712319-b970-4602-850c-bae1ced521a6~1')
print(file_group.info)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

uuid = '0d712319-b970-4602-850c-bae1ced521a6~1'
info = Uploadcare::Group.info(uuid)
puts info.inspect
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let group = try await uploadcare.uploadAPI.filesGroupInfo(groupId: "0d712319-b970-4602-850c-bae1ced521a6~1")
print(group)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val group = uploadcare.getUploadedGroup(groupId = "0d712319-b970-4602-850c-bae1ced521a6~1")
Log.d("TAG", group.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "query-parameters": {
                  "group_id": "d52d7136-a2e5-4338-9f45-affbf83b857d~2",
                  "pub_key": "caa9d29da887ee88ffe6",
                },
                "response": {
                  "body": {
                    "cdn_url": "https://ucarecdn.com/0d712319-b970-4602-850c-bae1ced521a6~1/",
                    "datetime_created": "2018-09-12T10:03:38Z",
                    "datetime_stored": "2024-01-15T09:30:00Z",
                    "files": [
                      {
                        "content_info": {
                          "image": {
                            "color_mode": "RGB",
                            "dpi": [
                              72,
                              72,
                            ],
                            "format": "JPEG",
                            "geo_location": {
                              "latitude": 55.62013611111111,
                              "longitude": 37.66299166666666,
                            },
                            "height": 4032,
                            "orientation": 6,
                            "sequence": false,
                            "width": 3024,
                          },
                          "mime": {
                            "mime": "image/jpeg",
                            "subtype": "jpeg",
                            "type": "image",
                          },
                        },
                        "default_effects": "resize/x800/",
                        "done": 2667636,
                        "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                        "filename": "IMG0412_123.JPG",
                        "image_info": {
                          "color_mode": "RGB",
                          "dpi": [
                            72,
                            72,
                          ],
                          "format": "JPEG",
                          "geo_location": {
                            "latitude": 55.62013611111111,
                            "longitude": 37.66299166666666,
                          },
                          "height": 4032,
                          "orientation": 6,
                          "sequence": false,
                          "width": 3024,
                        },
                        "is_image": true,
                        "is_ready": true,
                        "is_stored": true,
                        "metadata": {
                          "pet": "cat",
                          "subsystem": "uploader",
                        },
                        "mime_type": "image/jpeg",
                        "original_filename": "IMG-0412_123.JPG",
                        "size": 2667636,
                        "total": 2667636,
                        "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                      },
                    ],
                    "files_count": 1,
                    "id": "0d712319-b970-4602-850c-bae1ced521a6~1",
                    "url": "https://api.uploadcare.com/groups/0d712319-b970-4602-850c-bae1ced521a6~1/",
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/group/info/",
            "request": {
              "name": "FilesGroupInfoRequest",
              "query-parameters": {
                "group_id": {
                  "docs": "Group's unique ID. Group IDs look like \`UUID~N\`, where the \`~N\` part reflects the number of the files in the group.
",
                  "type": "string",
                },
                "pub_key": "root.ProjectPublicKeyType",
              },
            },
            "response": {
              "docs": "File group information was retrieved successfully.",
              "type": "root.GroupInfo",
            },
          },
        },
      },
    },
    "upload.yml": {
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "display-name": "Upload",
        "endpoints": {
          "baseUpload": {
            "auth": false,
            "display-name": "Direct uploads",
            "docs": "Direct file uploads comply with the [RFC 7578](https://www.rfc-editor.org/rfc/rfc7578) standard.
In other words, you can perform a direct upload by making an HTTP POST request with the Content-Type
header set to \`multipart/form-data\`.

**Note**: Direct file uploads support files smaller than 100 megabytes only.
If you would like to upload larger files, please use [Multipart Uploads](/api-refs/upload-api/#operation/multipartFileUploadStart) instead.

File upload example with curl:

\`\`\`
curl -F "UPLOADCARE_PUB_KEY=YOUR_PUBLIC_KEY" -F "my_file.jpg=@my_file.jpg" "https://upload.uploadcare.com/base/"
\`\`\`
",
            "errors": [
              "root.BaseUploadRequestBadRequestError",
              "root.BaseUploadRequestForbiddenError",
              "root.BaseUploadRequestContentTooLargeError",
              "root.BaseUploadRequestTooManyRequestsError",
            ],
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { base } from '@uploadcare/upload-client'

// fileData must be \`Blob\` or \`File\` or \`Buffer\`
const result = await base(
  fileData,
  {
    publicKey: 'YOUR_PUBLIC_KEY',
    store: 'auto',
    metadata: {
      subsystem: 'uploader',
      pet: 'cat'
    }
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$fileInfo = $uploader->fromPath(__DIR__ . '/squirrel.jpg', null, null, 'auto', [
    'system' => 'php-uploader',
    'pet' => 'cat',
]);
echo \\sprintf("URL: %s, ID: %s, Mime type: %s\\n", $fileInfo->getUrl(), $fileInfo->getUuid(), $fileInfo->getMimeType());
foreach ($fileInfo->getMetadata() as $key => $value) {
    echo \\sprintf("%s: %s\\n", $key, $value);
}
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
with open('test1.txt', 'rb') as file_object:
    ucare_file = uploadcare.upload(file_object)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

source_file = File.open('image.png')
uploaded_file = Uploadcare::Uploader.upload(source_file, store: auto)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

guard let url = Bundle.main.url(forResource: "squirrel", withExtension: "jpg"),
      let data = try? Data(contentsOf: url) else { return }
let metadata = ["subsystem": "uploader", "pet": "cat"]

let file = try await uploadcare.uploadFile(data, withName: "random_file_name.jpg", store: .auto) { progress in
  print("progress: \\(progress)")
}
prkint(file)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uri = "content://com.android.providers.media.documents/document/image%3A1000001178".toUri()
val file = FileUploader(uploadcare, uri = uri, context = context).upload()
Log.d("TAG", file.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "request": {
                  "UPLOADCARE_PUB_KEY": "caa9d29da887ee88ffe6",
                },
                "response": {
                  "body": {
                    "filename": "filename",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/base/",
            "request": {
              "body": {
                "properties": {
                  "UPLOADCARE_PUB_KEY": "root.ProjectPublicKeyType",
                  "UPLOADCARE_STORE": "optional<root.StoreType>",
                  "expire": "optional<root.ExpireType>",
                  "metadata[{key}]": "optional<root.MetadataValue>",
                  "signature": "optional<root.SignatureType>",
                  "{filename}": "list<file>",
                },
              },
              "content-type": "multipart/form-data",
              "headers": undefined,
              "name": "BaseUploadRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "The file was uploaded successfully.",
              "type": "BaseUploadResponse",
            },
          },
          "fileUploadInfo": {
            "auth": false,
            "display-name": "Get information about an uploaded file",
            "docs": "Returns a JSON object with information about an uploaded file (file size, MIME type, metadata, etc).
",
            "errors": [
              "root.FileUploadInfoRequestBadRequestError",
              "root.FileUploadInfoRequestForbiddenError",
              "root.FileUploadInfoRequestNotFoundError",
            ],
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { info } from '@uploadcare/upload-client'

const result = await info(
  'be3b4d5e-179d-460e-8a5d-69112ac86cbb',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$fileInfo = (new Uploadcare\\Api($configuration))->file()->fileInfo(string $uuid);
echo \\sprintf('URL: %s, ID: %s, Mime type: %s', $fileInfo->getUrl(), $fileInfo->getUuid(), $fileInfo->getMimeType());
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file('740e1b8c-1ad8-4324-b7ec-112c79d8eac2')
print(file.info)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

uuid = '740e1b8c-1ad8-4324-b7ec-112c79d8eac2'
info = Uploadcare::File.info(uuid)
puts info.inspect
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let file = try await uploadcare.uploadAPI.fileInfo(withFileId: "740e1b8c-1ad8-4324-b7ec-112c79d8eac2")
print(file)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val file = uploadcare.getUploadedFile(fileId = "740e1b8c-1ad8-4324-b7ec-112c79d8eac2")
Log.d("TAG", file.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "query-parameters": {
                  "file_id": "67947755-1584-4e3f-902b-d4e2bf76a841",
                  "pub_key": "caa9d29da887ee88ffe6",
                },
                "response": {
                  "body": {
                    "content_info": {
                      "image": {
                        "color_mode": "RGB",
                        "datetime_original": "2024-01-15T09:30:00Z",
                        "dpi": [
                          72,
                          72,
                        ],
                        "format": "JPEG",
                        "geo_location": {
                          "latitude": 55.62013611111111,
                          "longitude": 37.66299166666666,
                        },
                        "height": 4032,
                        "orientation": 6,
                        "sequence": false,
                        "width": 3024,
                      },
                      "mime": {
                        "mime": "image/jpeg",
                        "subtype": "jpeg",
                        "type": "image",
                      },
                      "video": {
                        "audio": [
                          {
                            "bitrate": 78,
                            "channels": 2,
                            "codec": "aac",
                            "sample_rate": 44100,
                          },
                        ],
                        "bitrate": 393,
                        "duration": 261827,
                        "format": "mp4",
                        "video": [
                          {
                            "bitrate": 315,
                            "codec": "h264",
                            "frame_rate": 30,
                            "height": 360,
                            "width": 640,
                          },
                        ],
                      },
                    },
                    "done": 2667636,
                    "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                    "filename": "IMG0412_123.JPG",
                    "image_info": {
                      "color_mode": "RGB",
                      "datetime_original": "2024-01-15T09:30:00Z",
                      "dpi": [
                        72,
                        72,
                      ],
                      "format": "JPEG",
                      "geo_location": {
                        "latitude": 55.62013611111111,
                        "longitude": 37.66299166666666,
                      },
                      "height": 4032,
                      "orientation": 6,
                      "sequence": false,
                      "width": 3024,
                    },
                    "is_image": true,
                    "is_ready": true,
                    "is_stored": true,
                    "metadata": {
                      "pet": "cat",
                      "subsystem": "uploader",
                    },
                    "mime_type": "image/jpeg",
                    "original_filename": "IMG-0412_123.JPG",
                    "s3_bucket": "custom-s3-bucket-name",
                    "size": 2667636,
                    "total": 2667636,
                    "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                    "video_info": {
                      "audio": {
                        "bitrate": 78,
                        "channels": "2",
                        "codec": "aac",
                        "sample_rate": 44100,
                      },
                      "bitrate": 393,
                      "duration": 261827,
                      "format": "mp4",
                      "video": {
                        "bitrate": 315,
                        "codec": "h264",
                        "frame_rate": 30,
                        "height": 360,
                        "width": 640,
                      },
                    },
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/info/",
            "request": {
              "name": "FileUploadInfoRequest",
              "query-parameters": {
                "file_id": {
                  "docs": "File's unique ID.",
                  "type": "string",
                },
                "pub_key": "root.ProjectPublicKeyType",
              },
            },
            "response": {
              "docs": "File information was retrieved successfully.",
              "type": "root.FileUploadInfo",
            },
          },
          "fromURLUpload": {
            "auth": false,
            "display-name": "Upload files from URLs",
            "docs": "Uploadcare can fetch a file from a publicly available URL and then automatically upload the
fetched file to your project.

#### Upload tokens
Requests to the endpoint return a JSON dictionary with a \`token\` that can be further used
to [check the status](/api-refs/upload-api/#operation/fromURLUploadStatus) of the upload
request.

**Note:** The token is not a file ID and can't be used to address the file directly.
The actual file ID should be retrieved by calling the \`/from_url/status/\` endpoint.

#### Duplicates prevention
By default, every call to the \`/from_url/\` endpoint with the same \`source_url\` results in
a new upload leading to file duplication.

If you would like Uploadcare to keep track of the requested URLs and avoid the duplicate
uploads, pass the \`save_URL_duplicates\` and \`check_URL_duplicates\` parameters described below.
",
            "errors": [
              "root.FromUrlUploadRequestBadRequestError",
              "root.FromUrlUploadRequestForbiddenError",
              "root.FromUrlUploadRequestTooManyRequestsError",
            ],
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { fromUrl } from '@uploadcare/upload-client'

const result = await fromUrl(
  'https://source.unsplash.com/featured',
  {
    publicKey: 'YOUR_PUBLIC_KEY',
    metadata: {
      subsystem: 'uploader',
      pet: 'cat'
    }
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$url = 'https://source.unsplash.com/featured';
$token = $uploader->fromUrl($url, null, null, 'auto', [
    'action' => 'upload from URL', // The "Action" is the metadata key
    'checkDuplicates' => true,
    'storeDuplicates' => false,
]);
echo \\sprintf('Upload from URL \\'%s\\' has been started. Token is %s', $url, $token);
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
ucare_file = uploadcare.upload_from_url_sync(
    "https://source.unsplash.com/featured",
    check_duplicates=True,
    save_duplicates=False
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"

source_url = "https://source.unsplash.com/featured"
uploaded_file = Uploadcare::Uploader.upload(source_url, store: auto)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let url = URL(string: "https://source.unsplash.com/featured")!
let task = UploadFromURLTask(sourceUrl: url)
  .store(.auto)
  .setMetadata("uploader", forKey: "subsystem")
  .setMetadata("cat", forKey: "pet")

let file = try await uploadcare.uploadAPI.uploadAndWaitForCompletion(task: task)
print(file)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uploader = UrlUploader(
    client = uploadcare,
    sourceUrl = "https://source.unsplash.com/featured"
)
val file = uploader.upload()
Log.d("TAG", file.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "name": "type-token",
                "request": {
                  "pub_key": "caa9d29da887ee88ffe6",
                  "source_url": "source_url",
                },
                "response": {
                  "body": {
                    "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                    "type": "token",
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import { fromUrl } from '@uploadcare/upload-client'

const result = await fromUrl(
  'https://source.unsplash.com/featured',
  {
    publicKey: 'YOUR_PUBLIC_KEY',
    metadata: {
      subsystem: 'uploader',
      pet: 'cat'
    }
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$url = 'https://source.unsplash.com/featured';
$token = $uploader->fromUrl($url, null, null, 'auto', [
    'action' => 'upload from URL', // The "Action" is the metadata key
    'checkDuplicates' => true,
    'storeDuplicates' => false,
]);
echo \\sprintf('Upload from URL \\'%s\\' has been started. Token is %s', $url, $token);
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
ucare_file = uploadcare.upload_from_url_sync(
    "https://source.unsplash.com/featured",
    check_duplicates=True,
    save_duplicates=False
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"

source_url = "https://source.unsplash.com/featured"
uploaded_file = Uploadcare::Uploader.upload(source_url, store: auto)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let url = URL(string: "https://source.unsplash.com/featured")!
let task = UploadFromURLTask(sourceUrl: url)
  .store(.auto)
  .setMetadata("uploader", forKey: "subsystem")
  .setMetadata("cat", forKey: "pet")

let file = try await uploadcare.uploadAPI.uploadAndWaitForCompletion(task: task)
print(file)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uploader = UrlUploader(
    client = uploadcare,
    sourceUrl = "https://source.unsplash.com/featured"
)
val file = uploader.upload()
Log.d("TAG", file.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "name": "type-file-info",
                "request": {
                  "pub_key": "caa9d29da887ee88ffe6",
                  "source_url": "source_url",
                },
                "response": {
                  "body": {
                    "content_info": {
                      "image": {
                        "color_mode": "RGB",
                        "datetime_original": "2024-01-15T09:30:00Z",
                        "dpi": [
                          72,
                          72,
                        ],
                        "format": "JPEG",
                        "geo_location": {
                          "latitude": 55.62013611111111,
                          "longitude": 37.66299166666666,
                        },
                        "height": 4032,
                        "orientation": 6,
                        "sequence": false,
                        "width": 3024,
                      },
                      "mime": {
                        "mime": "image/jpeg",
                        "subtype": "jpeg",
                        "type": "image",
                      },
                      "video": {
                        "audio": [
                          {
                            "bitrate": 78,
                            "channels": 2,
                            "codec": "aac",
                            "sample_rate": 44100,
                          },
                        ],
                        "bitrate": 393,
                        "duration": 261827,
                        "format": "mp4",
                        "video": [
                          {
                            "bitrate": 315,
                            "codec": "h264",
                            "frame_rate": 30,
                            "height": 360,
                            "width": 640,
                          },
                        ],
                      },
                    },
                    "done": 2667636,
                    "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                    "filename": "IMG0412_123.JPG",
                    "image_info": {
                      "color_mode": "RGB",
                      "datetime_original": "2024-01-15T09:30:00Z",
                      "dpi": [
                        72,
                        72,
                      ],
                      "format": "JPEG",
                      "geo_location": {
                        "latitude": 55.62013611111111,
                        "longitude": 37.66299166666666,
                      },
                      "height": 4032,
                      "orientation": 6,
                      "sequence": false,
                      "width": 3024,
                    },
                    "is_image": true,
                    "is_ready": true,
                    "is_stored": true,
                    "metadata": {
                      "pet": "cat",
                      "subsystem": "uploader",
                    },
                    "mime_type": "image/jpeg",
                    "original_filename": "IMG-0412_123.JPG",
                    "s3_bucket": "custom-s3-bucket-name",
                    "size": 2667636,
                    "total": 2667636,
                    "type": "file_info",
                    "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                    "video_info": {
                      "audio": {
                        "bitrate": 78,
                        "channels": "2",
                        "codec": "aac",
                        "sample_rate": 44100,
                      },
                      "bitrate": 393,
                      "duration": 261827,
                      "format": "mp4",
                      "video": {
                        "bitrate": 315,
                        "codec": "h264",
                        "frame_rate": 30,
                        "height": 360,
                        "width": 640,
                      },
                    },
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/from_url/",
            "request": {
              "body": {
                "properties": {
                  "check_URL_duplicates": {
                    "default": "0",
                    "docs": "If set to "1", enables the \`source_url\` duplicates prevention.
Specifically, if the \`source_url\` had already been fetched and uploaded previously,
this request will return information about the already uploaded file.
",
                    "type": "optional<FromUrlUploadRequestCheckUrlDuplicates>",
                  },
                  "expire": "optional<root.ExpireType>",
                  "filename": {
                    "docs": "Sets the file name of the resource fetched from the source URL.
If not defined, the file name is obtained from either HTTP
response headers or the \`source_url\`'s path.

**Note:** The filename will be sanitized to only contain the following symbols:
\`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._\`.
",
                    "type": "optional<string>",
                  },
                  "metadata[{key}]": "optional<root.MetadataValue>",
                  "pub_key": "root.ProjectPublicKeyType",
                  "save_URL_duplicates": {
                    "docs": "Determines if the requested \`source_url\` should be kept in the history of
fetched/uploaded URLs. If the value is not defined explicitly, it is set
to the value of the \`check_URL_duplicates\` parameter.
",
                    "type": "optional<FromUrlUploadRequestSaveUrlDuplicates>",
                  },
                  "signature": "optional<root.SignatureType>",
                  "source_url": {
                    "docs": "Source URL of the file to fetch and upload.

**Note**: The URL should point to a resource publicly available via HTTP/HTTPS.
",
                    "type": "string",
                    "validation": {
                      "format": "uri",
                      "maxLength": undefined,
                      "minLength": undefined,
                      "pattern": undefined,
                    },
                  },
                  "store": "optional<root.StoreType>",
                },
              },
              "content-type": "multipart/form-data",
              "headers": undefined,
              "name": "FromUrlUploadRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Status Token or File Info of an already downloaded file.",
              "type": "FromUrlUploadResponse",
            },
          },
          "fromURLUploadStatus": {
            "auth": false,
            "display-name": "Check the status of a task to fetch/upload a file from a URL",
            "docs": "The endpoint notifies about the progress of the task by changing the value of the \`status\` field:
  * the field is set to \`waiting\` initially
  * once the system starts processing the request, the field is set to \`progress\`
  * if the file is fetched and uploaded successfully, the \`status\` field is set to \`success\`
    and the endpoint returns a JSON object holding information about the uploaded file
  * if the system fails to fetch/upload the file, the \`status\` field is set to \`error\` and
    the \`error\` field is set to the cause of the error.
",
            "errors": [
              "root.FromUrlUploadStatusRequestBadRequestError",
            ],
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { fromUrlStatus } from '@uploadcare/upload-client'

const result = await fromUrlStatus(
  '945ebb27-1fd6-46c6-a859-b9893712d650',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$status = $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');
echo \\sprintf('Upload status is %s', $status);
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')
print(file.info)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

token = '945ebb27-1fd6-46c6-a859-b9893712d650'
puts Uploadcare::Uploader.get_upload_from_url_status(token)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let status = try await uploadcare.uploadAPI.uploadStatus(forToken: "945ebb27-1fd6-46c6-a859-b9893712d650")
print(status)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val status = uploadcare.getFromUrlStatus(token = "945ebb27-1fd6-46c6-a859-b9893712d650")
Log.d("TAG", status.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "name": "status-waiting",
                "query-parameters": {
                  "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                },
                "response": {
                  "body": {
                    "status": "waiting",
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import { fromUrlStatus } from '@uploadcare/upload-client'

const result = await fromUrlStatus(
  '945ebb27-1fd6-46c6-a859-b9893712d650',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$status = $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');
echo \\sprintf('Upload status is %s', $status);
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')
print(file.info)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

token = '945ebb27-1fd6-46c6-a859-b9893712d650'
puts Uploadcare::Uploader.get_upload_from_url_status(token)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let status = try await uploadcare.uploadAPI.uploadStatus(forToken: "945ebb27-1fd6-46c6-a859-b9893712d650")
print(status)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val status = uploadcare.getFromUrlStatus(token = "945ebb27-1fd6-46c6-a859-b9893712d650")
Log.d("TAG", status.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "name": "status-progress",
                "query-parameters": {
                  "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                },
                "response": {
                  "body": {
                    "done": 134427,
                    "status": "progress",
                    "total": 732434,
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import { fromUrlStatus } from '@uploadcare/upload-client'

const result = await fromUrlStatus(
  '945ebb27-1fd6-46c6-a859-b9893712d650',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$status = $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');
echo \\sprintf('Upload status is %s', $status);
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')
print(file.info)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

token = '945ebb27-1fd6-46c6-a859-b9893712d650'
puts Uploadcare::Uploader.get_upload_from_url_status(token)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let status = try await uploadcare.uploadAPI.uploadStatus(forToken: "945ebb27-1fd6-46c6-a859-b9893712d650")
print(status)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val status = uploadcare.getFromUrlStatus(token = "945ebb27-1fd6-46c6-a859-b9893712d650")
Log.d("TAG", status.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "name": "status-success",
                "query-parameters": {
                  "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                },
                "response": {
                  "body": {
                    "content_info": {
                      "image": {
                        "color_mode": "RGB",
                        "datetime_original": "2024-01-15T09:30:00Z",
                        "dpi": [
                          72,
                          72,
                        ],
                        "format": "JPEG",
                        "geo_location": {
                          "latitude": 55.62013611111111,
                          "longitude": 37.66299166666666,
                        },
                        "height": 4032,
                        "orientation": 6,
                        "sequence": false,
                        "width": 3024,
                      },
                      "mime": {
                        "mime": "image/jpeg",
                        "subtype": "jpeg",
                        "type": "image",
                      },
                      "video": {
                        "audio": [
                          {
                            "bitrate": 78,
                            "channels": 2,
                            "codec": "aac",
                            "sample_rate": 44100,
                          },
                        ],
                        "bitrate": 393,
                        "duration": 261827,
                        "format": "mp4",
                        "video": [
                          {
                            "bitrate": 315,
                            "codec": "h264",
                            "frame_rate": 30,
                            "height": 360,
                            "width": 640,
                          },
                        ],
                      },
                    },
                    "done": 2667636,
                    "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                    "filename": "IMG0412_123.JPG",
                    "image_info": {
                      "color_mode": "RGB",
                      "datetime_original": "2024-01-15T09:30:00Z",
                      "dpi": [
                        72,
                        72,
                      ],
                      "format": "JPEG",
                      "geo_location": {
                        "latitude": 55.62013611111111,
                        "longitude": 37.66299166666666,
                      },
                      "height": 4032,
                      "orientation": 6,
                      "sequence": false,
                      "width": 3024,
                    },
                    "is_image": true,
                    "is_ready": true,
                    "is_stored": true,
                    "metadata": {
                      "pet": "cat",
                      "subsystem": "uploader",
                    },
                    "mime_type": "image/jpeg",
                    "original_filename": "IMG-0412_123.JPG",
                    "s3_bucket": "custom-s3-bucket-name",
                    "size": 2667636,
                    "status": "success",
                    "total": 2667636,
                    "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                    "video_info": {
                      "audio": {
                        "bitrate": 78,
                        "channels": "2",
                        "codec": "aac",
                        "sample_rate": 44100,
                      },
                      "bitrate": 393,
                      "duration": 261827,
                      "format": "mp4",
                      "video": {
                        "bitrate": 315,
                        "codec": "h264",
                        "frame_rate": 30,
                        "height": 360,
                        "width": 640,
                      },
                    },
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import { fromUrlStatus } from '@uploadcare/upload-client'

const result = await fromUrlStatus(
  '945ebb27-1fd6-46c6-a859-b9893712d650',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$status = $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');
echo \\sprintf('Upload status is %s', $status);
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')
print(file.info)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

token = '945ebb27-1fd6-46c6-a859-b9893712d650'
puts Uploadcare::Uploader.get_upload_from_url_status(token)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let status = try await uploadcare.uploadAPI.uploadStatus(forToken: "945ebb27-1fd6-46c6-a859-b9893712d650")
print(status)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val status = uploadcare.getFromUrlStatus(token = "945ebb27-1fd6-46c6-a859-b9893712d650")
Log.d("TAG", status.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "name": "status-error",
                "query-parameters": {
                  "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                },
                "response": {
                  "body": {
                    "error": "HTTP client error: 404.",
                    "error_code": "DownloadFileHTTPClientError",
                    "status": "error",
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import { fromUrlStatus } from '@uploadcare/upload-client'

const result = await fromUrlStatus(
  '945ebb27-1fd6-46c6-a859-b9893712d650',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$status = $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');
echo \\sprintf('Upload status is %s', $status);
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')
print(file.info)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

token = '945ebb27-1fd6-46c6-a859-b9893712d650'
puts Uploadcare::Uploader.get_upload_from_url_status(token)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let status = try await uploadcare.uploadAPI.uploadStatus(forToken: "945ebb27-1fd6-46c6-a859-b9893712d650")
print(status)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val status = uploadcare.getFromUrlStatus(token = "945ebb27-1fd6-46c6-a859-b9893712d650")
Log.d("TAG", status.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "name": "status-unknown",
                "query-parameters": {
                  "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                },
                "response": {
                  "body": {
                    "status": "unknown",
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/from_url/status/",
            "request": {
              "name": "FromUrlUploadStatusRequest",
              "query-parameters": {
                "token": {
                  "docs": "Token returned by the \`/from_url/\` endpoint that identifies a request to fetch/upload a file from a URL.",
                  "type": "string",
                },
              },
            },
            "response": {
              "docs": "Request was processed successfully.
",
              "type": "FromUrlUploadStatusResponse",
            },
          },
          "multipartFileUploadComplete": {
            "auth": false,
            "display-name": "Complete multipart upload",
            "docs": "Once all the file parts have been uploaded successfully, complete the
upload session to assemble all the file parts into a single resulting file.
",
            "errors": [
              "root.MultipartFileUploadCompleteRequestBadRequestError",
              "root.MultipartFileUploadCompleteRequestForbiddenError",
              "root.MultipartFileUploadCompleteRequestNotFoundError",
            ],
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { multipartComplete } from '@uploadcare/upload-client'

const result = await multipartComplete(
  '67947755-1584-4e3f-902b-d4e2bf76a841',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$path = '/path-to-large-file.zip';
$handle = \\fopen($path, 'rb');
$response = $uploader->fromResource($handle, null, null, 'auto', [
    'size' => \\filesize($path), // The "size" is the metadata key
]);
echo \\sprintf('File uploaded. ID is \\'%s\\'', $response->getUuid());
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
with open('test1.txt', 'rb') as file_object:
    ucare_file = uploadcare.multipart_upload(file_object)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

source_file = File.open('image.png')
uploaded_file = Uploadcare::Uploader.upload(source_file, store: auto)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

guard let url = Bundle.main.url(forResource: "Mona_Lisa_23mb", withExtension: "jpg"),
      let data = try? Data(contentsOf: url) else { return }

let metadata = ["subsystem": "uploader", "pet": "cat"]
let onProgress: (Double)->Void = { (progress) in
  print("progress: \\(progress)")
}

let file = try await uploadcare.uploadAPI.multipartUpload(data, withName: "Mona_Lisa_big.jpg", store: .auto, metadata: metadata, onProgress)
print(file)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uri = "content://com.android.providers.media.documents/document/image%3A1000001178".toUri()
val file = FileUploader(uploadcare, uri = uri, context = context).upload()
Log.d("TAG", file.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "request": {
                  "UPLOADCARE_PUB_KEY": "caa9d29da887ee88ffe6",
                  "uuid": "uuid",
                },
                "response": {
                  "body": {
                    "content_info": {
                      "image": {
                        "color_mode": "RGB",
                        "datetime_original": "2024-01-15T09:30:00Z",
                        "dpi": [
                          72,
                          72,
                        ],
                        "format": "JPEG",
                        "geo_location": {
                          "latitude": 55.62013611111111,
                          "longitude": 37.66299166666666,
                        },
                        "height": 4032,
                        "orientation": 6,
                        "sequence": false,
                        "width": 3024,
                      },
                      "mime": {
                        "mime": "image/jpeg",
                        "subtype": "jpeg",
                        "type": "image",
                      },
                      "video": {
                        "audio": [
                          {
                            "bitrate": 78,
                            "channels": 2,
                            "codec": "aac",
                            "sample_rate": 44100,
                          },
                        ],
                        "bitrate": 393,
                        "duration": 261827,
                        "format": "mp4",
                        "video": [
                          {
                            "bitrate": 315,
                            "codec": "h264",
                            "frame_rate": 30,
                            "height": 360,
                            "width": 640,
                          },
                        ],
                      },
                    },
                    "done": 2667636,
                    "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                    "filename": "IMG0412_123.JPG",
                    "image_info": {
                      "color_mode": "RGB",
                      "datetime_original": "2024-01-15T09:30:00Z",
                      "dpi": [
                        72,
                        72,
                      ],
                      "format": "JPEG",
                      "geo_location": {
                        "latitude": 55.62013611111111,
                        "longitude": 37.66299166666666,
                      },
                      "height": 4032,
                      "orientation": 6,
                      "sequence": false,
                      "width": 3024,
                    },
                    "is_image": true,
                    "is_ready": true,
                    "is_stored": true,
                    "metadata": {
                      "pet": "cat",
                      "subsystem": "uploader",
                    },
                    "mime_type": "image/jpeg",
                    "original_filename": "IMG-0412_123.JPG",
                    "s3_bucket": "custom-s3-bucket-name",
                    "size": 2667636,
                    "total": 2667636,
                    "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                    "video_info": {
                      "audio": {
                        "bitrate": 78,
                        "channels": "2",
                        "codec": "aac",
                        "sample_rate": 44100,
                      },
                      "bitrate": 393,
                      "duration": 261827,
                      "format": "mp4",
                      "video": {
                        "bitrate": 315,
                        "codec": "h264",
                        "frame_rate": 30,
                        "height": 360,
                        "width": 640,
                      },
                    },
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/multipart/complete/",
            "request": {
              "body": {
                "properties": {
                  "UPLOADCARE_PUB_KEY": "root.ProjectPublicKeyType",
                  "uuid": {
                    "docs": "File's UUID from the \`/multipart/start/\` endpoint.",
                    "type": "string",
                    "validation": {
                      "format": "uuid",
                      "maxLength": undefined,
                      "minLength": undefined,
                      "pattern": undefined,
                    },
                  },
                },
              },
              "content-type": "multipart/form-data",
              "headers": undefined,
              "name": "MultipartFileUploadCompleteRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "The file was uploaded successfully.",
              "type": "root.FileUploadInfo",
            },
          },
          "multipartFileUploadPart": {
            "auth": false,
            "display-name": "Upload individual file parts",
            "docs": "The second phase is about uploading the file parts to the presigned upload URLs returned from the
\`/multipart/start/\` endpoint.

Each uploaded part should be at least 5 MiB (5242880 bytes) in size except for the last one, which can be smaller.
You can upload the file parts in parallel provided that the byte order stays unchanged.

**Note**: You MUST define \`Content-Type\` header for your data.
",
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { multipartUpload } from '@uploadcare/upload-client'

// partData is a chunk of the uploaded file's content
// must be \`Blob\` or \`File\` or \`Buffer\`
const result = await multipartUpload(
  partData,
  '<presigned-url-x>'
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$path = '/path-to-large-file.zip';
$handle = \\fopen($path, 'rb');
$response = $uploader->fromResource($handle, null, null, 'auto', [
    'size' => \\filesize($path), // The "size" is the metadata key
]);
echo \\sprintf('File uploaded. ID is \\'%s\\'', $response->getUuid());
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
with open('test1.txt', 'rb') as file_object:
    ucare_file = uploadcare.multipart_upload(file_object)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

source_file = File.open('image.png')
uploaded_file = Uploadcare::Uploader.upload(source_file, store: auto)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

guard let url = Bundle.main.url(forResource: "Mona_Lisa_23mb", withExtension: "jpg"),
      let data = try? Data(contentsOf: url) else { return }

let metadata = ["subsystem": "uploader", "pet": "cat"]
let onProgress: (Double)->Void = { (progress) in
  print("progress: \\(progress)")
}

let file = try await uploadcare.uploadAPI.multipartUpload(data, withName: "Mona_Lisa_big.jpg", store: .auto, metadata: metadata, onProgress)
print(file)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uri = "content://com.android.providers.media.documents/document/image%3A1000001178".toUri()
val file = FileUploader(uploadcare, uri = uri, context = context).upload()
Log.d("TAG", file.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
              },
            ],
            "method": "PUT",
            "pagination": undefined,
            "path": "/<presigned-url-x>",
            "request": {
              "body": "bytes",
              "content-type": "application/octet-stream",
            },
          },
          "multipartFileUploadStart": {
            "auth": false,
            "display-name": "Start multipart upload",
            "docs": "Multipart uploads should be used if you need to upload files larger than 100 megabytes or if you want to
explicitly trigger [AWS S3 Transfer Acceleration](https://aws.amazon.com/s3/transfer-acceleration/).
When you use Multipart Uploads your files go straight to AWS S3 bypassing our upload instances.

To upload large files, 3 requests are sent in sequence:
1. \`/multipart/start/\`
2. \`<presigned-url-x>\`
3. \`/multipart/complete/\`.

**Note**: Multipart uploads support files larger than 10 megabytes only.
",
            "errors": [
              "root.MultipartFileUploadStartRequestBadRequestError",
              "root.MultipartFileUploadStartRequestForbiddenError",
              "root.MultipartFileUploadStartRequestTooManyRequestsError",
            ],
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { multipartStart } from '@uploadcare/upload-client'

const result = await multipartStart(
  27796904,
  {
    publicKey: 'YOUR_PUBLIC_KEY',
    store: 'auto',
    fileName: 'myfile.mp4',
    contentType: 'video/mp4',
    metadata: {
      subsystem: 'uploader',
      pet: 'cat'
    }
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$path = '/path-to-large-file.zip';
$handle = \\fopen($path, 'rb');
$response = $uploader->fromResource($handle, null, null, 'auto', [
    'size' => \\filesize($path), // The "size" is the metadata key
]);
echo \\sprintf('File uploaded. ID is \\'%s\\'', $response->getUuid());
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
with open('test1.txt', 'rb') as file_object:
    ucare_file = uploadcare.multipart_upload(file_object)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

source_file = File.open('image.png')
uploaded_file = Uploadcare::Uploader.upload(source_file, store: auto)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

guard let url = Bundle.main.url(forResource: "Mona_Lisa_23mb", withExtension: "jpg"),
      let data = try? Data(contentsOf: url) else { return }

let metadata = ["subsystem": "uploader", "pet": "cat"]
let onProgress: (Double)->Void = { (progress) in
  print("progress: \\(progress)")
}

let file = try await uploadcare.uploadAPI.multipartUpload(data, withName: "Mona_Lisa_big.jpg", store: .auto, metadata: metadata, onProgress)
print(file)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uri = "content://com.android.providers.media.documents/document/image%3A1000001178".toUri()
val file = FileUploader(uploadcare, uri = uri, context = context).upload()
Log.d("TAG", file.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "request": {
                  "UPLOADCARE_PUB_KEY": "caa9d29da887ee88ffe6",
                  "content_type": "content_type",
                  "filename": "filename",
                  "size": 1,
                },
                "response": {
                  "body": {
                    "parts": [
                      "<presigned-url-1>",
                      "<presigned-url-2>",
                      "<presigned-url-3>",
                      "<presigned-url-4>",
                      "<presigned-url-5>",
                    ],
                    "uuid": "67947755-1584-4e3f-902b-d4e2bf76a841",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/multipart/start/",
            "request": {
              "body": {
                "properties": {
                  "UPLOADCARE_PUB_KEY": "root.ProjectPublicKeyType",
                  "UPLOADCARE_STORE": "optional<root.StoreType>",
                  "content_type": {
                    "docs": "File's MIME-type.",
                    "type": "string",
                  },
                  "expire": "optional<root.ExpireType>",
                  "filename": {
                    "docs": "Original file name of the uploaded file",
                    "type": "string",
                  },
                  "metadata[{key}]": "optional<root.MetadataValue>",
                  "part_size": {
                    "default": 5242880,
                    "docs": "Multipart Uploads expect that you will split the uploaded file into equally sized
parts (except for the last part) and then will upload them to AWS S3 (possibly in parallel).
By default, we assume that you will upload the files in 5 megabyte chunks,
so we return a list of presigned AWS S3 URLs accordingly.
If you intend to upload large files (for example, larger than a gigabyte),
we recommend to bump the part size and to pass the expected chunk size
to us as a value of the \`part_size\` parameter (in bytes).
",
                    "type": "optional<integer>",
                    "validation": {
                      "exclusiveMax": undefined,
                      "exclusiveMin": undefined,
                      "max": undefined,
                      "min": 5242880,
                      "multipleOf": undefined,
                    },
                  },
                  "signature": "optional<root.SignatureType>",
                  "size": {
                    "docs": "Precise file size of the uploaded file (in bytes).
**Note**: The size should not exceed max file size cap for your project.
",
                    "type": "integer",
                  },
                },
              },
              "content-type": "multipart/form-data",
              "headers": undefined,
              "name": "MultipartFileUploadStartRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Multipart upload started successfully.",
              "type": "MultipartFileUploadStartResponse",
            },
          },
        },
      },
      "types": {
        "BaseUploadResponse": {
          "docs": "JSON object where the key is the file name of the uploaded file and
the value is the unique ID of the file on our systems.
",
          "properties": {
            "filename": {
              "type": "optional<string>",
              "validation": {
                "format": "uuid",
                "maxLength": undefined,
                "minLength": undefined,
                "pattern": undefined,
              },
            },
          },
        },
        "FromUrlUploadRequestCheckUrlDuplicates": {
          "default": "0",
          "docs": "If set to "1", enables the \`source_url\` duplicates prevention.
Specifically, if the \`source_url\` had already been fetched and uploaded previously,
this request will return information about the already uploaded file.
",
          "enum": [
            {
              "name": "Zero",
              "value": "0",
            },
            {
              "name": "One",
              "value": "1",
            },
          ],
        },
        "FromUrlUploadRequestSaveUrlDuplicates": {
          "docs": "Determines if the requested \`source_url\` should be kept in the history of
fetched/uploaded URLs. If the value is not defined explicitly, it is set
to the value of the \`check_URL_duplicates\` parameter.
",
          "enum": [
            {
              "name": "Zero",
              "value": "0",
            },
            {
              "name": "One",
              "value": "1",
            },
          ],
        },
        "FromUrlUploadResponse": {
          "discriminated": false,
          "docs": undefined,
          "union": [
            "root.FromUrlUploadResponseSchema",
            "root.FileUploadInfoFromUrl",
          ],
        },
        "FromUrlUploadStatusResponse": {
          "discriminated": false,
          "docs": undefined,
          "union": [
            "root.FileUploadInfoWaitingStatus",
            "root.FileUploadInfoProgressStatus",
            "root.FileUploadInfoSuccessStatus",
            "root.FileUploadInfoErrorStatus",
            "root.FileUploadInfoUnknownStatus",
          ],
        },
        "MultipartFileUploadStartResponse": {
          "docs": undefined,
          "properties": {
            "parts": "list<string>",
            "uuid": {
              "docs": "File's UUID.",
              "type": "string",
              "validation": {
                "format": "uuid",
                "maxLength": undefined,
                "minLength": undefined,
                "pattern": undefined,
              },
            },
          },
        },
      },
    },
  },
  "packageMarkerFile": {
    "errors": {
      "BaseUploadRequestBadRequestError": {
        "docs": "Request failed input parameters validation.",
        "examples": [
          {
            "docs": undefined,
            "name": "request-fields-number-limit-exceeded",
            "value": "The request contains too many HTTP POST fields.",
          },
          {
            "docs": undefined,
            "name": "post-request-parser-failed",
            "value": "HTTP POST request parsing failed.",
          },
          {
            "docs": undefined,
            "name": "null-characters-forbidden",
            "value": "Null characters are not allowed.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-key-duplicate",
            "value": "File's metadata key \`subsystem\` has a duplicate.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-key-empty",
            "value": "File's metadata key can not be empty.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-key-forbidden",
            "value": "File's metadata key \`subsystem\` contains symbols not allowed by the metadata key format.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-key-length-too-big",
            "value": "Length of file metadata key \`aaa...\` can not be more than 64 symbols.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-value-empty",
            "value": "Value of the file metadata key \`subsystem\` can not be empty.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-value-forbidden",
            "value": "Value of file metadata key \`subsystem\` contains symbols not allowed by the metadata value format.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-value-length-too-big",
            "value": "Value of file metadata's key \`subsystem\` can not be more than 512 symbols in length.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-keys-number-too-big",
            "value": "A file can not have more than 50 metadata keys.",
          },
          {
            "docs": undefined,
            "name": "signature-required",
            "value": "\`signature\` is required.",
          },
          {
            "docs": undefined,
            "name": "signature-expiration-required",
            "value": "\`expire\` is required.",
          },
          {
            "docs": undefined,
            "name": "signature-expiration-invalid",
            "value": "\`expire\` must be a UNIX timestamp.",
          },
          {
            "docs": undefined,
            "name": "files-required",
            "value": "Request does not contain files.",
          },
          {
            "docs": undefined,
            "name": "file-size-limit-exceeded",
            "value": "File is too large.",
          },
          {
            "docs": undefined,
            "name": "file-type-forbidden",
            "value": "Uploading of these file types is not allowed.",
          },
          {
            "docs": undefined,
            "name": "file-infected",
            "value": "The file is infected by Win.Test.EICAR_HDB-1 virus.",
          },
        ],
        "status-code": 400,
        "type": "BaseUploadRequestBadRequestErrorBody",
      },
      "BaseUploadRequestContentTooLargeError": {
        "docs": "The size of the request is too large.",
        "examples": [
          {
            "docs": undefined,
            "name": undefined,
            "value": "The size of the request is too large.",
          },
        ],
        "status-code": 413,
        "type": "string",
      },
      "BaseUploadRequestForbiddenError": {
        "docs": "Request was not allowed.",
        "examples": [
          {
            "docs": undefined,
            "name": "public-key-is-required",
            "value": "UPLOADCARE_PUB_KEY is required.",
          },
          {
            "docs": undefined,
            "name": "public-key-is-invalid",
            "value": "UPLOADCARE_PUB_KEY is invalid.",
          },
          {
            "docs": undefined,
            "name": "auto-store-is-disabled",
            "value": "Autostore is disabled.",
          },
          {
            "docs": undefined,
            "name": "project-public-key-removed",
            "value": "Project 39e3eb895fdada95e7a9 is marked as removed.",
          },
          {
            "docs": undefined,
            "name": "account-blocked",
            "value": "Account has been blocked.",
          },
          {
            "docs": undefined,
            "name": "account-unpaid",
            "value": "Account has been blocked for non payment.",
          },
          {
            "docs": undefined,
            "name": "upload-failed",
            "value": "Upload failed.",
          },
          {
            "docs": undefined,
            "name": "account-limits-exceeded",
            "value": "Account has reached its limits.",
          },
          {
            "docs": undefined,
            "name": "signature-expiration",
            "value": "Expired signature.",
          },
          {
            "docs": undefined,
            "name": "signature-invalid",
            "value": "Invalid signature.",
          },
        ],
        "status-code": 403,
        "type": "BaseUploadRequestForbiddenErrorBody",
      },
      "BaseUploadRequestTooManyRequestsError": {
        "docs": "Request was throttled.",
        "examples": [
          {
            "docs": undefined,
            "name": undefined,
            "value": "Request was throttled.",
          },
        ],
        "status-code": 429,
        "type": "string",
      },
      "CreateFilesGroupRequestBadRequestError": {
        "docs": "Request failed input parameters validation.",
        "examples": [
          {
            "docs": undefined,
            "name": "request-fields-number-limit-exceeded",
            "value": "The request contains too many HTTP POST fields.",
          },
          {
            "docs": undefined,
            "name": "post-request-parser-failed",
            "value": "HTTP POST request parsing failed.",
          },
          {
            "docs": undefined,
            "name": "null-characters-forbidden",
            "value": "Null characters are not allowed.",
          },
          {
            "docs": undefined,
            "name": "signature-required",
            "value": "\`signature\` is required.",
          },
          {
            "docs": undefined,
            "name": "signature-expiration-required",
            "value": "\`expire\` is required.",
          },
          {
            "docs": undefined,
            "name": "signature-expiration-invalid",
            "value": "\`expire\` must be a UNIX timestamp.",
          },
          {
            "docs": undefined,
            "name": "group-files-invalid",
            "value": "This is not valid file url: wrong-uuid.",
          },
          {
            "docs": undefined,
            "name": "group-file-url-parsing-failed",
            "value": "No files[N] parameters found.",
          },
          {
            "docs": undefined,
            "name": "group-files-not-found",
            "value": "Some files not found.",
          },
        ],
        "status-code": 400,
        "type": "CreateFilesGroupRequestBadRequestErrorBody",
      },
      "CreateFilesGroupRequestForbiddenError": {
        "docs": "Request was not allowed.",
        "examples": [
          {
            "docs": undefined,
            "name": "public-key-is-required",
            "value": "pub_key is required.",
          },
          {
            "docs": undefined,
            "name": "public-key-is-invalid",
            "value": "pub_key is invalid.",
          },
          {
            "docs": undefined,
            "name": "project-public-key-removed",
            "value": "Project 39e3eb895fdada95e7a9 is marked as removed.",
          },
          {
            "docs": undefined,
            "name": "account-blocked",
            "value": "Account has been blocked.",
          },
          {
            "docs": undefined,
            "name": "account-unpaid",
            "value": "Account has been blocked for non payment.",
          },
          {
            "docs": undefined,
            "name": "upload-failed",
            "value": "Upload failed.",
          },
          {
            "docs": undefined,
            "name": "account-limits-exceeded",
            "value": "Account has reached its limits.",
          },
          {
            "docs": undefined,
            "name": "signature-expiration",
            "value": "Expired signature.",
          },
          {
            "docs": undefined,
            "name": "signature-invalid",
            "value": "Invalid signature.",
          },
        ],
        "status-code": 403,
        "type": "CreateFilesGroupRequestForbiddenErrorBody",
      },
      "FileUploadInfoRequestBadRequestError": {
        "docs": "Request failed input parameters validation.",
        "examples": [
          {
            "docs": undefined,
            "name": "null-characters-forbidden",
            "value": "Null characters are not allowed.",
          },
          {
            "docs": undefined,
            "name": "file-id-required",
            "value": "file_id is required.",
          },
          {
            "docs": undefined,
            "name": "file-id-invalid",
            "value": "file_id is invalid.",
          },
        ],
        "status-code": 400,
        "type": "FileUploadInfoRequestBadRequestErrorBody",
      },
      "FileUploadInfoRequestForbiddenError": {
        "docs": "Request was not allowed.",
        "examples": [
          {
            "docs": undefined,
            "name": "public-key-is-required",
            "value": "pub_key is required.",
          },
          {
            "docs": undefined,
            "name": "public-key-is-invalid",
            "value": "pub_key is invalid.",
          },
        ],
        "status-code": 403,
        "type": "FileUploadInfoRequestForbiddenErrorBody",
      },
      "FileUploadInfoRequestNotFoundError": {
        "docs": "File with specified UUID was not found.",
        "examples": [
          {
            "docs": undefined,
            "name": "file-not-found",
            "value": "File is not found.",
          },
        ],
        "status-code": 404,
        "type": "FileNotFoundError",
      },
      "FilesGroupInfoRequestBadRequestError": {
        "docs": "Request failed input parameters validation.",
        "examples": [
          {
            "docs": undefined,
            "name": "null-characters-forbidden",
            "value": "Null characters are not allowed.",
          },
          {
            "docs": undefined,
            "name": "group-id-required",
            "value": "group_id is required.",
          },
        ],
        "status-code": 400,
        "type": "FilesGroupInfoRequestBadRequestErrorBody",
      },
      "FilesGroupInfoRequestForbiddenError": {
        "docs": "Request was not allowed.",
        "examples": [
          {
            "docs": undefined,
            "name": "public-key-is-required",
            "value": "pub_key is required.",
          },
          {
            "docs": undefined,
            "name": "public-key-is-invalid",
            "value": "pub_key is invalid.",
          },
        ],
        "status-code": 403,
        "type": "FilesGroupInfoRequestForbiddenErrorBody",
      },
      "FilesGroupInfoRequestNotFoundError": {
        "docs": "Group with specified UUID was not found.",
        "examples": [
          {
            "docs": undefined,
            "name": "group-not-found",
            "value": "group_id is invalid.",
          },
        ],
        "status-code": 404,
        "type": "GroupNotFoundError",
      },
      "FromUrlUploadRequestBadRequestError": {
        "docs": "Request failed input parameters validation.",
        "examples": [
          {
            "docs": undefined,
            "name": "request-fields-number-limit-exceeded",
            "value": "The request contains too many HTTP POST fields.",
          },
          {
            "docs": undefined,
            "name": "post-request-parser-failed",
            "value": "HTTP POST request parsing failed.",
          },
          {
            "docs": undefined,
            "name": "null-characters-forbidden",
            "value": "Null characters are not allowed.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-key-duplicate",
            "value": "File's metadata key \`subsystem\` has a duplicate.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-key-empty",
            "value": "File's metadata key can not be empty.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-key-forbidden",
            "value": "File's metadata key \`subsystem\` contains symbols not allowed by the metadata key format.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-key-length-too-big",
            "value": "Length of file metadata key \`aaa...\` can not be more than 64 symbols.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-value-empty",
            "value": "Value of the file metadata key \`subsystem\` can not be empty.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-value-forbidden",
            "value": "Value of file metadata key \`subsystem\` contains symbols not allowed by the metadata value format.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-value-length-too-big",
            "value": "Value of file metadata's key \`subsystem\` can not be more than 512 symbols in length.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-keys-number-too-big",
            "value": "A file can not have more than 50 metadata keys.",
          },
          {
            "docs": undefined,
            "name": "signature-required",
            "value": "\`signature\` is required.",
          },
          {
            "docs": undefined,
            "name": "signature-expiration-required",
            "value": "\`expire\` is required.",
          },
          {
            "docs": undefined,
            "name": "signature-expiration-invalid",
            "value": "\`expire\` must be a UNIX timestamp.",
          },
          {
            "docs": undefined,
            "name": "source-url-required",
            "value": "source_url is required.",
          },
          {
            "docs": undefined,
            "name": "url-parsing-failed",
            "value": "Failed to parse URL.",
          },
          {
            "docs": undefined,
            "name": "url-scheme-required",
            "value": "No URL scheme supplied.",
          },
          {
            "docs": undefined,
            "name": "url-scheme-invalid",
            "value": "Invalid URL scheme.",
          },
          {
            "docs": undefined,
            "name": "url-host-required",
            "value": "No URL host supplied.",
          },
          {
            "docs": undefined,
            "name": "url-blacklisted",
            "value": "Source is blacklisted.",
          },
          {
            "docs": undefined,
            "name": "hostname-not-found",
            "value": "Host does not exist.",
          },
          {
            "docs": undefined,
            "name": "url-host-malformed",
            "value": "URL host is malformed.",
          },
          {
            "docs": undefined,
            "name": "url-host-private-ip-forbidden",
            "value": "Only public IPs are allowed.",
          },
        ],
        "status-code": 400,
        "type": "FromUrlUploadRequestBadRequestErrorBody",
      },
      "FromUrlUploadRequestForbiddenError": {
        "docs": "Request was not allowed.",
        "examples": [
          {
            "docs": undefined,
            "name": "public-key-is-required",
            "value": "pub_key is required.",
          },
          {
            "docs": undefined,
            "name": "public-key-is-invalid",
            "value": "pub_key is invalid.",
          },
          {
            "docs": undefined,
            "name": "auto-store-is-disabled",
            "value": "Autostore is disabled.",
          },
          {
            "docs": undefined,
            "name": "project-public-key-removed",
            "value": "Project 39e3eb895fdada95e7a9 is marked as removed.",
          },
          {
            "docs": undefined,
            "name": "account-blocked",
            "value": "Account has been blocked.",
          },
          {
            "docs": undefined,
            "name": "account-unpaid",
            "value": "Account has been blocked for non payment.",
          },
          {
            "docs": undefined,
            "name": "upload-failed",
            "value": "Upload failed.",
          },
          {
            "docs": undefined,
            "name": "account-limits-exceeded",
            "value": "Account has reached its limits.",
          },
          {
            "docs": undefined,
            "name": "signature-expiration",
            "value": "Expired signature.",
          },
          {
            "docs": undefined,
            "name": "signature-invalid",
            "value": "Invalid signature.",
          },
        ],
        "status-code": 403,
        "type": "FromUrlUploadRequestForbiddenErrorBody",
      },
      "FromUrlUploadRequestTooManyRequestsError": {
        "docs": "Request was throttled.",
        "examples": [
          {
            "docs": undefined,
            "name": undefined,
            "value": "Request was throttled.",
          },
        ],
        "status-code": 429,
        "type": "string",
      },
      "FromUrlUploadStatusRequestBadRequestError": {
        "docs": "Request failed input parameters validation.",
        "examples": [
          {
            "docs": undefined,
            "name": "token-required",
            "value": "token is required.",
          },
        ],
        "status-code": 400,
        "type": "TokenRequiredError",
      },
      "MultipartFileUploadCompleteRequestBadRequestError": {
        "docs": "Request failed input parameters validation.",
        "examples": [
          {
            "docs": undefined,
            "name": "request-fields-number-limit-exceeded",
            "value": "The request contains too many HTTP POST fields.",
          },
          {
            "docs": undefined,
            "name": "post-request-parser-failed",
            "value": "HTTP POST request parsing failed.",
          },
          {
            "docs": undefined,
            "name": "null-characters-forbidden",
            "value": "Null characters are not allowed.",
          },
          {
            "docs": undefined,
            "name": "multipart-file-id-required",
            "value": "uuid is required.",
          },
          {
            "docs": undefined,
            "name": "uuid-invalid",
            "value": "uuid is invalid.",
          },
          {
            "docs": undefined,
            "name": "multipart-file-already-uploaded",
            "value": "File is already uploaded.",
          },
          {
            "docs": undefined,
            "name": "multipart-upload-size-too-large",
            "value": "Uploaded size is more than expected.",
          },
          {
            "docs": undefined,
            "name": "multipart-upload-size-too-small",
            "value": "File size mismatch. Not all parts uploaded?",
          },
          {
            "docs": undefined,
            "name": "multipart-file-completion-failed",
            "value": "Can not complete upload. Wrong parts size?",
          },
          {
            "docs": undefined,
            "name": "file-type-forbidden",
            "value": "Uploading of these file types is not allowed.",
          },
          {
            "docs": undefined,
            "name": "file-infected",
            "value": "The file is infected by Win.Test.EICAR_HDB-1 virus.",
          },
        ],
        "status-code": 400,
        "type": "MultipartFileUploadCompleteRequestBadRequestErrorBody",
      },
      "MultipartFileUploadCompleteRequestForbiddenError": {
        "docs": "Request was not allowed.",
        "examples": [
          {
            "docs": undefined,
            "name": "public-key-is-required",
            "value": "UPLOADCARE_PUB_KEY is required.",
          },
          {
            "docs": undefined,
            "name": "public-key-is-invalid",
            "value": "UPLOADCARE_PUB_KEY is invalid.",
          },
        ],
        "status-code": 403,
        "type": "MultipartFileUploadCompleteRequestForbiddenErrorBody",
      },
      "MultipartFileUploadCompleteRequestNotFoundError": {
        "docs": "File with specified UUID was not found.",
        "examples": [
          {
            "docs": undefined,
            "name": "file-not-found",
            "value": "File is not found.",
          },
        ],
        "status-code": 404,
        "type": "FileNotFoundError",
      },
      "MultipartFileUploadStartRequestBadRequestError": {
        "docs": "Request failed input parameters validation.",
        "examples": [
          {
            "docs": undefined,
            "name": "request-fields-number-limit-exceeded",
            "value": "The request contains too many HTTP POST fields.",
          },
          {
            "docs": undefined,
            "name": "post-request-parser-failed",
            "value": "HTTP POST request parsing failed.",
          },
          {
            "docs": undefined,
            "name": "null-characters-forbidden",
            "value": "Null characters are not allowed.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-key-duplicate",
            "value": "File's metadata key \`subsystem\` has a duplicate.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-key-empty",
            "value": "File's metadata key can not be empty.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-key-forbidden",
            "value": "File's metadata key \`subsystem\` contains symbols not allowed by the metadata key format.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-key-length-too-big",
            "value": "Length of file metadata key \`aaa...\` can not be more than 64 symbols.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-value-empty",
            "value": "Value of the file metadata key \`subsystem\` can not be empty.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-value-forbidden",
            "value": "Value of file metadata key \`subsystem\` contains symbols not allowed by the metadata value format.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-value-length-too-big",
            "value": "Value of file metadata's key \`subsystem\` can not be more than 512 symbols in length.",
          },
          {
            "docs": undefined,
            "name": "file-metadata-keys-number-too-big",
            "value": "A file can not have more than 50 metadata keys.",
          },
          {
            "docs": undefined,
            "name": "signature-required",
            "value": "\`signature\` is required.",
          },
          {
            "docs": undefined,
            "name": "signature-expiration-required",
            "value": "\`expire\` is required.",
          },
          {
            "docs": undefined,
            "name": "signature-expiration-invalid",
            "value": "\`expire\` must be a UNIX timestamp.",
          },
          {
            "docs": undefined,
            "name": "request-param-required",
            "value": "filename is required.",
          },
          {
            "docs": undefined,
            "name": "multipart-size-invalid",
            "value": "size should be integer.",
          },
          {
            "docs": undefined,
            "name": "multipart-file-size-limit-exceeded",
            "value": "File size exceeds project limit.",
          },
          {
            "docs": undefined,
            "name": "multipart-file-size-too-small",
            "value": "File size can not be less than 10485760 bytes. Please use direct upload instead of multipart.",
          },
          {
            "docs": undefined,
            "name": "multipart-part-size-invalid",
            "value": "Multipart Upload Part Size should be an integer.",
          },
          {
            "docs": undefined,
            "name": "multipart-part-size-too-small",
            "value": "Multipart Upload Part Size can not be less than 5242880 bytes.",
          },
          {
            "docs": undefined,
            "name": "multipart-part-size-too-big",
            "value": "Multipart Upload Part Size can not be more than 5368709120 bytes.",
          },
        ],
        "status-code": 400,
        "type": "MultipartFileUploadStartRequestBadRequestErrorBody",
      },
      "MultipartFileUploadStartRequestForbiddenError": {
        "docs": "Request was not allowed.",
        "examples": [
          {
            "docs": undefined,
            "name": "public-key-is-required",
            "value": "UPLOADCARE_PUB_KEY is required.",
          },
          {
            "docs": undefined,
            "name": "public-key-is-invalid",
            "value": "UPLOADCARE_PUB_KEY is invalid.",
          },
          {
            "docs": undefined,
            "name": "auto-store-is-disabled",
            "value": "Autostore is disabled.",
          },
          {
            "docs": undefined,
            "name": "project-public-key-removed",
            "value": "Project 39e3eb895fdada95e7a9 is marked as removed.",
          },
          {
            "docs": undefined,
            "name": "account-blocked",
            "value": "Account has been blocked.",
          },
          {
            "docs": undefined,
            "name": "account-unpaid",
            "value": "Account has been blocked for non payment.",
          },
          {
            "docs": undefined,
            "name": "upload-failed",
            "value": "Upload failed.",
          },
          {
            "docs": undefined,
            "name": "account-limits-exceeded",
            "value": "Account has reached its limits.",
          },
          {
            "docs": undefined,
            "name": "signature-expiration",
            "value": "Expired signature.",
          },
          {
            "docs": undefined,
            "name": "signature-invalid",
            "value": "Invalid signature.",
          },
        ],
        "status-code": 403,
        "type": "MultipartFileUploadStartRequestForbiddenErrorBody",
      },
      "MultipartFileUploadStartRequestTooManyRequestsError": {
        "docs": "Request was throttled.",
        "examples": [
          {
            "docs": undefined,
            "name": undefined,
            "value": "Request was throttled.",
          },
        ],
        "status-code": 429,
        "type": "string",
      },
    },
    "types": {
      "AccountBlockedError": {
        "type": "string",
      },
      "AccountLimitsExceededError": {
        "type": "string",
      },
      "AccountUnpaidError": {
        "type": "string",
      },
      "AutoStoreDisabledError": {
        "type": "string",
      },
      "BaseUploadRequestBadRequestErrorBody": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "RequestFiledsNumberLimitExceededError",
          "PostRequestParserFailedError",
          "NullCharactersForbiddenError",
          "FileMetadataKeyDuplicatedError",
          "FileMetadataKeyEmptyError",
          "FileMetadataKeyForbiddenError",
          "FileMetadataKeyLengthTooBigError",
          "FileMetadataValueEmptyError",
          "FileMetadataValueForbiddenError",
          "FileMetadataValueLengthTooBigError",
          "FileMetadataKeysNumberTooBigError",
          "SignatureRequiredError",
          "SignatureExpirationRequiredError",
          "SignatureExpirationInvalidError",
          "FilesRequiredError",
          "FileSizeLimitExceededError",
          "FileTypeForbiddenError",
          "FileInfectedError",
        ],
      },
      "BaseUploadRequestForbiddenErrorBody": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "UploadcarePublicKeyRequiredError",
          "UploadcarePublicKeyInvalidError",
          "AutoStoreDisabledError",
          "ProjectPublicKeyRemovedError",
          "AccountBlockedError",
          "AccountUnpaidError",
          "UploadFailedError",
          "AccountLimitsExceededError",
          "SignatureExpirationError",
          "SignatureInvalidError",
        ],
      },
      "ContentInfo": {
        "docs": "Information about file content.",
        "properties": {
          "image": "optional<SchemasImageInfo>",
          "mime": {
            "docs": "MIME type.",
            "type": "optional<ContentInfoMime>",
          },
          "video": "optional<VideoInfo>",
        },
      },
      "ContentInfoMime": {
        "docs": "MIME type.",
        "properties": {
          "mime": {
            "docs": "Full MIME type.",
            "type": "string",
          },
          "subtype": {
            "docs": "Subtype of MIME type.",
            "type": "string",
          },
          "type": {
            "docs": "Type of MIME type.",
            "type": "string",
          },
        },
      },
      "CreateFilesGroupRequestBadRequestErrorBody": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "RequestFiledsNumberLimitExceededError",
          "PostRequestParserFailedError",
          "NullCharactersForbiddenError",
          "SignatureRequiredError",
          "SignatureExpirationRequiredError",
          "SignatureExpirationInvalidError",
          "GroupFilesInvalidError",
          "GroupFileUrlParsingFailedError",
          "GroupFilesNotFoundError",
        ],
      },
      "CreateFilesGroupRequestForbiddenErrorBody": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "PublicKeyRequiredError",
          "PublicKeyInvalidError",
          "ProjectPublicKeyRemovedError",
          "AccountBlockedError",
          "AccountUnpaidError",
          "UploadFailedError",
          "AccountLimitsExceededError",
          "SignatureExpirationError",
          "SignatureInvalidError",
        ],
      },
      "ExpireType": {
        "docs": "\`expire\` must be sent along with your upload request if you would like to use signed uploads.
The parameter defines the time during which your signature is valid. It's a UNIX timestamp.
See [signed uploads](https://uploadcare.com/docs/security/secure-uploads/) for details.
",
        "type": "double",
      },
      "FileIdInvalidError": {
        "type": "string",
      },
      "FileIdRequiredError": {
        "type": "string",
      },
      "FileInfectedError": {
        "type": "string",
      },
      "FileMetadataKeyDuplicatedError": {
        "type": "string",
      },
      "FileMetadataKeyEmptyError": {
        "type": "string",
      },
      "FileMetadataKeyForbiddenError": {
        "type": "string",
      },
      "FileMetadataKeyLengthTooBigError": {
        "type": "string",
      },
      "FileMetadataKeysNumberTooBigError": {
        "type": "string",
      },
      "FileMetadataValueEmptyError": {
        "type": "string",
      },
      "FileMetadataValueForbiddenError": {
        "type": "string",
      },
      "FileMetadataValueLengthTooBigError": {
        "type": "string",
      },
      "FileNotFoundError": {
        "type": "string",
      },
      "FileSizeLimitExceededError": {
        "type": "string",
      },
      "FileTypeForbiddenError": {
        "type": "string",
      },
      "FileUploadInfo": {
        "docs": "Information about an uploaded file.",
        "properties": {
          "content_info": "optional<ContentInfo>",
          "done": {
            "docs": "Same as \`size\`.",
            "type": "integer",
          },
          "file_id": {
            "docs": "Same as \`uuid\`",
            "type": "string",
            "validation": {
              "format": "uuid",
              "maxLength": undefined,
              "minLength": undefined,
              "pattern": undefined,
            },
          },
          "filename": {
            "docs": "Sanitized \`original_filename\`.",
            "type": "string",
          },
          "image_info": "optional<ImageInfo>",
          "is_image": {
            "docs": "True if the uploaded file is an image of a supported file format.",
            "type": "boolean",
          },
          "is_ready": {
            "docs": "True if the file is ready to be fetched from Uploadcare's CDN.",
            "type": "boolean",
          },
          "is_stored": {
            "docs": "True if the file has been marked as stored.",
            "type": "boolean",
          },
          "metadata": "optional<Metadata>",
          "mime_type": {
            "docs": "File's MIME-type.",
            "type": "string",
          },
          "original_filename": {
            "docs": "Original file of the uploaded file.",
            "type": "string",
          },
          "s3_bucket": {
            "docs": "Name of an AWS S3 bucket where the file is stored. Only available if you associate a Foreign Storage Bucket with your project.",
            "type": "optional<string>",
          },
          "size": {
            "docs": "File's size in bytes.",
            "type": "integer",
          },
          "total": {
            "docs": "Same as \`size\`.",
            "type": "integer",
          },
          "uuid": {
            "docs": "File's unique ID.",
            "type": "string",
            "validation": {
              "format": "uuid",
              "maxLength": undefined,
              "minLength": undefined,
              "pattern": undefined,
            },
          },
          "video_info": "optional<LegacyVideoInfo>",
        },
      },
      "FileUploadInfoErrorStatus": {
        "docs": undefined,
        "properties": {
          "error": {
            "docs": "Human readable description of the issue with the fetch/upload task.
",
            "type": "optional<string>",
          },
          "error_code": {
            "docs": "Machine readable error code.

Note: See the [Errors > FromURL upload errors](#tag/Errors) section of this
page for a full list of all possible error codes.
",
            "type": "optional<string>",
          },
          "status": {
            "docs": "The system failed to fetch and/or upload the file.
",
            "type": "optional<literal<"error">>",
          },
        },
      },
      "FileUploadInfoFromUrl": {
        "docs": undefined,
        "extends": [
          "FileUploadInfo",
        ],
        "properties": {
          "type": "optional<literal<"file_info">>",
        },
      },
      "FileUploadInfoProgressStatus": {
        "docs": undefined,
        "properties": {
          "done": {
            "docs": "How many bytes of the file have been fetched so far.
",
            "type": "optional<double>",
          },
          "status": {
            "docs": "The system is fetching/uploading the file.
",
            "type": "optional<literal<"progress">>",
          },
          "total": {
            "docs": "The expected size of the fetched file (in bytes).

**Note:** the value can be missing if the server we are fetching the file from
does not provide the information or if the server is returning the file in, for
example, [compressed form](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding).
",
            "type": "optional<double>",
          },
        },
      },
      "FileUploadInfoRequestBadRequestErrorBody": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "NullCharactersForbiddenError",
          "FileIdRequiredError",
          "FileIdInvalidError",
        ],
      },
      "FileUploadInfoRequestForbiddenErrorBody": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "PublicKeyRequiredError",
          "PublicKeyInvalidError",
        ],
      },
      "FileUploadInfoSuccessStatus": {
        "docs": undefined,
        "extends": [
          "FileUploadInfo",
        ],
        "properties": {
          "status": {
            "docs": "The file has been fetched/uploaded successfully.",
            "type": "optional<literal<"success">>",
          },
        },
      },
      "FileUploadInfoUnknownStatus": {
        "docs": undefined,
        "properties": {
          "status": {
            "docs": "The system does not have information about the task.

Note: Uploadcare stores information about the \`/from_url/\` tasks for a limited
period of time only. The endpoint can return the status \`unknown\` for the tasks
that are tool old (or that have not been created at all).
",
            "type": "optional<literal<"unknown">>",
          },
        },
      },
      "FileUploadInfoWaitingStatus": {
        "docs": undefined,
        "properties": {
          "status": {
            "docs": "The system is preparing to handle the request.
",
            "type": "optional<literal<"waiting">>",
          },
        },
      },
      "FilesGroupInfoRequestBadRequestErrorBody": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "NullCharactersForbiddenError",
          "GroupIdRequiredError",
        ],
      },
      "FilesGroupInfoRequestForbiddenErrorBody": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "PublicKeyRequiredError",
          "PublicKeyInvalidError",
        ],
      },
      "FilesRequiredError": {
        "type": "string",
      },
      "FromUrlUploadRequestBadRequestErrorBody": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "RequestFiledsNumberLimitExceededError",
          "PostRequestParserFailedError",
          "NullCharactersForbiddenError",
          "FileMetadataKeyDuplicatedError",
          "FileMetadataKeyEmptyError",
          "FileMetadataKeyForbiddenError",
          "FileMetadataKeyLengthTooBigError",
          "FileMetadataValueEmptyError",
          "FileMetadataValueForbiddenError",
          "FileMetadataValueLengthTooBigError",
          "FileMetadataKeysNumberTooBigError",
          "SignatureRequiredError",
          "SignatureExpirationRequiredError",
          "SignatureExpirationInvalidError",
          "SourceUrlRequiredError",
          "UrlParsingFailedError",
          "UrlSchemeRequiredError",
          "UrlSchemeInvalidError",
          "UrlHostRequiredError",
          "UrlBlacklistedError",
          "HostnameNotFoundError",
          "UrlHostMalformedError",
          "UrlHostPrivateIpForbiddenError",
        ],
      },
      "FromUrlUploadRequestForbiddenErrorBody": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "PublicKeyRequiredError",
          "PublicKeyInvalidError",
          "AutoStoreDisabledError",
          "ProjectPublicKeyRemovedError",
          "AccountBlockedError",
          "AccountUnpaidError",
          "UploadFailedError",
          "AccountLimitsExceededError",
          "SignatureExpirationError",
          "SignatureInvalidError",
        ],
      },
      "FromUrlUploadResponseSchema": {
        "docs": "\`/from_url/\` upload response.",
        "properties": {
          "token": {
            "docs": "Token to identify a \`/from_url/\` request.",
            "type": "optional<string>",
            "validation": {
              "format": "uuid",
              "maxLength": undefined,
              "minLength": undefined,
              "pattern": undefined,
            },
          },
          "type": "optional<literal<"token">>",
        },
      },
      "GroupFileUrlParsingFailedError": {
        "type": "string",
      },
      "GroupFilesInvalidError": {
        "type": "string",
      },
      "GroupFilesNotFoundError": {
        "type": "string",
      },
      "GroupIdRequiredError": {
        "type": "string",
      },
      "GroupInfo": {
        "docs": "File group information object.",
        "properties": {
          "cdn_url": {
            "docs": "Group's CDN URL.",
            "type": "optional<string>",
            "validation": {
              "format": "uri",
              "maxLength": undefined,
              "minLength": undefined,
              "pattern": undefined,
            },
          },
          "datetime_created": {
            "docs": "ISO-8601 date and time when the group was created.",
            "type": "optional<datetime>",
          },
          "datetime_stored": {
            "availability": "deprecated",
            "docs": "ISO-8601 date and time when the group was marked as stored.",
            "type": "optional<datetime>",
          },
          "files": {
            "docs": "The list of files in the group. An array may contain null values if a file has been removed.
",
            "type": "optional<list<unknown>>",
          },
          "files_count": {
            "docs": "Number of the files in the group.",
            "type": "optional<double>",
          },
          "id": {
            "docs": "Group's unique ID.",
            "type": "optional<string>",
          },
          "url": {
            "docs": "Group's API resource URL. See the [REST API](/api-refs/rest-api/) documentation for details.",
            "type": "optional<string>",
            "validation": {
              "format": "uri",
              "maxLength": undefined,
              "minLength": undefined,
              "pattern": undefined,
            },
          },
        },
      },
      "GroupNotFoundError": {
        "type": "string",
      },
      "HostnameNotFoundError": {
        "type": "string",
      },
      "ImageInfo": {
        "docs": "Image metadata.",
        "properties": {
          "color_mode": {
            "docs": "Image color mode.",
            "type": "ImageInfoColorMode",
          },
          "datetime_original": {
            "docs": "Image date and time from EXIF. Please be aware that this data is not always formatted and displayed exactly as it appears in the EXIF.",
            "type": "optional<datetime>",
          },
          "dpi": {
            "docs": "Image DPI for two dimensions.",
            "type": "optional<list<double>>",
          },
          "format": {
            "docs": "Image format.",
            "type": "string",
          },
          "geo_location": {
            "docs": "Geo-location of image from EXIF.",
            "type": "optional<ImageInfoGeoLocation>",
          },
          "height": {
            "docs": "Image height in pixels.",
            "type": "integer",
          },
          "orientation": {
            "docs": "Image orientation from EXIF.",
            "type": "optional<integer>",
            "validation": {
              "exclusiveMax": undefined,
              "exclusiveMin": undefined,
              "max": 8,
              "min": 0,
              "multipleOf": undefined,
            },
          },
          "sequence": {
            "docs": "Set to true if a file contains a sequence of images (GIF for example).",
            "type": "boolean",
          },
          "width": {
            "docs": "Image width in pixels.",
            "type": "integer",
          },
        },
      },
      "ImageInfoColorMode": {
        "docs": "Image color mode.",
        "enum": [
          "RGB",
          "RGBA",
          "RGBX",
          "L",
          "LA",
          "P",
          "PA",
          "CMYK",
          "YCbCr",
          "HSV",
          "LAB",
        ],
      },
      "ImageInfoGeoLocation": {
        "docs": "Geo-location of image from EXIF.",
        "properties": {
          "latitude": {
            "docs": "Location latitude.",
            "type": "double",
          },
          "longitude": {
            "docs": "Location longitude.",
            "type": "double",
          },
        },
      },
      "LegacyVideoInfo": {
        "docs": "Video metadata.",
        "properties": {
          "audio": {
            "docs": "Audio stream's metadata.",
            "type": "optional<LegacyVideoInfoAudio>",
          },
          "bitrate": {
            "docs": "Video file's bitrate.",
            "type": "optional<double>",
          },
          "duration": {
            "docs": "Video file's duration in milliseconds.",
            "type": "optional<double>",
          },
          "format": {
            "docs": "Video file's format.",
            "type": "optional<string>",
          },
          "video": {
            "docs": "Video stream's metadata.",
            "type": "optional<LegacyVideoInfoVideo>",
          },
        },
      },
      "LegacyVideoInfoAudio": {
        "docs": "Audio stream's metadata.",
        "properties": {
          "bitrate": {
            "docs": "Audio stream's bitrate.",
            "type": "optional<double>",
          },
          "channels": {
            "docs": "Audio stream's number of channels.",
            "type": "optional<string>",
          },
          "codec": {
            "docs": "Audio stream's codec.",
            "type": "optional<string>",
          },
          "sample_rate": {
            "docs": "Audio stream's sample rate.",
            "type": "optional<double>",
          },
        },
      },
      "LegacyVideoInfoVideo": {
        "docs": "Video stream's metadata.",
        "properties": {
          "bitrate": {
            "docs": "Video stream's bitrate.",
            "type": "optional<double>",
          },
          "codec": {
            "docs": "Video stream codec.",
            "type": "optional<string>",
          },
          "frame_rate": {
            "docs": "Video stream's frame rate.",
            "type": "optional<double>",
          },
          "height": {
            "docs": "Video stream's image height.",
            "type": "optional<double>",
          },
          "width": {
            "docs": "Video stream's image width.",
            "type": "optional<double>",
          },
        },
      },
      "Metadata": {
        "docs": "Arbitrary metadata associated with a file.",
        "type": "optional<map<string, unknown>>",
      },
      "MetadataValue": {
        "docs": "Arbitrary metadata associated with the file.
See [docs](https://uploadcare.com/docs/file-metadata/) and [REST API v0.7](/api-refs/rest-api/v0.7.0/#tag/File-metadata) for more information.
",
        "type": "string",
        "validation": {
          "format": undefined,
          "maxLength": 512,
          "minLength": 1,
          "pattern": undefined,
        },
      },
      "MultipartFileAlreadyUploadedError": {
        "type": "string",
      },
      "MultipartFileCompletionFailedError": {
        "type": "string",
      },
      "MultipartFileIdRequiredError": {
        "type": "string",
      },
      "MultipartFileSizeLimitExceededError": {
        "type": "string",
      },
      "MultipartFileSizeTooSmallError": {
        "type": "string",
      },
      "MultipartFileUploadCompleteRequestBadRequestErrorBody": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "RequestFiledsNumberLimitExceededError",
          "PostRequestParserFailedError",
          "NullCharactersForbiddenError",
          "MultipartFileIdRequiredError",
          "UuidInvalidError",
          "MultipartFileAlreadyUploadedError",
          "MultipartUploadSizeTooLargeError",
          "MultipartUploadSizeTooSmallError",
          "MultipartFileCompletionFailedError",
          "FileTypeForbiddenError",
          "FileInfectedError",
        ],
      },
      "MultipartFileUploadCompleteRequestForbiddenErrorBody": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "UploadcarePublicKeyRequiredError",
          "UploadcarePublicKeyInvalidError",
        ],
      },
      "MultipartFileUploadStartRequestBadRequestErrorBody": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "RequestFiledsNumberLimitExceededError",
          "PostRequestParserFailedError",
          "NullCharactersForbiddenError",
          "FileMetadataKeyDuplicatedError",
          "FileMetadataKeyEmptyError",
          "FileMetadataKeyForbiddenError",
          "FileMetadataKeyLengthTooBigError",
          "FileMetadataValueEmptyError",
          "FileMetadataValueForbiddenError",
          "FileMetadataValueLengthTooBigError",
          "FileMetadataKeysNumberTooBigError",
          "SignatureRequiredError",
          "SignatureExpirationRequiredError",
          "SignatureExpirationInvalidError",
          "RequestParamRequiredError",
          "MultipartSizeInvalidError",
          "MultipartFileSizeLimitExceededError",
          "MultipartFileSizeTooSmallError",
          "MultipartPartSizeInvalidError",
          "MultipartPartSizeTooSmallError",
          "MultipartPartSizeTooBigError",
        ],
      },
      "MultipartFileUploadStartRequestForbiddenErrorBody": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "UploadcarePublicKeyRequiredError",
          "UploadcarePublicKeyInvalidError",
          "AutoStoreDisabledError",
          "ProjectPublicKeyRemovedError",
          "AccountBlockedError",
          "AccountUnpaidError",
          "UploadFailedError",
          "AccountLimitsExceededError",
          "SignatureExpirationError",
          "SignatureInvalidError",
        ],
      },
      "MultipartPartSizeInvalidError": {
        "type": "string",
      },
      "MultipartPartSizeTooBigError": {
        "type": "string",
      },
      "MultipartPartSizeTooSmallError": {
        "type": "string",
      },
      "MultipartSizeInvalidError": {
        "type": "string",
      },
      "MultipartUploadSizeTooLargeError": {
        "type": "string",
      },
      "MultipartUploadSizeTooSmallError": {
        "type": "string",
      },
      "NullCharactersForbiddenError": {
        "type": "string",
      },
      "PostRequestParserFailedError": {
        "type": "string",
      },
      "ProjectPublicKeyRemovedError": {
        "type": "string",
      },
      "ProjectPublicKeyType": {
        "docs": "Public key identifying an Uploadcare project your uploads will go to.",
        "type": "string",
      },
      "PublicKeyInvalidError": {
        "type": "string",
      },
      "PublicKeyRequiredError": {
        "type": "string",
      },
      "RequestFiledsNumberLimitExceededError": {
        "type": "string",
      },
      "RequestParamRequiredError": {
        "type": "string",
      },
      "SchemasImageInfo": {
        "docs": "Image metadata.",
        "properties": {
          "color_mode": {
            "docs": "Image color mode.",
            "type": "SchemasImageInfoColorMode",
          },
          "datetime_original": {
            "docs": "Image date and time from EXIF. Please be aware that this data is not always formatted and displayed exactly as it appears in the EXIF.",
            "type": "optional<datetime>",
          },
          "dpi": {
            "docs": "Image DPI for two dimensions.",
            "type": "optional<list<double>>",
          },
          "format": {
            "docs": "Image format.",
            "type": "string",
          },
          "geo_location": {
            "docs": "Geo-location of image from EXIF.",
            "type": "optional<SchemasImageInfoGeoLocation>",
          },
          "height": {
            "docs": "Image height in pixels.",
            "type": "integer",
          },
          "orientation": {
            "docs": "Image orientation from EXIF.",
            "type": "optional<integer>",
            "validation": {
              "exclusiveMax": undefined,
              "exclusiveMin": undefined,
              "max": 8,
              "min": 0,
              "multipleOf": undefined,
            },
          },
          "sequence": {
            "docs": "Set to true if a file contains a sequence of images (GIF for example).",
            "type": "boolean",
          },
          "width": {
            "docs": "Image width in pixels.",
            "type": "integer",
          },
        },
      },
      "SchemasImageInfoColorMode": {
        "docs": "Image color mode.",
        "enum": [
          "RGB",
          "RGBA",
          "RGBX",
          "L",
          "LA",
          "P",
          "PA",
          "CMYK",
          "YCbCr",
          "HSV",
          "LAB",
        ],
      },
      "SchemasImageInfoGeoLocation": {
        "docs": "Geo-location of image from EXIF.",
        "properties": {
          "latitude": {
            "docs": "Location latitude.",
            "type": "double",
          },
          "longitude": {
            "docs": "Location longitude.",
            "type": "double",
          },
        },
      },
      "SignatureExpirationError": {
        "type": "string",
      },
      "SignatureExpirationInvalidError": {
        "type": "string",
      },
      "SignatureExpirationRequiredError": {
        "type": "string",
      },
      "SignatureInvalidError": {
        "type": "string",
      },
      "SignatureRequiredError": {
        "type": "string",
      },
      "SignatureType": {
        "docs": "\`signature\` must be sent along with your upload request if you would like to use signed uploads.
The signature should be generated on your backend.
**Note**: the process requires knowledge of your Uploadcare Project's Secret key.
See [signed uploads](https://uploadcare.com/docs/security/secure-uploads/) for details.
",
        "type": "string",
      },
      "SourceUrlRequiredError": {
        "type": "string",
      },
      "StoreType": {
        "default": "auto",
        "docs": "Determines if an uploaded file should be marked as temporary or permanent.

The parameter can have the following values:
- \`0\` - do not mark an uploaded file as stored and remove it after 24 hours
- \`1\` - mark the uploaded file as stored
- \`auto\` - delegate the choice of the file-storing behavior to a project-wide setting called
  [auto-store](https://app.uploadcare.com/projects/-/settings/#storage).

The default value depends on the user registration date.

For all users registered after February 12, 2024 (UTC 13:30), the default value is \`auto\`. 
File-storing behavior depends entirely on what is set in the 
[storage settings](https://app.uploadcare.com/projects/-/settings/#storage) in the Dashboard.

For users registered before February 12, 2024, the default value is \`0\`. 
To ensure that file storage in the project matches the settings in the Dashboard,
change the value to \`auto\`.
",
        "enum": [
          {
            "name": "Zero",
            "value": "0",
          },
          {
            "name": "One",
            "value": "1",
          },
          "auto",
        ],
      },
      "TokenRequiredError": {
        "type": "string",
      },
      "UploadFailedError": {
        "type": "string",
      },
      "UploadcarePublicKeyInvalidError": {
        "type": "string",
      },
      "UploadcarePublicKeyRequiredError": {
        "type": "string",
      },
      "UrlBlacklistedError": {
        "type": "string",
      },
      "UrlHostMalformedError": {
        "type": "string",
      },
      "UrlHostPrivateIpForbiddenError": {
        "type": "string",
      },
      "UrlHostRequiredError": {
        "type": "string",
      },
      "UrlParsingFailedError": {
        "type": "string",
      },
      "UrlSchemeInvalidError": {
        "type": "string",
      },
      "UrlSchemeRequiredError": {
        "type": "string",
      },
      "UuidInvalidError": {
        "type": "string",
      },
      "VideoInfo": {
        "docs": "Video metadata.",
        "properties": {
          "audio": "list<VideoInfoAudioItem>",
          "bitrate": {
            "docs": "Video file's bitrate.",
            "type": "optional<integer>",
          },
          "duration": {
            "docs": "Video file's duration in milliseconds.",
            "type": "optional<integer>",
          },
          "format": {
            "docs": "Video file's format.",
            "type": "string",
          },
          "video": "list<VideoInfoVideoItem>",
        },
      },
      "VideoInfoAudioItem": {
        "docs": "Audio stream's metadata.",
        "properties": {
          "bitrate": {
            "docs": "Audio stream's bitrate.",
            "type": "optional<integer>",
          },
          "channels": {
            "docs": "Audio stream's number of channels.",
            "type": "optional<integer>",
          },
          "codec": {
            "docs": "Audio stream's codec.",
            "type": "optional<string>",
          },
          "sample_rate": {
            "docs": "Audio stream's sample rate.",
            "type": "optional<integer>",
          },
        },
      },
      "VideoInfoVideoItem": {
        "docs": "Video stream's metadata.",
        "properties": {
          "bitrate": {
            "docs": "Video stream's bitrate.",
            "type": "optional<integer>",
          },
          "codec": {
            "docs": "Video stream's codec.",
            "type": "optional<string>",
          },
          "frame_rate": {
            "docs": "Video stream's frame rate.",
            "type": "double",
          },
          "height": {
            "docs": "Video stream's image height.",
            "type": "integer",
          },
          "width": {
            "docs": "Video stream's image width.",
            "type": "integer",
          },
        },
      },
    },
  },
  "rootApiFile": {
    "default-environment": "Default",
    "display-name": "Upload API Reference",
    "environments": {
      "Default": "https://upload.uploadcare.com",
    },
    "error-discrimination": {
      "strategy": "status-code",
    },
    "name": "api",
  },
}
`;

exports[`open api parser uploadcare simple 1`] = `
{
  "definitionFiles": {
    "groups.yml": {
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "display-name": "Groups",
        "endpoints": {
          "createFilesGroup": {
            "auth": false,
            "display-name": "Create a file group",
            "docs": "Create a file group from a set of already uploaded files.

The most common use case for creating a file group is when a user uploads
multiple files at once and then wants to display them together.

**Note:** A group itself and files within it MUST belong to the same project.

**Note:** Groups are immutable and the only way to add/remove a file to a group
is to create a new one.
",
            "errors": [
              "root.BadRequestError",
              "root.ForbiddenError",
            ],
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { group } from '@uploadcare/upload-client'

const result = await group(
  [
    'd6d34fa9-addd-472c-868d-2e5c105f9fcd',
    'b1026315-8116-4632-8364-607e64fca723/-/resize/x800/'
  ],
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$result = $uploader->groupFiles(['d6d34fa9-addd-472c-868d-2e5c105f9fcd', 'b1026315-8116-4632-8364-607e64fca723/-/resize/x800/']);
echo \\sprintf('Response status is %s', $result->getStatusCode());
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, File, FileGroup

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file_1 = uploadcare.file('d6d34fa9-addd-472c-868d-2e5c105f9fcd')
file_2 = uploadcare.file('b1026315-8116-4632-8364-607e64fca723/-/resize/x800/')
file_group = uploadcare.create_file_group([file_1, file_2])
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"

uuids = [
  'd6d34fa9-addd-472c-868d-2e5c105f9fcd',
  'b1026315-8116-4632-8364-607e64fca723/-/resize/x800/'
]
group = Uploadcare::Group.create(uuids)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let filesIds = ["d6d34fa9-addd-472c-868d-2e5c105f9fcd", "b1026315-8116-4632-8364-607e64fca723/-/resize/x800/"]
let group = try await uploadAPI.createFilesGroup(fileIds: filesIds)
print(group)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uuids = listOf(
    "d6d34fa9-addd-472c-868d-2e5c105f9fcd",
    "b1026315-8116-4632-8364-607e64fca723/-/resize/x800/"
)
val group = uploadcare.createGroup(fileIds = uuids)
Log.d("TAG", group.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "request": {
                  "files[]": [
                    "files[]",
                  ],
                  "pub_key": "caa9d29da887ee88ffe6",
                },
                "response": {
                  "body": {
                    "cdn_url": "https://ucarecdn.com/0d712319-b970-4602-850c-bae1ced521a6~1/",
                    "datetime_created": "2018-09-12T10:03:38Z",
                    "datetime_stored": "2024-01-15T09:30:00Z",
                    "files": [
                      {
                        "content_info": {
                          "image": {
                            "color_mode": "RGB",
                            "dpi": [
                              72,
                              72,
                            ],
                            "format": "JPEG",
                            "geo_location": {
                              "latitude": 55.62013611111111,
                              "longitude": 37.66299166666666,
                            },
                            "height": 4032,
                            "orientation": 6,
                            "sequence": false,
                            "width": 3024,
                          },
                          "mime": {
                            "mime": "image/jpeg",
                            "subtype": "jpeg",
                            "type": "image",
                          },
                        },
                        "default_effects": "resize/x800/",
                        "done": 2667636,
                        "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                        "filename": "IMG0412_123.JPG",
                        "image_info": {
                          "color_mode": "RGB",
                          "dpi": [
                            72,
                            72,
                          ],
                          "format": "JPEG",
                          "geo_location": {
                            "latitude": 55.62013611111111,
                            "longitude": 37.66299166666666,
                          },
                          "height": 4032,
                          "orientation": 6,
                          "sequence": false,
                          "width": 3024,
                        },
                        "is_image": true,
                        "is_ready": true,
                        "is_stored": true,
                        "metadata": {
                          "pet": "cat",
                          "subsystem": "uploader",
                        },
                        "mime_type": "image/jpeg",
                        "original_filename": "IMG-0412_123.JPG",
                        "size": 2667636,
                        "total": 2667636,
                        "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                      },
                    ],
                    "files_count": 1,
                    "id": "0d712319-b970-4602-850c-bae1ced521a6~1",
                    "url": "https://api.uploadcare.com/groups/0d712319-b970-4602-850c-bae1ced521a6~1/",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/group/",
            "request": {
              "body": {
                "properties": {
                  "expire": "optional<root.ExpireType>",
                  "files[]": {
                    "docs": "Set of files you want to add to the group.
Each element can be a file UUID with or without the applied image
processing operations.
",
                    "type": "list<string>",
                  },
                  "pub_key": "root.ProjectPublicKeyType",
                  "signature": "optional<root.SignatureType>",
                },
              },
              "content-type": "multipart/form-data",
              "headers": undefined,
              "name": "CreateFilesGroupRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "The group was created successfully.",
              "type": "root.GroupInfo",
            },
          },
          "filesGroupInfo": {
            "auth": false,
            "display-name": "Get information about a file group",
            "docs": "Returns a JSON object with information about a file group (when the group was created,
number of the files in the group, etc).
",
            "errors": [
              "root.BadRequestError",
              "root.ForbiddenError",
              "root.NotFoundError",
            ],
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { groupInfo } from '@uploadcare/upload-client'

const result = await groupInfo(
  '0d712319-b970-4602-850c-bae1ced521a6~1',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$groupInfo = $uploader->groupInfo('0d712319-b970-4602-850c-bae1ced521a6~1');
echo $groupInfo->getBody()->getContents();
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, FileGroup

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file_group = uploadcare.file_group('0d712319-b970-4602-850c-bae1ced521a6~1')
print(file_group.info)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

uuid = '0d712319-b970-4602-850c-bae1ced521a6~1'
info = Uploadcare::Group.info(uuid)
puts info.inspect
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let group = try await uploadcare.uploadAPI.filesGroupInfo(groupId: "0d712319-b970-4602-850c-bae1ced521a6~1")
print(group)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val group = uploadcare.getUploadedGroup(groupId = "0d712319-b970-4602-850c-bae1ced521a6~1")
Log.d("TAG", group.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "query-parameters": {
                  "group_id": "d52d7136-a2e5-4338-9f45-affbf83b857d~2",
                  "pub_key": "caa9d29da887ee88ffe6",
                },
                "response": {
                  "body": {
                    "cdn_url": "https://ucarecdn.com/0d712319-b970-4602-850c-bae1ced521a6~1/",
                    "datetime_created": "2018-09-12T10:03:38Z",
                    "datetime_stored": "2024-01-15T09:30:00Z",
                    "files": [
                      {
                        "content_info": {
                          "image": {
                            "color_mode": "RGB",
                            "dpi": [
                              72,
                              72,
                            ],
                            "format": "JPEG",
                            "geo_location": {
                              "latitude": 55.62013611111111,
                              "longitude": 37.66299166666666,
                            },
                            "height": 4032,
                            "orientation": 6,
                            "sequence": false,
                            "width": 3024,
                          },
                          "mime": {
                            "mime": "image/jpeg",
                            "subtype": "jpeg",
                            "type": "image",
                          },
                        },
                        "default_effects": "resize/x800/",
                        "done": 2667636,
                        "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                        "filename": "IMG0412_123.JPG",
                        "image_info": {
                          "color_mode": "RGB",
                          "dpi": [
                            72,
                            72,
                          ],
                          "format": "JPEG",
                          "geo_location": {
                            "latitude": 55.62013611111111,
                            "longitude": 37.66299166666666,
                          },
                          "height": 4032,
                          "orientation": 6,
                          "sequence": false,
                          "width": 3024,
                        },
                        "is_image": true,
                        "is_ready": true,
                        "is_stored": true,
                        "metadata": {
                          "pet": "cat",
                          "subsystem": "uploader",
                        },
                        "mime_type": "image/jpeg",
                        "original_filename": "IMG-0412_123.JPG",
                        "size": 2667636,
                        "total": 2667636,
                        "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                      },
                    ],
                    "files_count": 1,
                    "id": "0d712319-b970-4602-850c-bae1ced521a6~1",
                    "url": "https://api.uploadcare.com/groups/0d712319-b970-4602-850c-bae1ced521a6~1/",
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/group/info/",
            "request": {
              "name": "FilesGroupInfoRequest",
              "query-parameters": {
                "group_id": {
                  "docs": "Group's unique ID. Group IDs look like \`UUID~N\`, where the \`~N\` part reflects the number of the files in the group.
",
                  "type": "string",
                },
                "pub_key": "root.ProjectPublicKeyType",
              },
            },
            "response": {
              "docs": "File group information was retrieved successfully.",
              "type": "root.GroupInfo",
            },
          },
        },
      },
    },
    "upload.yml": {
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "display-name": "Upload",
        "endpoints": {
          "baseUpload": {
            "auth": false,
            "display-name": "Direct uploads",
            "docs": "Direct file uploads comply with the [RFC 7578](https://www.rfc-editor.org/rfc/rfc7578) standard.
In other words, you can perform a direct upload by making an HTTP POST request with the Content-Type
header set to \`multipart/form-data\`.

**Note**: Direct file uploads support files smaller than 100 megabytes only.
If you would like to upload larger files, please use [Multipart Uploads](/api-refs/upload-api/#operation/multipartFileUploadStart) instead.

File upload example with curl:

\`\`\`
curl -F "UPLOADCARE_PUB_KEY=YOUR_PUBLIC_KEY" -F "my_file.jpg=@my_file.jpg" "https://upload.uploadcare.com/base/"
\`\`\`
",
            "errors": [
              "root.BadRequestError",
              "root.ForbiddenError",
              "root.ContentTooLargeError",
              "root.TooManyRequestsError",
            ],
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { base } from '@uploadcare/upload-client'

// fileData must be \`Blob\` or \`File\` or \`Buffer\`
const result = await base(
  fileData,
  {
    publicKey: 'YOUR_PUBLIC_KEY',
    store: 'auto',
    metadata: {
      subsystem: 'uploader',
      pet: 'cat'
    }
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$fileInfo = $uploader->fromPath(__DIR__ . '/squirrel.jpg', null, null, 'auto', [
    'system' => 'php-uploader',
    'pet' => 'cat',
]);
echo \\sprintf("URL: %s, ID: %s, Mime type: %s\\n", $fileInfo->getUrl(), $fileInfo->getUuid(), $fileInfo->getMimeType());
foreach ($fileInfo->getMetadata() as $key => $value) {
    echo \\sprintf("%s: %s\\n", $key, $value);
}
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
with open('test1.txt', 'rb') as file_object:
    ucare_file = uploadcare.upload(file_object)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

source_file = File.open('image.png')
uploaded_file = Uploadcare::Uploader.upload(source_file, store: auto)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

guard let url = Bundle.main.url(forResource: "squirrel", withExtension: "jpg"),
      let data = try? Data(contentsOf: url) else { return }
let metadata = ["subsystem": "uploader", "pet": "cat"]

let file = try await uploadcare.uploadFile(data, withName: "random_file_name.jpg", store: .auto) { progress in
  print("progress: \\(progress)")
}
prkint(file)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uri = "content://com.android.providers.media.documents/document/image%3A1000001178".toUri()
val file = FileUploader(uploadcare, uri = uri, context = context).upload()
Log.d("TAG", file.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "request": {
                  "UPLOADCARE_PUB_KEY": "caa9d29da887ee88ffe6",
                },
                "response": {
                  "body": {
                    "filename": "filename",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/base/",
            "request": {
              "body": {
                "properties": {
                  "UPLOADCARE_PUB_KEY": "root.ProjectPublicKeyType",
                  "UPLOADCARE_STORE": "optional<root.StoreType>",
                  "expire": "optional<root.ExpireType>",
                  "metadata[{key}]": "optional<root.MetadataValue>",
                  "signature": "optional<root.SignatureType>",
                  "{filename}": "list<file>",
                },
              },
              "content-type": "multipart/form-data",
              "headers": undefined,
              "name": "BaseUploadRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "The file was uploaded successfully.",
              "type": "BaseUploadResponse",
            },
          },
          "fileUploadInfo": {
            "auth": false,
            "display-name": "Get information about an uploaded file",
            "docs": "Returns a JSON object with information about an uploaded file (file size, MIME type, metadata, etc).
",
            "errors": [
              "root.BadRequestError",
              "root.ForbiddenError",
              "root.NotFoundError",
            ],
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { info } from '@uploadcare/upload-client'

const result = await info(
  'be3b4d5e-179d-460e-8a5d-69112ac86cbb',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$fileInfo = (new Uploadcare\\Api($configuration))->file()->fileInfo(string $uuid);
echo \\sprintf('URL: %s, ID: %s, Mime type: %s', $fileInfo->getUrl(), $fileInfo->getUuid(), $fileInfo->getMimeType());
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file('740e1b8c-1ad8-4324-b7ec-112c79d8eac2')
print(file.info)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

uuid = '740e1b8c-1ad8-4324-b7ec-112c79d8eac2'
info = Uploadcare::File.info(uuid)
puts info.inspect
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let file = try await uploadcare.uploadAPI.fileInfo(withFileId: "740e1b8c-1ad8-4324-b7ec-112c79d8eac2")
print(file)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val file = uploadcare.getUploadedFile(fileId = "740e1b8c-1ad8-4324-b7ec-112c79d8eac2")
Log.d("TAG", file.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "query-parameters": {
                  "file_id": "67947755-1584-4e3f-902b-d4e2bf76a841",
                  "pub_key": "caa9d29da887ee88ffe6",
                },
                "response": {
                  "body": {
                    "content_info": {
                      "image": {
                        "color_mode": "RGB",
                        "datetime_original": "2024-01-15T09:30:00Z",
                        "dpi": [
                          72,
                          72,
                        ],
                        "format": "JPEG",
                        "geo_location": {
                          "latitude": 55.62013611111111,
                          "longitude": 37.66299166666666,
                        },
                        "height": 4032,
                        "orientation": 6,
                        "sequence": false,
                        "width": 3024,
                      },
                      "mime": {
                        "mime": "image/jpeg",
                        "subtype": "jpeg",
                        "type": "image",
                      },
                      "video": {
                        "audio": [
                          {
                            "bitrate": 78,
                            "channels": 2,
                            "codec": "aac",
                            "sample_rate": 44100,
                          },
                        ],
                        "bitrate": 393,
                        "duration": 261827,
                        "format": "mp4",
                        "video": [
                          {
                            "bitrate": 315,
                            "codec": "h264",
                            "frame_rate": 30,
                            "height": 360,
                            "width": 640,
                          },
                        ],
                      },
                    },
                    "done": 2667636,
                    "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                    "filename": "IMG0412_123.JPG",
                    "image_info": {
                      "color_mode": "RGB",
                      "datetime_original": "2024-01-15T09:30:00Z",
                      "dpi": [
                        72,
                        72,
                      ],
                      "format": "JPEG",
                      "geo_location": {
                        "latitude": 55.62013611111111,
                        "longitude": 37.66299166666666,
                      },
                      "height": 4032,
                      "orientation": 6,
                      "sequence": false,
                      "width": 3024,
                    },
                    "is_image": true,
                    "is_ready": true,
                    "is_stored": true,
                    "metadata": {
                      "pet": "cat",
                      "subsystem": "uploader",
                    },
                    "mime_type": "image/jpeg",
                    "original_filename": "IMG-0412_123.JPG",
                    "s3_bucket": "custom-s3-bucket-name",
                    "size": 2667636,
                    "total": 2667636,
                    "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                    "video_info": {
                      "audio": {
                        "bitrate": 78,
                        "channels": "2",
                        "codec": "aac",
                        "sample_rate": 44100,
                      },
                      "bitrate": 393,
                      "duration": 261827,
                      "format": "mp4",
                      "video": {
                        "bitrate": 315,
                        "codec": "h264",
                        "frame_rate": 30,
                        "height": 360,
                        "width": 640,
                      },
                    },
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/info/",
            "request": {
              "name": "FileUploadInfoRequest",
              "query-parameters": {
                "file_id": {
                  "docs": "File's unique ID.",
                  "type": "string",
                },
                "pub_key": "root.ProjectPublicKeyType",
              },
            },
            "response": {
              "docs": "File information was retrieved successfully.",
              "type": "root.FileUploadInfo",
            },
          },
          "fromURLUpload": {
            "auth": false,
            "display-name": "Upload files from URLs",
            "docs": "Uploadcare can fetch a file from a publicly available URL and then automatically upload the
fetched file to your project.

#### Upload tokens
Requests to the endpoint return a JSON dictionary with a \`token\` that can be further used
to [check the status](/api-refs/upload-api/#operation/fromURLUploadStatus) of the upload
request.

**Note:** The token is not a file ID and can't be used to address the file directly.
The actual file ID should be retrieved by calling the \`/from_url/status/\` endpoint.

#### Duplicates prevention
By default, every call to the \`/from_url/\` endpoint with the same \`source_url\` results in
a new upload leading to file duplication.

If you would like Uploadcare to keep track of the requested URLs and avoid the duplicate
uploads, pass the \`save_URL_duplicates\` and \`check_URL_duplicates\` parameters described below.
",
            "errors": [
              "root.BadRequestError",
              "root.ForbiddenError",
              "root.TooManyRequestsError",
            ],
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { fromUrl } from '@uploadcare/upload-client'

const result = await fromUrl(
  'https://source.unsplash.com/featured',
  {
    publicKey: 'YOUR_PUBLIC_KEY',
    metadata: {
      subsystem: 'uploader',
      pet: 'cat'
    }
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$url = 'https://source.unsplash.com/featured';
$token = $uploader->fromUrl($url, null, null, 'auto', [
    'action' => 'upload from URL', // The "Action" is the metadata key
    'checkDuplicates' => true,
    'storeDuplicates' => false,
]);
echo \\sprintf('Upload from URL \\'%s\\' has been started. Token is %s', $url, $token);
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
ucare_file = uploadcare.upload_from_url_sync(
    "https://source.unsplash.com/featured",
    check_duplicates=True,
    save_duplicates=False
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"

source_url = "https://source.unsplash.com/featured"
uploaded_file = Uploadcare::Uploader.upload(source_url, store: auto)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let url = URL(string: "https://source.unsplash.com/featured")!
let task = UploadFromURLTask(sourceUrl: url)
  .store(.auto)
  .setMetadata("uploader", forKey: "subsystem")
  .setMetadata("cat", forKey: "pet")

let file = try await uploadcare.uploadAPI.uploadAndWaitForCompletion(task: task)
print(file)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uploader = UrlUploader(
    client = uploadcare,
    sourceUrl = "https://source.unsplash.com/featured"
)
val file = uploader.upload()
Log.d("TAG", file.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "name": "type-token",
                "request": {
                  "pub_key": "caa9d29da887ee88ffe6",
                  "source_url": "source_url",
                },
                "response": {
                  "body": {
                    "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                    "type": "token",
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import { fromUrl } from '@uploadcare/upload-client'

const result = await fromUrl(
  'https://source.unsplash.com/featured',
  {
    publicKey: 'YOUR_PUBLIC_KEY',
    metadata: {
      subsystem: 'uploader',
      pet: 'cat'
    }
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$url = 'https://source.unsplash.com/featured';
$token = $uploader->fromUrl($url, null, null, 'auto', [
    'action' => 'upload from URL', // The "Action" is the metadata key
    'checkDuplicates' => true,
    'storeDuplicates' => false,
]);
echo \\sprintf('Upload from URL \\'%s\\' has been started. Token is %s', $url, $token);
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
ucare_file = uploadcare.upload_from_url_sync(
    "https://source.unsplash.com/featured",
    check_duplicates=True,
    save_duplicates=False
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"

source_url = "https://source.unsplash.com/featured"
uploaded_file = Uploadcare::Uploader.upload(source_url, store: auto)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let url = URL(string: "https://source.unsplash.com/featured")!
let task = UploadFromURLTask(sourceUrl: url)
  .store(.auto)
  .setMetadata("uploader", forKey: "subsystem")
  .setMetadata("cat", forKey: "pet")

let file = try await uploadcare.uploadAPI.uploadAndWaitForCompletion(task: task)
print(file)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uploader = UrlUploader(
    client = uploadcare,
    sourceUrl = "https://source.unsplash.com/featured"
)
val file = uploader.upload()
Log.d("TAG", file.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "name": "type-file-info",
                "request": {
                  "pub_key": "caa9d29da887ee88ffe6",
                  "source_url": "source_url",
                },
                "response": {
                  "body": {
                    "content_info": {
                      "image": {
                        "color_mode": "RGB",
                        "datetime_original": "2024-01-15T09:30:00Z",
                        "dpi": [
                          72,
                          72,
                        ],
                        "format": "JPEG",
                        "geo_location": {
                          "latitude": 55.62013611111111,
                          "longitude": 37.66299166666666,
                        },
                        "height": 4032,
                        "orientation": 6,
                        "sequence": false,
                        "width": 3024,
                      },
                      "mime": {
                        "mime": "image/jpeg",
                        "subtype": "jpeg",
                        "type": "image",
                      },
                      "video": {
                        "audio": [
                          {
                            "bitrate": 78,
                            "channels": 2,
                            "codec": "aac",
                            "sample_rate": 44100,
                          },
                        ],
                        "bitrate": 393,
                        "duration": 261827,
                        "format": "mp4",
                        "video": [
                          {
                            "bitrate": 315,
                            "codec": "h264",
                            "frame_rate": 30,
                            "height": 360,
                            "width": 640,
                          },
                        ],
                      },
                    },
                    "done": 2667636,
                    "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                    "filename": "IMG0412_123.JPG",
                    "image_info": {
                      "color_mode": "RGB",
                      "datetime_original": "2024-01-15T09:30:00Z",
                      "dpi": [
                        72,
                        72,
                      ],
                      "format": "JPEG",
                      "geo_location": {
                        "latitude": 55.62013611111111,
                        "longitude": 37.66299166666666,
                      },
                      "height": 4032,
                      "orientation": 6,
                      "sequence": false,
                      "width": 3024,
                    },
                    "is_image": true,
                    "is_ready": true,
                    "is_stored": true,
                    "metadata": {
                      "pet": "cat",
                      "subsystem": "uploader",
                    },
                    "mime_type": "image/jpeg",
                    "original_filename": "IMG-0412_123.JPG",
                    "s3_bucket": "custom-s3-bucket-name",
                    "size": 2667636,
                    "total": 2667636,
                    "type": "file_info",
                    "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                    "video_info": {
                      "audio": {
                        "bitrate": 78,
                        "channels": "2",
                        "codec": "aac",
                        "sample_rate": 44100,
                      },
                      "bitrate": 393,
                      "duration": 261827,
                      "format": "mp4",
                      "video": {
                        "bitrate": 315,
                        "codec": "h264",
                        "frame_rate": 30,
                        "height": 360,
                        "width": 640,
                      },
                    },
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/from_url/",
            "request": {
              "body": {
                "properties": {
                  "check_URL_duplicates": {
                    "default": "0",
                    "docs": "If set to "1", enables the \`source_url\` duplicates prevention.
Specifically, if the \`source_url\` had already been fetched and uploaded previously,
this request will return information about the already uploaded file.
",
                    "type": "optional<FromUrlUploadRequestCheckUrlDuplicates>",
                  },
                  "expire": "optional<root.ExpireType>",
                  "filename": {
                    "docs": "Sets the file name of the resource fetched from the source URL.
If not defined, the file name is obtained from either HTTP
response headers or the \`source_url\`'s path.

**Note:** The filename will be sanitized to only contain the following symbols:
\`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._\`.
",
                    "type": "optional<string>",
                  },
                  "metadata[{key}]": "optional<root.MetadataValue>",
                  "pub_key": "root.ProjectPublicKeyType",
                  "save_URL_duplicates": {
                    "docs": "Determines if the requested \`source_url\` should be kept in the history of
fetched/uploaded URLs. If the value is not defined explicitly, it is set
to the value of the \`check_URL_duplicates\` parameter.
",
                    "type": "optional<FromUrlUploadRequestSaveUrlDuplicates>",
                  },
                  "signature": "optional<root.SignatureType>",
                  "source_url": {
                    "docs": "Source URL of the file to fetch and upload.

**Note**: The URL should point to a resource publicly available via HTTP/HTTPS.
",
                    "type": "string",
                    "validation": {
                      "format": "uri",
                      "maxLength": undefined,
                      "minLength": undefined,
                      "pattern": undefined,
                    },
                  },
                  "store": "optional<root.StoreType>",
                },
              },
              "content-type": "multipart/form-data",
              "headers": undefined,
              "name": "FromUrlUploadRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Status Token or File Info of an already downloaded file.",
              "type": "FromUrlUploadResponse",
            },
          },
          "fromURLUploadStatus": {
            "auth": false,
            "display-name": "Check the status of a task to fetch/upload a file from a URL",
            "docs": "The endpoint notifies about the progress of the task by changing the value of the \`status\` field:
  * the field is set to \`waiting\` initially
  * once the system starts processing the request, the field is set to \`progress\`
  * if the file is fetched and uploaded successfully, the \`status\` field is set to \`success\`
    and the endpoint returns a JSON object holding information about the uploaded file
  * if the system fails to fetch/upload the file, the \`status\` field is set to \`error\` and
    the \`error\` field is set to the cause of the error.
",
            "errors": [
              "root.BadRequestError",
            ],
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { fromUrlStatus } from '@uploadcare/upload-client'

const result = await fromUrlStatus(
  '945ebb27-1fd6-46c6-a859-b9893712d650',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$status = $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');
echo \\sprintf('Upload status is %s', $status);
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')
print(file.info)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

token = '945ebb27-1fd6-46c6-a859-b9893712d650'
puts Uploadcare::Uploader.get_upload_from_url_status(token)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let status = try await uploadcare.uploadAPI.uploadStatus(forToken: "945ebb27-1fd6-46c6-a859-b9893712d650")
print(status)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val status = uploadcare.getFromUrlStatus(token = "945ebb27-1fd6-46c6-a859-b9893712d650")
Log.d("TAG", status.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "name": "status-waiting",
                "query-parameters": {
                  "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                },
                "response": {
                  "body": {
                    "status": "waiting",
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import { fromUrlStatus } from '@uploadcare/upload-client'

const result = await fromUrlStatus(
  '945ebb27-1fd6-46c6-a859-b9893712d650',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$status = $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');
echo \\sprintf('Upload status is %s', $status);
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')
print(file.info)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

token = '945ebb27-1fd6-46c6-a859-b9893712d650'
puts Uploadcare::Uploader.get_upload_from_url_status(token)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let status = try await uploadcare.uploadAPI.uploadStatus(forToken: "945ebb27-1fd6-46c6-a859-b9893712d650")
print(status)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val status = uploadcare.getFromUrlStatus(token = "945ebb27-1fd6-46c6-a859-b9893712d650")
Log.d("TAG", status.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "name": "status-progress",
                "query-parameters": {
                  "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                },
                "response": {
                  "body": {
                    "done": 134427,
                    "status": "progress",
                    "total": 732434,
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import { fromUrlStatus } from '@uploadcare/upload-client'

const result = await fromUrlStatus(
  '945ebb27-1fd6-46c6-a859-b9893712d650',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$status = $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');
echo \\sprintf('Upload status is %s', $status);
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')
print(file.info)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

token = '945ebb27-1fd6-46c6-a859-b9893712d650'
puts Uploadcare::Uploader.get_upload_from_url_status(token)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let status = try await uploadcare.uploadAPI.uploadStatus(forToken: "945ebb27-1fd6-46c6-a859-b9893712d650")
print(status)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val status = uploadcare.getFromUrlStatus(token = "945ebb27-1fd6-46c6-a859-b9893712d650")
Log.d("TAG", status.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "name": "status-success",
                "query-parameters": {
                  "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                },
                "response": {
                  "body": {
                    "content_info": {
                      "image": {
                        "color_mode": "RGB",
                        "datetime_original": "2024-01-15T09:30:00Z",
                        "dpi": [
                          72,
                          72,
                        ],
                        "format": "JPEG",
                        "geo_location": {
                          "latitude": 55.62013611111111,
                          "longitude": 37.66299166666666,
                        },
                        "height": 4032,
                        "orientation": 6,
                        "sequence": false,
                        "width": 3024,
                      },
                      "mime": {
                        "mime": "image/jpeg",
                        "subtype": "jpeg",
                        "type": "image",
                      },
                      "video": {
                        "audio": [
                          {
                            "bitrate": 78,
                            "channels": 2,
                            "codec": "aac",
                            "sample_rate": 44100,
                          },
                        ],
                        "bitrate": 393,
                        "duration": 261827,
                        "format": "mp4",
                        "video": [
                          {
                            "bitrate": 315,
                            "codec": "h264",
                            "frame_rate": 30,
                            "height": 360,
                            "width": 640,
                          },
                        ],
                      },
                    },
                    "done": 2667636,
                    "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                    "filename": "IMG0412_123.JPG",
                    "image_info": {
                      "color_mode": "RGB",
                      "datetime_original": "2024-01-15T09:30:00Z",
                      "dpi": [
                        72,
                        72,
                      ],
                      "format": "JPEG",
                      "geo_location": {
                        "latitude": 55.62013611111111,
                        "longitude": 37.66299166666666,
                      },
                      "height": 4032,
                      "orientation": 6,
                      "sequence": false,
                      "width": 3024,
                    },
                    "is_image": true,
                    "is_ready": true,
                    "is_stored": true,
                    "metadata": {
                      "pet": "cat",
                      "subsystem": "uploader",
                    },
                    "mime_type": "image/jpeg",
                    "original_filename": "IMG-0412_123.JPG",
                    "s3_bucket": "custom-s3-bucket-name",
                    "size": 2667636,
                    "status": "success",
                    "total": 2667636,
                    "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                    "video_info": {
                      "audio": {
                        "bitrate": 78,
                        "channels": "2",
                        "codec": "aac",
                        "sample_rate": 44100,
                      },
                      "bitrate": 393,
                      "duration": 261827,
                      "format": "mp4",
                      "video": {
                        "bitrate": 315,
                        "codec": "h264",
                        "frame_rate": 30,
                        "height": 360,
                        "width": 640,
                      },
                    },
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import { fromUrlStatus } from '@uploadcare/upload-client'

const result = await fromUrlStatus(
  '945ebb27-1fd6-46c6-a859-b9893712d650',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$status = $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');
echo \\sprintf('Upload status is %s', $status);
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')
print(file.info)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

token = '945ebb27-1fd6-46c6-a859-b9893712d650'
puts Uploadcare::Uploader.get_upload_from_url_status(token)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let status = try await uploadcare.uploadAPI.uploadStatus(forToken: "945ebb27-1fd6-46c6-a859-b9893712d650")
print(status)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val status = uploadcare.getFromUrlStatus(token = "945ebb27-1fd6-46c6-a859-b9893712d650")
Log.d("TAG", status.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "name": "status-error",
                "query-parameters": {
                  "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                },
                "response": {
                  "body": {
                    "error": "HTTP client error: 404.",
                    "error_code": "DownloadFileHTTPClientError",
                    "status": "error",
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import { fromUrlStatus } from '@uploadcare/upload-client'

const result = await fromUrlStatus(
  '945ebb27-1fd6-46c6-a859-b9893712d650',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$status = $uploader->checkStatus('945ebb27-1fd6-46c6-a859-b9893712d650');
echo \\sprintf('Upload status is %s', $status);
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
file = uploadcare.file_from_url('945ebb27-1fd6-46c6-a859-b9893712d650')
print(file.info)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

token = '945ebb27-1fd6-46c6-a859-b9893712d650'
puts Uploadcare::Uploader.get_upload_from_url_status(token)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

let status = try await uploadcare.uploadAPI.uploadStatus(forToken: "945ebb27-1fd6-46c6-a859-b9893712d650")
print(status)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val status = uploadcare.getFromUrlStatus(token = "945ebb27-1fd6-46c6-a859-b9893712d650")
Log.d("TAG", status.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "name": "status-unknown",
                "query-parameters": {
                  "token": "945ebb27-1fd6-46c6-a859-b9893712d650",
                },
                "response": {
                  "body": {
                    "status": "unknown",
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/from_url/status/",
            "request": {
              "name": "FromUrlUploadStatusRequest",
              "query-parameters": {
                "token": {
                  "docs": "Token returned by the \`/from_url/\` endpoint that identifies a request to fetch/upload a file from a URL.",
                  "type": "string",
                },
              },
            },
            "response": {
              "docs": "Request was processed successfully.
",
              "type": "FromUrlUploadStatusResponse",
            },
          },
          "multipartFileUploadComplete": {
            "auth": false,
            "display-name": "Complete multipart upload",
            "docs": "Once all the file parts have been uploaded successfully, complete the
upload session to assemble all the file parts into a single resulting file.
",
            "errors": [
              "root.BadRequestError",
              "root.ForbiddenError",
              "root.NotFoundError",
            ],
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { multipartComplete } from '@uploadcare/upload-client'

const result = await multipartComplete(
  '67947755-1584-4e3f-902b-d4e2bf76a841',
  {
    publicKey: 'YOUR_PUBLIC_KEY'
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$path = '/path-to-large-file.zip';
$handle = \\fopen($path, 'rb');
$response = $uploader->fromResource($handle, null, null, 'auto', [
    'size' => \\filesize($path), // The "size" is the metadata key
]);
echo \\sprintf('File uploaded. ID is \\'%s\\'', $response->getUuid());
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
with open('test1.txt', 'rb') as file_object:
    ucare_file = uploadcare.multipart_upload(file_object)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

source_file = File.open('image.png')
uploaded_file = Uploadcare::Uploader.upload(source_file, store: auto)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

guard let url = Bundle.main.url(forResource: "Mona_Lisa_23mb", withExtension: "jpg"),
      let data = try? Data(contentsOf: url) else { return }

let metadata = ["subsystem": "uploader", "pet": "cat"]
let onProgress: (Double)->Void = { (progress) in
  print("progress: \\(progress)")
}

let file = try await uploadcare.uploadAPI.multipartUpload(data, withName: "Mona_Lisa_big.jpg", store: .auto, metadata: metadata, onProgress)
print(file)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uri = "content://com.android.providers.media.documents/document/image%3A1000001178".toUri()
val file = FileUploader(uploadcare, uri = uri, context = context).upload()
Log.d("TAG", file.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "request": {
                  "UPLOADCARE_PUB_KEY": "caa9d29da887ee88ffe6",
                  "uuid": "uuid",
                },
                "response": {
                  "body": {
                    "content_info": {
                      "image": {
                        "color_mode": "RGB",
                        "datetime_original": "2024-01-15T09:30:00Z",
                        "dpi": [
                          72,
                          72,
                        ],
                        "format": "JPEG",
                        "geo_location": {
                          "latitude": 55.62013611111111,
                          "longitude": 37.66299166666666,
                        },
                        "height": 4032,
                        "orientation": 6,
                        "sequence": false,
                        "width": 3024,
                      },
                      "mime": {
                        "mime": "image/jpeg",
                        "subtype": "jpeg",
                        "type": "image",
                      },
                      "video": {
                        "audio": [
                          {
                            "bitrate": 78,
                            "channels": 2,
                            "codec": "aac",
                            "sample_rate": 44100,
                          },
                        ],
                        "bitrate": 393,
                        "duration": 261827,
                        "format": "mp4",
                        "video": [
                          {
                            "bitrate": 315,
                            "codec": "h264",
                            "frame_rate": 30,
                            "height": 360,
                            "width": 640,
                          },
                        ],
                      },
                    },
                    "done": 2667636,
                    "file_id": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                    "filename": "IMG0412_123.JPG",
                    "image_info": {
                      "color_mode": "RGB",
                      "datetime_original": "2024-01-15T09:30:00Z",
                      "dpi": [
                        72,
                        72,
                      ],
                      "format": "JPEG",
                      "geo_location": {
                        "latitude": 55.62013611111111,
                        "longitude": 37.66299166666666,
                      },
                      "height": 4032,
                      "orientation": 6,
                      "sequence": false,
                      "width": 3024,
                    },
                    "is_image": true,
                    "is_ready": true,
                    "is_stored": true,
                    "metadata": {
                      "pet": "cat",
                      "subsystem": "uploader",
                    },
                    "mime_type": "image/jpeg",
                    "original_filename": "IMG-0412_123.JPG",
                    "s3_bucket": "custom-s3-bucket-name",
                    "size": 2667636,
                    "total": 2667636,
                    "uuid": "be3b4d5e-179d-460e-8a5d-69112ac86cbb",
                    "video_info": {
                      "audio": {
                        "bitrate": 78,
                        "channels": "2",
                        "codec": "aac",
                        "sample_rate": 44100,
                      },
                      "bitrate": 393,
                      "duration": 261827,
                      "format": "mp4",
                      "video": {
                        "bitrate": 315,
                        "codec": "h264",
                        "frame_rate": 30,
                        "height": 360,
                        "width": 640,
                      },
                    },
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/multipart/complete/",
            "request": {
              "body": {
                "properties": {
                  "UPLOADCARE_PUB_KEY": "root.ProjectPublicKeyType",
                  "uuid": {
                    "docs": "File's UUID from the \`/multipart/start/\` endpoint.",
                    "type": "string",
                    "validation": {
                      "format": "uuid",
                      "maxLength": undefined,
                      "minLength": undefined,
                      "pattern": undefined,
                    },
                  },
                },
              },
              "content-type": "multipart/form-data",
              "headers": undefined,
              "name": "MultipartFileUploadCompleteRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "The file was uploaded successfully.",
              "type": "root.FileUploadInfo",
            },
          },
          "multipartFileUploadPart": {
            "auth": false,
            "display-name": "Upload individual file parts",
            "docs": "The second phase is about uploading the file parts to the presigned upload URLs returned from the
\`/multipart/start/\` endpoint.

Each uploaded part should be at least 5 MiB (5242880 bytes) in size except for the last one, which can be smaller.
You can upload the file parts in parallel provided that the byte order stays unchanged.

**Note**: You MUST define \`Content-Type\` header for your data.
",
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { multipartUpload } from '@uploadcare/upload-client'

// partData is a chunk of the uploaded file's content
// must be \`Blob\` or \`File\` or \`Buffer\`
const result = await multipartUpload(
  partData,
  '<presigned-url-x>'
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$path = '/path-to-large-file.zip';
$handle = \\fopen($path, 'rb');
$response = $uploader->fromResource($handle, null, null, 'auto', [
    'size' => \\filesize($path), // The "size" is the metadata key
]);
echo \\sprintf('File uploaded. ID is \\'%s\\'', $response->getUuid());
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
with open('test1.txt', 'rb') as file_object:
    ucare_file = uploadcare.multipart_upload(file_object)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

source_file = File.open('image.png')
uploaded_file = Uploadcare::Uploader.upload(source_file, store: auto)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

guard let url = Bundle.main.url(forResource: "Mona_Lisa_23mb", withExtension: "jpg"),
      let data = try? Data(contentsOf: url) else { return }

let metadata = ["subsystem": "uploader", "pet": "cat"]
let onProgress: (Double)->Void = { (progress) in
  print("progress: \\(progress)")
}

let file = try await uploadcare.uploadAPI.multipartUpload(data, withName: "Mona_Lisa_big.jpg", store: .auto, metadata: metadata, onProgress)
print(file)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uri = "content://com.android.providers.media.documents/document/image%3A1000001178".toUri()
val file = FileUploader(uploadcare, uri = uri, context = context).upload()
Log.d("TAG", file.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
              },
            ],
            "method": "PUT",
            "pagination": undefined,
            "path": "/<presigned-url-x>",
            "request": {
              "body": "bytes",
              "content-type": "application/octet-stream",
            },
          },
          "multipartFileUploadStart": {
            "auth": false,
            "display-name": "Start multipart upload",
            "docs": "Multipart uploads should be used if you need to upload files larger than 100 megabytes or if you want to
explicitly trigger [AWS S3 Transfer Acceleration](https://aws.amazon.com/s3/transfer-acceleration/).
When you use Multipart Uploads your files go straight to AWS S3 bypassing our upload instances.

To upload large files, 3 requests are sent in sequence:
1. \`/multipart/start/\`
2. \`<presigned-url-x>\`
3. \`/multipart/complete/\`.

**Note**: Multipart uploads support files larger than 10 megabytes only.
",
            "errors": [
              "root.BadRequestError",
              "root.ForbiddenError",
              "root.TooManyRequestsError",
            ],
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import { multipartStart } from '@uploadcare/upload-client'

const result = await multipartStart(
  27796904,
  {
    publicKey: 'YOUR_PUBLIC_KEY',
    store: 'auto',
    fileName: 'myfile.mp4',
    contentType: 'video/mp4',
    metadata: {
      subsystem: 'uploader',
      pet: 'cat'
    }
  }
)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "JavaScript",
                    "name": "JS",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

<?php
$configuration = Uploadcare\\Configuration::create((string) $_ENV['UPLOADCARE_PUBLIC_KEY'], (string) $_ENV['UPLOADCARE_SECRET_KEY']);

$uploader = new Uploadcare\\Uploader\\Uploader($configuration);
$path = '/path-to-large-file.zip';
$handle = \\fopen($path, 'rb');
$response = $uploader->fromResource($handle, null, null, 'auto', [
    'size' => \\filesize($path), // The "size" is the metadata key
]);
echo \\sprintf('File uploaded. ID is \\'%s\\'', $response->getUuid());
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "PHP",
                    "name": "PHP",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

from pyuploadcare import Uploadcare, File

uploadcare = Uploadcare(public_key='YOUR_PUBLIC_KEY', secret_key='YOUR_SECRET_KEY')
with open('test1.txt', 'rb') as file_object:
    ucare_file = uploadcare.multipart_upload(file_object)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Python",
                    "name": "Python",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

require 'uploadcare'
Uploadcare.config.public_key = "YOUR_PUBLIC_KEY"
Uploadcare.config.secret_key = "YOUR_SECRET_KEY"

source_file = File.open('image.png')
uploaded_file = Uploadcare::Uploader.upload(source_file, store: auto)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Ruby",
                    "name": "Ruby",
                  },
                  {
                    "code": "// Uploadcare lib provides high level API for multipart uploads that does everything for you

import Uploadcare

let uploadcare = Uploadcare(withPublicKey: "YOUR_PUBLIC_KEY", secretKey: "YOUR_SECRET_KEY")

guard let url = Bundle.main.url(forResource: "Mona_Lisa_23mb", withExtension: "jpg"),
      let data = try? Data(contentsOf: url) else { return }

let metadata = ["subsystem": "uploader", "pet": "cat"]
let onProgress: (Double)->Void = { (progress) in
  print("progress: \\(progress)")
}

let file = try await uploadcare.uploadAPI.multipartUpload(data, withName: "Mona_Lisa_big.jpg", store: .auto, metadata: metadata, onProgress)
print(file)
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Swift",
                    "name": "Swift",
                  },
                  {
                    "code": "import com.uploadcare.android.library.api.UploadcareClient

val uploadcare = UploadcareClient(publicKey = "YOUR_PUBLIC_KEY", secretKey = "YOUR_SECRET_KEY")

val uri = "content://com.android.providers.media.documents/document/image%3A1000001178".toUri()
val file = FileUploader(uploadcare, uri = uri, context = context).upload()
Log.d("TAG", file.toString())
",
                    "docs": undefined,
                    "install": undefined,
                    "language": "Kotlin",
                    "name": "Kotlin",
                  },
                ],
                "request": {
                  "UPLOADCARE_PUB_KEY": "caa9d29da887ee88ffe6",
                  "content_type": "content_type",
                  "filename": "filename",
                  "size": 1,
                },
                "response": {
                  "body": {
                    "parts": [
                      "<presigned-url-1>",
                      "<presigned-url-2>",
                      "<presigned-url-3>",
                      "<presigned-url-4>",
                      "<presigned-url-5>",
                    ],
                    "uuid": "67947755-1584-4e3f-902b-d4e2bf76a841",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/multipart/start/",
            "request": {
              "body": {
                "properties": {
                  "UPLOADCARE_PUB_KEY": "root.ProjectPublicKeyType",
                  "UPLOADCARE_STORE": "optional<root.StoreType>",
                  "content_type": {
                    "docs": "File's MIME-type.",
                    "type": "string",
                  },
                  "expire": "optional<root.ExpireType>",
                  "filename": {
                    "docs": "Original file name of the uploaded file",
                    "type": "string",
                  },
                  "metadata[{key}]": "optional<root.MetadataValue>",
                  "part_size": {
                    "default": 5242880,
                    "docs": "Multipart Uploads expect that you will split the uploaded file into equally sized
parts (except for the last part) and then will upload them to AWS S3 (possibly in parallel).
By default, we assume that you will upload the files in 5 megabyte chunks,
so we return a list of presigned AWS S3 URLs accordingly.
If you intend to upload large files (for example, larger than a gigabyte),
we recommend to bump the part size and to pass the expected chunk size
to us as a value of the \`part_size\` parameter (in bytes).
",
                    "type": "optional<integer>",
                    "validation": {
                      "exclusiveMax": undefined,
                      "exclusiveMin": undefined,
                      "max": undefined,
                      "min": 5242880,
                      "multipleOf": undefined,
                    },
                  },
                  "signature": "optional<root.SignatureType>",
                  "size": {
                    "docs": "Precise file size of the uploaded file (in bytes).
**Note**: The size should not exceed max file size cap for your project.
",
                    "type": "integer",
                  },
                },
              },
              "content-type": "multipart/form-data",
              "headers": undefined,
              "name": "MultipartFileUploadStartRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Multipart upload started successfully.",
              "type": "MultipartFileUploadStartResponse",
            },
          },
        },
      },
      "types": {
        "BaseUploadResponse": {
          "docs": "JSON object where the key is the file name of the uploaded file and
the value is the unique ID of the file on our systems.
",
          "properties": {
            "filename": {
              "type": "optional<string>",
              "validation": {
                "format": "uuid",
                "maxLength": undefined,
                "minLength": undefined,
                "pattern": undefined,
              },
            },
          },
        },
        "FromUrlUploadRequestCheckUrlDuplicates": {
          "default": "0",
          "docs": "If set to "1", enables the \`source_url\` duplicates prevention.
Specifically, if the \`source_url\` had already been fetched and uploaded previously,
this request will return information about the already uploaded file.
",
          "enum": [
            {
              "name": "Zero",
              "value": "0",
            },
            {
              "name": "One",
              "value": "1",
            },
          ],
        },
        "FromUrlUploadRequestSaveUrlDuplicates": {
          "docs": "Determines if the requested \`source_url\` should be kept in the history of
fetched/uploaded URLs. If the value is not defined explicitly, it is set
to the value of the \`check_URL_duplicates\` parameter.
",
          "enum": [
            {
              "name": "Zero",
              "value": "0",
            },
            {
              "name": "One",
              "value": "1",
            },
          ],
        },
        "FromUrlUploadResponse": {
          "discriminated": false,
          "docs": undefined,
          "union": [
            "root.FromUrlUploadResponseSchema",
            "root.FileUploadInfoFromUrl",
          ],
        },
        "FromUrlUploadStatusResponse": {
          "discriminated": false,
          "docs": undefined,
          "union": [
            "root.FileUploadInfoWaitingStatus",
            "root.FileUploadInfoProgressStatus",
            "root.FileUploadInfoSuccessStatus",
            "root.FileUploadInfoErrorStatus",
            "root.FileUploadInfoUnknownStatus",
          ],
        },
        "MultipartFileUploadStartResponse": {
          "docs": undefined,
          "properties": {
            "parts": "list<string>",
            "uuid": {
              "docs": "File's UUID.",
              "type": "string",
              "validation": {
                "format": "uuid",
                "maxLength": undefined,
                "minLength": undefined,
                "pattern": undefined,
              },
            },
          },
        },
      },
    },
  },
  "packageMarkerFile": {
    "errors": {
      "BadRequestError": {
        "examples": [
          {
            "docs": undefined,
            "name": "null-characters-forbidden",
            "value": "Null characters are not allowed.",
          },
          {
            "docs": undefined,
            "name": "group-id-required",
            "value": "group_id is required.",
          },
        ],
        "status-code": 400,
        "type": "unknown",
      },
      "ContentTooLargeError": {
        "docs": "The size of the request is too large.",
        "examples": [
          {
            "docs": undefined,
            "name": undefined,
            "value": "The size of the request is too large.",
          },
        ],
        "status-code": 413,
        "type": "string",
      },
      "ForbiddenError": {
        "docs": "Request was not allowed.",
        "examples": [
          {
            "docs": undefined,
            "name": "public-key-is-required",
            "value": "UPLOADCARE_PUB_KEY is required.",
          },
          {
            "docs": undefined,
            "name": "public-key-is-invalid",
            "value": "UPLOADCARE_PUB_KEY is invalid.",
          },
          {
            "docs": undefined,
            "name": "auto-store-is-disabled",
            "value": "Autostore is disabled.",
          },
          {
            "docs": undefined,
            "name": "project-public-key-removed",
            "value": "Project 39e3eb895fdada95e7a9 is marked as removed.",
          },
          {
            "docs": undefined,
            "name": "account-blocked",
            "value": "Account has been blocked.",
          },
          {
            "docs": undefined,
            "name": "account-unpaid",
            "value": "Account has been blocked for non payment.",
          },
          {
            "docs": undefined,
            "name": "upload-failed",
            "value": "Upload failed.",
          },
          {
            "docs": undefined,
            "name": "account-limits-exceeded",
            "value": "Account has reached its limits.",
          },
          {
            "docs": undefined,
            "name": "signature-expiration",
            "value": "Expired signature.",
          },
          {
            "docs": undefined,
            "name": "signature-invalid",
            "value": "Invalid signature.",
          },
          {
            "docs": undefined,
            "name": "public-key-is-required",
            "value": "pub_key is required.",
          },
          {
            "docs": undefined,
            "name": "public-key-is-invalid",
            "value": "pub_key is invalid.",
          },
        ],
        "status-code": 403,
        "type": "ForbiddenErrorBody",
      },
      "NotFoundError": {
        "examples": [
          {
            "docs": undefined,
            "name": "group-not-found",
            "value": "group_id is invalid.",
          },
        ],
        "status-code": 404,
        "type": "unknown",
      },
      "TooManyRequestsError": {
        "docs": "Request was throttled.",
        "examples": [
          {
            "docs": undefined,
            "name": undefined,
            "value": "Request was throttled.",
          },
        ],
        "status-code": 429,
        "type": "string",
      },
    },
    "types": {
      "AccountBlockedError": {
        "type": "string",
      },
      "AccountLimitsExceededError": {
        "type": "string",
      },
      "AccountUnpaidError": {
        "type": "string",
      },
      "AutoStoreDisabledError": {
        "type": "string",
      },
      "BadRequestErrorBody": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "NullCharactersForbiddenError",
          "GroupIdRequiredError",
        ],
      },
      "ContentInfo": {
        "docs": "Information about file content.",
        "properties": {
          "image": "optional<SchemasImageInfo>",
          "mime": {
            "docs": "MIME type.",
            "type": "optional<ContentInfoMime>",
          },
          "video": "optional<VideoInfo>",
        },
      },
      "ContentInfoMime": {
        "docs": "MIME type.",
        "properties": {
          "mime": {
            "docs": "Full MIME type.",
            "type": "string",
          },
          "subtype": {
            "docs": "Subtype of MIME type.",
            "type": "string",
          },
          "type": {
            "docs": "Type of MIME type.",
            "type": "string",
          },
        },
      },
      "ExpireType": {
        "docs": "\`expire\` must be sent along with your upload request if you would like to use signed uploads.
The parameter defines the time during which your signature is valid. It's a UNIX timestamp.
See [signed uploads](https://uploadcare.com/docs/security/secure-uploads/) for details.
",
        "type": "double",
      },
      "FileIdInvalidError": {
        "type": "string",
      },
      "FileIdRequiredError": {
        "type": "string",
      },
      "FileInfectedError": {
        "type": "string",
      },
      "FileMetadataKeyDuplicatedError": {
        "type": "string",
      },
      "FileMetadataKeyEmptyError": {
        "type": "string",
      },
      "FileMetadataKeyForbiddenError": {
        "type": "string",
      },
      "FileMetadataKeyLengthTooBigError": {
        "type": "string",
      },
      "FileMetadataKeysNumberTooBigError": {
        "type": "string",
      },
      "FileMetadataValueEmptyError": {
        "type": "string",
      },
      "FileMetadataValueForbiddenError": {
        "type": "string",
      },
      "FileMetadataValueLengthTooBigError": {
        "type": "string",
      },
      "FileNotFoundError": {
        "type": "string",
      },
      "FileSizeLimitExceededError": {
        "type": "string",
      },
      "FileTypeForbiddenError": {
        "type": "string",
      },
      "FileUploadInfo": {
        "docs": "Information about an uploaded file.",
        "properties": {
          "content_info": "optional<ContentInfo>",
          "done": {
            "docs": "Same as \`size\`.",
            "type": "integer",
          },
          "file_id": {
            "docs": "Same as \`uuid\`",
            "type": "string",
            "validation": {
              "format": "uuid",
              "maxLength": undefined,
              "minLength": undefined,
              "pattern": undefined,
            },
          },
          "filename": {
            "docs": "Sanitized \`original_filename\`.",
            "type": "string",
          },
          "image_info": "optional<ImageInfo>",
          "is_image": {
            "docs": "True if the uploaded file is an image of a supported file format.",
            "type": "boolean",
          },
          "is_ready": {
            "docs": "True if the file is ready to be fetched from Uploadcare's CDN.",
            "type": "boolean",
          },
          "is_stored": {
            "docs": "True if the file has been marked as stored.",
            "type": "boolean",
          },
          "metadata": "optional<Metadata>",
          "mime_type": {
            "docs": "File's MIME-type.",
            "type": "string",
          },
          "original_filename": {
            "docs": "Original file of the uploaded file.",
            "type": "string",
          },
          "s3_bucket": {
            "docs": "Name of an AWS S3 bucket where the file is stored. Only available if you associate a Foreign Storage Bucket with your project.",
            "type": "optional<string>",
          },
          "size": {
            "docs": "File's size in bytes.",
            "type": "integer",
          },
          "total": {
            "docs": "Same as \`size\`.",
            "type": "integer",
          },
          "uuid": {
            "docs": "File's unique ID.",
            "type": "string",
            "validation": {
              "format": "uuid",
              "maxLength": undefined,
              "minLength": undefined,
              "pattern": undefined,
            },
          },
          "video_info": "optional<LegacyVideoInfo>",
        },
      },
      "FileUploadInfoErrorStatus": {
        "docs": undefined,
        "properties": {
          "error": {
            "docs": "Human readable description of the issue with the fetch/upload task.
",
            "type": "optional<string>",
          },
          "error_code": {
            "docs": "Machine readable error code.

Note: See the [Errors > FromURL upload errors](#tag/Errors) section of this
page for a full list of all possible error codes.
",
            "type": "optional<string>",
          },
          "status": {
            "docs": "The system failed to fetch and/or upload the file.
",
            "type": "optional<literal<"error">>",
          },
        },
      },
      "FileUploadInfoFromUrl": {
        "docs": undefined,
        "extends": [
          "FileUploadInfo",
        ],
        "properties": {
          "type": "optional<literal<"file_info">>",
        },
      },
      "FileUploadInfoProgressStatus": {
        "docs": undefined,
        "properties": {
          "done": {
            "docs": "How many bytes of the file have been fetched so far.
",
            "type": "optional<double>",
          },
          "status": {
            "docs": "The system is fetching/uploading the file.
",
            "type": "optional<literal<"progress">>",
          },
          "total": {
            "docs": "The expected size of the fetched file (in bytes).

**Note:** the value can be missing if the server we are fetching the file from
does not provide the information or if the server is returning the file in, for
example, [compressed form](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding).
",
            "type": "optional<double>",
          },
        },
      },
      "FileUploadInfoSuccessStatus": {
        "docs": undefined,
        "extends": [
          "FileUploadInfo",
        ],
        "properties": {
          "status": {
            "docs": "The file has been fetched/uploaded successfully.",
            "type": "optional<literal<"success">>",
          },
        },
      },
      "FileUploadInfoUnknownStatus": {
        "docs": undefined,
        "properties": {
          "status": {
            "docs": "The system does not have information about the task.

Note: Uploadcare stores information about the \`/from_url/\` tasks for a limited
period of time only. The endpoint can return the status \`unknown\` for the tasks
that are tool old (or that have not been created at all).
",
            "type": "optional<literal<"unknown">>",
          },
        },
      },
      "FileUploadInfoWaitingStatus": {
        "docs": undefined,
        "properties": {
          "status": {
            "docs": "The system is preparing to handle the request.
",
            "type": "optional<literal<"waiting">>",
          },
        },
      },
      "FilesRequiredError": {
        "type": "string",
      },
      "ForbiddenErrorBody": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "PublicKeyRequiredError",
          "PublicKeyInvalidError",
        ],
      },
      "FromUrlUploadResponseSchema": {
        "docs": "\`/from_url/\` upload response.",
        "properties": {
          "token": {
            "docs": "Token to identify a \`/from_url/\` request.",
            "type": "optional<string>",
            "validation": {
              "format": "uuid",
              "maxLength": undefined,
              "minLength": undefined,
              "pattern": undefined,
            },
          },
          "type": "optional<literal<"token">>",
        },
      },
      "GroupFileUrlParsingFailedError": {
        "type": "string",
      },
      "GroupFilesInvalidError": {
        "type": "string",
      },
      "GroupFilesNotFoundError": {
        "type": "string",
      },
      "GroupIdRequiredError": {
        "type": "string",
      },
      "GroupInfo": {
        "docs": "File group information object.",
        "properties": {
          "cdn_url": {
            "docs": "Group's CDN URL.",
            "type": "optional<string>",
            "validation": {
              "format": "uri",
              "maxLength": undefined,
              "minLength": undefined,
              "pattern": undefined,
            },
          },
          "datetime_created": {
            "docs": "ISO-8601 date and time when the group was created.",
            "type": "optional<datetime>",
          },
          "datetime_stored": {
            "availability": "deprecated",
            "docs": "ISO-8601 date and time when the group was marked as stored.",
            "type": "optional<datetime>",
          },
          "files": {
            "docs": "The list of files in the group. An array may contain null values if a file has been removed.
",
            "type": "optional<list<unknown>>",
          },
          "files_count": {
            "docs": "Number of the files in the group.",
            "type": "optional<double>",
          },
          "id": {
            "docs": "Group's unique ID.",
            "type": "optional<string>",
          },
          "url": {
            "docs": "Group's API resource URL. See the [REST API](/api-refs/rest-api/) documentation for details.",
            "type": "optional<string>",
            "validation": {
              "format": "uri",
              "maxLength": undefined,
              "minLength": undefined,
              "pattern": undefined,
            },
          },
        },
      },
      "GroupNotFoundError": {
        "type": "string",
      },
      "HostnameNotFoundError": {
        "type": "string",
      },
      "ImageInfo": {
        "docs": "Image metadata.",
        "properties": {
          "color_mode": {
            "docs": "Image color mode.",
            "type": "ImageInfoColorMode",
          },
          "datetime_original": {
            "docs": "Image date and time from EXIF. Please be aware that this data is not always formatted and displayed exactly as it appears in the EXIF.",
            "type": "optional<datetime>",
          },
          "dpi": {
            "docs": "Image DPI for two dimensions.",
            "type": "optional<list<double>>",
          },
          "format": {
            "docs": "Image format.",
            "type": "string",
          },
          "geo_location": {
            "docs": "Geo-location of image from EXIF.",
            "type": "optional<ImageInfoGeoLocation>",
          },
          "height": {
            "docs": "Image height in pixels.",
            "type": "integer",
          },
          "orientation": {
            "docs": "Image orientation from EXIF.",
            "type": "optional<integer>",
            "validation": {
              "exclusiveMax": undefined,
              "exclusiveMin": undefined,
              "max": 8,
              "min": 0,
              "multipleOf": undefined,
            },
          },
          "sequence": {
            "docs": "Set to true if a file contains a sequence of images (GIF for example).",
            "type": "boolean",
          },
          "width": {
            "docs": "Image width in pixels.",
            "type": "integer",
          },
        },
      },
      "ImageInfoColorMode": {
        "docs": "Image color mode.",
        "enum": [
          "RGB",
          "RGBA",
          "RGBX",
          "L",
          "LA",
          "P",
          "PA",
          "CMYK",
          "YCbCr",
          "HSV",
          "LAB",
        ],
      },
      "ImageInfoGeoLocation": {
        "docs": "Geo-location of image from EXIF.",
        "properties": {
          "latitude": {
            "docs": "Location latitude.",
            "type": "double",
          },
          "longitude": {
            "docs": "Location longitude.",
            "type": "double",
          },
        },
      },
      "LegacyVideoInfo": {
        "docs": "Video metadata.",
        "properties": {
          "audio": {
            "docs": "Audio stream's metadata.",
            "type": "optional<LegacyVideoInfoAudio>",
          },
          "bitrate": {
            "docs": "Video file's bitrate.",
            "type": "optional<double>",
          },
          "duration": {
            "docs": "Video file's duration in milliseconds.",
            "type": "optional<double>",
          },
          "format": {
            "docs": "Video file's format.",
            "type": "optional<string>",
          },
          "video": {
            "docs": "Video stream's metadata.",
            "type": "optional<LegacyVideoInfoVideo>",
          },
        },
      },
      "LegacyVideoInfoAudio": {
        "docs": "Audio stream's metadata.",
        "properties": {
          "bitrate": {
            "docs": "Audio stream's bitrate.",
            "type": "optional<double>",
          },
          "channels": {
            "docs": "Audio stream's number of channels.",
            "type": "optional<string>",
          },
          "codec": {
            "docs": "Audio stream's codec.",
            "type": "optional<string>",
          },
          "sample_rate": {
            "docs": "Audio stream's sample rate.",
            "type": "optional<double>",
          },
        },
      },
      "LegacyVideoInfoVideo": {
        "docs": "Video stream's metadata.",
        "properties": {
          "bitrate": {
            "docs": "Video stream's bitrate.",
            "type": "optional<double>",
          },
          "codec": {
            "docs": "Video stream codec.",
            "type": "optional<string>",
          },
          "frame_rate": {
            "docs": "Video stream's frame rate.",
            "type": "optional<double>",
          },
          "height": {
            "docs": "Video stream's image height.",
            "type": "optional<double>",
          },
          "width": {
            "docs": "Video stream's image width.",
            "type": "optional<double>",
          },
        },
      },
      "Metadata": {
        "docs": "Arbitrary metadata associated with a file.",
        "type": "optional<map<string, unknown>>",
      },
      "MetadataValue": {
        "docs": "Arbitrary metadata associated with the file.
See [docs](https://uploadcare.com/docs/file-metadata/) and [REST API v0.7](/api-refs/rest-api/v0.7.0/#tag/File-metadata) for more information.
",
        "type": "string",
        "validation": {
          "format": undefined,
          "maxLength": 512,
          "minLength": 1,
          "pattern": undefined,
        },
      },
      "MultipartFileAlreadyUploadedError": {
        "type": "string",
      },
      "MultipartFileCompletionFailedError": {
        "type": "string",
      },
      "MultipartFileIdRequiredError": {
        "type": "string",
      },
      "MultipartFileSizeLimitExceededError": {
        "type": "string",
      },
      "MultipartFileSizeTooSmallError": {
        "type": "string",
      },
      "MultipartPartSizeInvalidError": {
        "type": "string",
      },
      "MultipartPartSizeTooBigError": {
        "type": "string",
      },
      "MultipartPartSizeTooSmallError": {
        "type": "string",
      },
      "MultipartSizeInvalidError": {
        "type": "string",
      },
      "MultipartUploadSizeTooLargeError": {
        "type": "string",
      },
      "MultipartUploadSizeTooSmallError": {
        "type": "string",
      },
      "NullCharactersForbiddenError": {
        "type": "string",
      },
      "PostRequestParserFailedError": {
        "type": "string",
      },
      "ProjectPublicKeyRemovedError": {
        "type": "string",
      },
      "ProjectPublicKeyType": {
        "docs": "Public key identifying an Uploadcare project your uploads will go to.",
        "type": "string",
      },
      "PublicKeyInvalidError": {
        "type": "string",
      },
      "PublicKeyRequiredError": {
        "type": "string",
      },
      "RequestFiledsNumberLimitExceededError": {
        "type": "string",
      },
      "RequestParamRequiredError": {
        "type": "string",
      },
      "SchemasImageInfo": {
        "docs": "Image metadata.",
        "properties": {
          "color_mode": {
            "docs": "Image color mode.",
            "type": "SchemasImageInfoColorMode",
          },
          "datetime_original": {
            "docs": "Image date and time from EXIF. Please be aware that this data is not always formatted and displayed exactly as it appears in the EXIF.",
            "type": "optional<datetime>",
          },
          "dpi": {
            "docs": "Image DPI for two dimensions.",
            "type": "optional<list<double>>",
          },
          "format": {
            "docs": "Image format.",
            "type": "string",
          },
          "geo_location": {
            "docs": "Geo-location of image from EXIF.",
            "type": "optional<SchemasImageInfoGeoLocation>",
          },
          "height": {
            "docs": "Image height in pixels.",
            "type": "integer",
          },
          "orientation": {
            "docs": "Image orientation from EXIF.",
            "type": "optional<integer>",
            "validation": {
              "exclusiveMax": undefined,
              "exclusiveMin": undefined,
              "max": 8,
              "min": 0,
              "multipleOf": undefined,
            },
          },
          "sequence": {
            "docs": "Set to true if a file contains a sequence of images (GIF for example).",
            "type": "boolean",
          },
          "width": {
            "docs": "Image width in pixels.",
            "type": "integer",
          },
        },
      },
      "SchemasImageInfoColorMode": {
        "docs": "Image color mode.",
        "enum": [
          "RGB",
          "RGBA",
          "RGBX",
          "L",
          "LA",
          "P",
          "PA",
          "CMYK",
          "YCbCr",
          "HSV",
          "LAB",
        ],
      },
      "SchemasImageInfoGeoLocation": {
        "docs": "Geo-location of image from EXIF.",
        "properties": {
          "latitude": {
            "docs": "Location latitude.",
            "type": "double",
          },
          "longitude": {
            "docs": "Location longitude.",
            "type": "double",
          },
        },
      },
      "SignatureExpirationError": {
        "type": "string",
      },
      "SignatureExpirationInvalidError": {
        "type": "string",
      },
      "SignatureExpirationRequiredError": {
        "type": "string",
      },
      "SignatureInvalidError": {
        "type": "string",
      },
      "SignatureRequiredError": {
        "type": "string",
      },
      "SignatureType": {
        "docs": "\`signature\` must be sent along with your upload request if you would like to use signed uploads.
The signature should be generated on your backend.
**Note**: the process requires knowledge of your Uploadcare Project's Secret key.
See [signed uploads](https://uploadcare.com/docs/security/secure-uploads/) for details.
",
        "type": "string",
      },
      "SourceUrlRequiredError": {
        "type": "string",
      },
      "StoreType": {
        "default": "auto",
        "docs": "Determines if an uploaded file should be marked as temporary or permanent.

The parameter can have the following values:
- \`0\` - do not mark an uploaded file as stored and remove it after 24 hours
- \`1\` - mark the uploaded file as stored
- \`auto\` - delegate the choice of the file-storing behavior to a project-wide setting called
  [auto-store](https://app.uploadcare.com/projects/-/settings/#storage).

The default value depends on the user registration date.

For all users registered after February 12, 2024 (UTC 13:30), the default value is \`auto\`. 
File-storing behavior depends entirely on what is set in the 
[storage settings](https://app.uploadcare.com/projects/-/settings/#storage) in the Dashboard.

For users registered before February 12, 2024, the default value is \`0\`. 
To ensure that file storage in the project matches the settings in the Dashboard,
change the value to \`auto\`.
",
        "enum": [
          {
            "name": "Zero",
            "value": "0",
          },
          {
            "name": "One",
            "value": "1",
          },
          "auto",
        ],
      },
      "TokenRequiredError": {
        "type": "string",
      },
      "UploadFailedError": {
        "type": "string",
      },
      "UploadcarePublicKeyInvalidError": {
        "type": "string",
      },
      "UploadcarePublicKeyRequiredError": {
        "type": "string",
      },
      "UrlBlacklistedError": {
        "type": "string",
      },
      "UrlHostMalformedError": {
        "type": "string",
      },
      "UrlHostPrivateIpForbiddenError": {
        "type": "string",
      },
      "UrlHostRequiredError": {
        "type": "string",
      },
      "UrlParsingFailedError": {
        "type": "string",
      },
      "UrlSchemeInvalidError": {
        "type": "string",
      },
      "UrlSchemeRequiredError": {
        "type": "string",
      },
      "UuidInvalidError": {
        "type": "string",
      },
      "VideoInfo": {
        "docs": "Video metadata.",
        "properties": {
          "audio": "list<VideoInfoAudioItem>",
          "bitrate": {
            "docs": "Video file's bitrate.",
            "type": "optional<integer>",
          },
          "duration": {
            "docs": "Video file's duration in milliseconds.",
            "type": "optional<integer>",
          },
          "format": {
            "docs": "Video file's format.",
            "type": "string",
          },
          "video": "list<VideoInfoVideoItem>",
        },
      },
      "VideoInfoAudioItem": {
        "docs": "Audio stream's metadata.",
        "properties": {
          "bitrate": {
            "docs": "Audio stream's bitrate.",
            "type": "optional<integer>",
          },
          "channels": {
            "docs": "Audio stream's number of channels.",
            "type": "optional<integer>",
          },
          "codec": {
            "docs": "Audio stream's codec.",
            "type": "optional<string>",
          },
          "sample_rate": {
            "docs": "Audio stream's sample rate.",
            "type": "optional<integer>",
          },
        },
      },
      "VideoInfoVideoItem": {
        "docs": "Video stream's metadata.",
        "properties": {
          "bitrate": {
            "docs": "Video stream's bitrate.",
            "type": "optional<integer>",
          },
          "codec": {
            "docs": "Video stream's codec.",
            "type": "optional<string>",
          },
          "frame_rate": {
            "docs": "Video stream's frame rate.",
            "type": "double",
          },
          "height": {
            "docs": "Video stream's image height.",
            "type": "integer",
          },
          "width": {
            "docs": "Video stream's image width.",
            "type": "integer",
          },
        },
      },
    },
  },
  "rootApiFile": {
    "default-environment": "Default",
    "display-name": "Upload API Reference",
    "environments": {
      "Default": "https://upload.uploadcare.com",
    },
    "error-discrimination": {
      "strategy": "status-code",
    },
    "name": "api",
  },
}
`;
