// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`open api ir to fern humanloop docs 1`] = `
{
  "definitionFiles": {
    "datasets.yml": {
      "docs": "Datasets are collections of input-output pairs that you can use within Humanloop for Evaluations.

#### What is a Dataset?

A Dataset is a collection of unique Datapoints. These Datapoints contain \`inputs\` and \`target\` fields. The \`inputs\`
are used to populate a Prompt's template and the \`target\` can be referenced by Evaluators to evaluate the quality of
the generated output.

Note that Humanloop automatically deduplicates Datapoints. If you try to add a Datapoint that already exists, it will
be ignored. If you intentionally want to add a duplicate Datapoint, you can add a unique identifier to the Datapoint's
inputs such as \`{_dedupe_id: <unique ID>}\`.

#### Creating Dataset versions

Datasets have immutable versions. To add/remove Datapoint to/from an existing version, use the **Create** endpoint
and specify \`action\` as \`"add"\` or \`"remove"\` respectively. You may also specify the \`version_id\` or \`environment\`
query parameters to identify the existing version to base the new version on. If neither is provided, the version
deployed to the default Environment will be used.

",
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "display-name": "Datasets",
        "endpoints": {
          "commit": {
            "auth": true,
            "display-name": "Commit",
            "docs": "Commit the Dataset Version with the given ID.",
            "errors": [
              "root.DatasetsCommitRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                  "version_id": "version_id",
                },
                "request": {
                  "commit_message": "commit_message",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "datapoints": [
                      {
                        "id": "id",
                        "inputs": {
                          "key": "value",
                        },
                        "messages": [
                          {
                            "role": "user",
                          },
                        ],
                        "target": {
                          "key": "value",
                        },
                      },
                    ],
                    "datapoints_count": 1,
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "id": "id",
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "status": "uncommitted",
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/datasets/{id}/versions/{version_id}/commit",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Dataset.",
                "type": "string",
              },
              "version_id": {
                "docs": "Unique identifier for the specific version of the Dataset.",
                "type": "string",
              },
            },
            "request": {
              "body": "root.CommitRequest",
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.DatasetResponse",
            },
          },
          "create": {
            "auth": true,
            "display-name": "Create Dataset",
            "docs": "Create a Dataset.

Dataset have immutable versions. When you call this endpoint
with the same Dataset name but different parameters, a new version of
the Dataset will be created.

If you provide a commit message, then the new version will be committed;
otherwise it will be uncommitted. If you try to commit an already committed version,
an exception will be raised.

By default, the new Dataset version will be set to the list of Datapoints provided in
the request.
You can create a new version by adding or removing Datapoints from an existing version
by specifying \`action\` as \`add\` or \`remove\` respectively. In this case, you may specify
the \`version_id\` or \`environment\` query parameters to identify the existing version to base
the new version on. If neither is provided, the default deployed version will be used.

Humanloop also deduplicates Datapoints. If you try to add a Datapoint that already
exists, it will be ignored.",
            "errors": [
              "root.DatasetsCreateRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "request": {
                  "datapoints": [
                    {},
                  ],
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "datapoints": [
                      {
                        "id": "id",
                        "inputs": {
                          "key": "value",
                        },
                        "messages": [
                          {
                            "role": "user",
                          },
                        ],
                        "target": {
                          "key": "value",
                        },
                      },
                    ],
                    "datapoints_count": 1,
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "id": "id",
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "status": "uncommitted",
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/datasets",
            "request": {
              "body": {
                "properties": {
                  "action": {
                    "docs": "The action to take with the provided Datapoints.

 - If \`"set"\`, the created version will only contain the Datapoints provided in this request. 
 - If \`"add"\`, the created version will contain the Datapoints provided in this request in addition to the Datapoints in the target version. 
 - If \`"remove"\`, the created version will contain the Datapoints in the target version except for the Datapoints provided in this request. 

If \`"add"\` or \`"remove"\`, one of the \`version_id\` or \`environment\` query parameters may be provided.",
                    "type": "optional<root.UpdateDatesetAction>",
                  },
                  "commit_message": {
                    "docs": "Message describing the changes made. If provided, a committed version of the Dataset is created. Otherwise, an uncommitted version is created.",
                    "type": "optional<string>",
                  },
                  "datapoints": {
                    "docs": "The Datapoints to create this Dataset version with. Modify the \`action\` field to determine how these Datapoints are used.",
                    "type": "list<root.CreateDatapointRequest>",
                  },
                  "name": {
                    "docs": "Name of the Dataset, which is used as a unique identifier.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "DatasetRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag to identify a deployed Version to base the created Version on. Only used when \`action\` is \`"add"\` or \`"remove"\`.",
                  "type": "optional<string>",
                },
                "version_id": {
                  "docs": "ID of the specific Dataset version to base the created Version on. Only used when \`action\` is \`"add"\` or \`"remove"\`.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.DatasetResponse",
            },
          },
          "delete": {
            "auth": true,
            "display-name": "Delete Dataset",
            "docs": "Delete the Dataset with the given ID.",
            "errors": [
              "root.DatasetsDeleteRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
              },
            ],
            "method": "DELETE",
            "pagination": undefined,
            "path": "/datasets/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Dataset.",
                "type": "string",
              },
            },
          },
          "deploy": {
            "auth": true,
            "display-name": "Deploy",
            "docs": "Deploy Dataset to Environment.

Set the deployed Version for the specified Environment.",
            "errors": [
              "root.DeployDatasetsIdVersionsVersionIdDeployPostRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                  "version_id": "version_id",
                },
                "query-parameters": {
                  "environment_id": "environment_id",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "datapoints": [
                      {
                        "id": "id",
                        "inputs": {
                          "key": "value",
                        },
                        "messages": [
                          {
                            "role": "user",
                          },
                        ],
                        "target": {
                          "key": "value",
                        },
                      },
                    ],
                    "datapoints_count": 1,
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "id": "id",
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "status": "uncommitted",
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/datasets/{id}/versions/{version_id}/deploy",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Dataset.",
                "type": "string",
              },
              "version_id": {
                "docs": "Unique identifier for the specific version of the Dataset.",
                "type": "string",
              },
            },
            "request": {
              "name": "DeployDatasetsIdVersionsVersionIdDeployPostRequest",
              "query-parameters": {
                "environment_id": {
                  "docs": "Unique identifier for the Environment to deploy the Version to.",
                  "type": "string",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.DatasetResponse",
            },
          },
          "get": {
            "auth": true,
            "display-name": "Get Dataset",
            "docs": "Retrieve the Dataset with the given ID.

Unless \`include_datapoints\` is set to \`true\`, the response will not include
the Datapoints.
Use the List Datapoints endpoint (\`GET /{id}/datapoints\`) to efficiently
retrieve Datapoints for a large Dataset.

By default the deployed version of the Dataset is returned. Use the query parameters
\`version_id\` or \`environment\` to target a specific version of the Dataset.",
            "errors": [
              "root.DatasetsGetRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "datapoints": [
                      {
                        "id": "id",
                        "inputs": {
                          "key": "value",
                        },
                        "messages": [
                          {
                            "role": "user",
                          },
                        ],
                        "target": {
                          "key": "value",
                        },
                      },
                    ],
                    "datapoints_count": 1,
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "id": "id",
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "status": "uncommitted",
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/datasets/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Dataset.",
                "type": "string",
              },
            },
            "request": {
              "name": "DatasetsGetRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag to retrieve a deployed Version from.",
                  "type": "optional<string>",
                },
                "include_datapoints": {
                  "docs": "If set to \`true\`, include all Datapoints in the response. Defaults to \`false\`. Consider using the paginated List Datapoints endpoint instead.",
                  "type": "optional<boolean>",
                },
                "version_id": {
                  "docs": "A specific Version ID of the Dataset to retrieve.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.DatasetResponse",
            },
          },
          "list": {
            "auth": true,
            "display-name": "List ",
            "docs": "Get a list of Datasets.",
            "errors": [
              "root.DatasetsListRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "response": {
                  "body": {
                    "page": 1,
                    "records": [
                      {
                        "commit_message": "commit_message",
                        "created_at": "2024-01-15T09:30:00Z",
                        "created_by": {
                          "email_address": "email_address",
                          "id": "id",
                        },
                        "datapoints": [
                          {
                            "id": "id",
                          },
                        ],
                        "datapoints_count": 1,
                        "environments": [
                          {
                            "created_at": "2024-01-15T09:30:00Z",
                            "id": "id",
                            "name": "name",
                            "tag": "default",
                          },
                        ],
                        "id": "id",
                        "last_used_at": "2024-01-15T09:30:00Z",
                        "name": "name",
                        "status": "uncommitted",
                        "updated_at": "2024-01-15T09:30:00Z",
                        "version_id": "version_id",
                      },
                    ],
                    "size": 1,
                    "total": 1,
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/datasets",
            "request": {
              "name": "DatasetsListRequest",
              "query-parameters": {
                "name": {
                  "docs": "Case-insensitive filter for Dataset name.",
                  "type": "optional<string>",
                },
                "order": {
                  "docs": "Direction to sort by.",
                  "type": "optional<root.SortOrder>",
                },
                "page": {
                  "docs": "Page offset for pagination.",
                  "type": "optional<integer>",
                },
                "size": {
                  "docs": "Page size for pagination. Number of Datasets to fetch.",
                  "type": "optional<integer>",
                },
                "sort_by": {
                  "docs": "Field to sort Datasets by",
                  "type": "optional<root.ProjectSortBy>",
                },
                "user_filter": {
                  "docs": "Case-insensitive filter for users in the Dataset. This filter matches against both email address and name of users.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PaginatedDataDatasetResponse",
            },
          },
          "listdatapoints": {
            "auth": true,
            "display-name": "List Datapoints",
            "docs": "List all Datapoints for the Dataset with the given ID.",
            "errors": [
              "root.DatasetsListDatapointsRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "page": 1,
                    "records": [
                      {
                        "id": "id",
                        "inputs": {
                          "key": "value",
                        },
                        "messages": [
                          {
                            "role": "user",
                          },
                        ],
                        "target": {
                          "key": "value",
                        },
                      },
                    ],
                    "size": 1,
                    "total": 1,
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/datasets/{id}/datapoints",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Dataset.",
                "type": "string",
              },
            },
            "request": {
              "name": "DatasetsListDatapointsRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag to retrieve a deployed Version from.",
                  "type": "optional<string>",
                },
                "page": {
                  "docs": "Page number for pagination.",
                  "type": "optional<integer>",
                },
                "size": {
                  "docs": "Page size for pagination. Number of Datapoints to fetch.",
                  "type": "optional<integer>",
                },
                "version_id": {
                  "docs": "A specific Version ID of the Dataset to retrieve.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PaginatedDataDatapointResponse",
            },
          },
          "listversions": {
            "auth": true,
            "display-name": "List Versions",
            "docs": "Get a list of the versions for a Dataset.",
            "errors": [
              "root.DatasetsListVersionsRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "records": [
                      {
                        "commit_message": "commit_message",
                        "created_at": "2024-01-15T09:30:00Z",
                        "created_by": {
                          "email_address": "email_address",
                          "id": "id",
                        },
                        "datapoints": [
                          {
                            "id": "id",
                          },
                        ],
                        "datapoints_count": 1,
                        "environments": [
                          {
                            "created_at": "2024-01-15T09:30:00Z",
                            "id": "id",
                            "name": "name",
                            "tag": "default",
                          },
                        ],
                        "id": "id",
                        "last_used_at": "2024-01-15T09:30:00Z",
                        "name": "name",
                        "status": "uncommitted",
                        "updated_at": "2024-01-15T09:30:00Z",
                        "version_id": "version_id",
                      },
                    ],
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/datasets/{id}/versions",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Dataset.",
                "type": "string",
              },
            },
            "request": {
              "name": "DatasetsListVersionsRequest",
              "query-parameters": {
                "environment": {
                  "docs": "Filter versions by environment tag. If no environment is provided, all versions are returned.",
                  "type": "optional<string>",
                },
                "evaluation_aggregates": "optional<boolean>",
                "status": {
                  "docs": "Filter versions by status: 'uncommitted', 'committed'. If no status is provided, all versions are returned.",
                  "type": "optional<root.VersionStatus>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ListDatasets",
            },
          },
          "update": {
            "auth": true,
            "display-name": "Update Dataset",
            "docs": "Update the Dataset with the given ID.",
            "errors": [
              "root.DatasetsUpdateRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {},
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "datapoints": [
                      {
                        "id": "id",
                        "inputs": {
                          "key": "value",
                        },
                        "messages": [
                          {
                            "role": "user",
                          },
                        ],
                        "target": {
                          "key": "value",
                        },
                      },
                    ],
                    "datapoints_count": 1,
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "id": "id",
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "status": "uncommitted",
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                  },
                },
              },
            ],
            "method": "PATCH",
            "pagination": undefined,
            "path": "/datasets/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Dataset.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "name": {
                    "docs": "Name of the Dataset, which is used as a unique identifier.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "UpdateDatasetRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.DatasetResponse",
            },
          },
        },
      },
    },
    "evaluations.yml": {
      "docs": "Evaluations help you measure the performance of your Prompts, Tools and LLM Evaluators.

An Evaluation consists of a Dataset, Evaluatees (i.e. Versions to evaluate), and Evaluators.
When an Evaluation is created, Humanloop will start generating Logs, iterating through Datapoints in the Dataset,
for each Evaluatee. The Evaluators will then be run on these Logs.

Aggregate stats can be viewed in the Humanloop app or retrieved with the **Get Evaluation Stats** endpoint.

Note that when an Evaluation is created, Humanloop will attempt to reuse any existing Logs for each Datapoint-Evaluatee
pair. This means that you can create multiple Evaluations without generating new Logs unnecessarily.

",
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "display-name": "Evaluations",
        "endpoints": {
          "create": {
            "auth": true,
            "display-name": "Create Evaluation",
            "docs": "Create an Evaluation.

Create a new Evaluation by specifying the Dataset, Evaluatees, and Evaluators.
Humanloop will automatically start generating Logs and running Evaluators.

To keep updated on the progress of the Evaluation, you can poll the Evaluation
and check its status.",
            "errors": [
              "root.EvaluationsCreateRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "request": {
                  "dataset": {
                    "version_id": "version_id",
                  },
                  "evaluatees": [
                    {
                      "version_id": "version_id",
                    },
                  ],
                  "evaluators": [
                    {
                      "version_id": "version_id",
                    },
                  ],
                },
                "response": {
                  "body": {
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "dataset": {
                      "commit_message": "commit_message",
                      "created_at": "2024-01-15T09:30:00Z",
                      "created_by": {
                        "email_address": "email_address",
                        "full_name": "full_name",
                        "id": "id",
                      },
                      "datapoints": [
                        {
                          "id": "id",
                        },
                      ],
                      "datapoints_count": 1,
                      "environments": [
                        {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "name": "name",
                          "tag": "default",
                        },
                      ],
                      "id": "id",
                      "last_used_at": "2024-01-15T09:30:00Z",
                      "name": "name",
                      "status": "uncommitted",
                      "updated_at": "2024-01-15T09:30:00Z",
                      "version_id": "version_id",
                    },
                    "evaluatees": [
                      {
                        "batch_id": "batch_id",
                        "orchestrated": true,
                        "version": {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "inputs": [
                            {
                              "name": "name",
                            },
                          ],
                          "last_used_at": "2024-01-15T09:30:00Z",
                          "model": "model",
                          "name": "name",
                          "status": "uncommitted",
                          "total_logs_count": 1,
                          "updated_at": "2024-01-15T09:30:00Z",
                          "version_id": "version_id",
                          "version_logs_count": 1,
                        },
                      },
                    ],
                    "evaluators": [],
                    "id": "id",
                    "status": "pending",
                    "updated_at": "2024-01-15T09:30:00Z",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/evaluations",
            "request": {
              "body": "root.CreateEvaluationRequest",
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluationResponse",
            },
          },
          "delete": {
            "auth": true,
            "display-name": "Delete Evaluation",
            "docs": "Delete an Evaluation.

Remove an Evaluation from Humanloop. The Logs and Versions used in the Evaluation
will not be deleted.",
            "errors": [
              "root.EvaluationsDeleteRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
              },
            ],
            "method": "DELETE",
            "pagination": undefined,
            "path": "/evaluations/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluation.",
                "type": "string",
              },
            },
          },
          "get": {
            "auth": true,
            "display-name": "Get Evaluation",
            "docs": "Get an Evaluation.

Retrieve the Evaluation with the given ID.",
            "errors": [
              "root.EvaluationsGetRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "dataset": {
                      "commit_message": "commit_message",
                      "created_at": "2024-01-15T09:30:00Z",
                      "created_by": {
                        "email_address": "email_address",
                        "full_name": "full_name",
                        "id": "id",
                      },
                      "datapoints": [
                        {
                          "id": "id",
                        },
                      ],
                      "datapoints_count": 1,
                      "environments": [
                        {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "name": "name",
                          "tag": "default",
                        },
                      ],
                      "id": "id",
                      "last_used_at": "2024-01-15T09:30:00Z",
                      "name": "name",
                      "status": "uncommitted",
                      "updated_at": "2024-01-15T09:30:00Z",
                      "version_id": "version_id",
                    },
                    "evaluatees": [
                      {
                        "batch_id": "batch_id",
                        "orchestrated": true,
                        "version": {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "inputs": [
                            {
                              "name": "name",
                            },
                          ],
                          "last_used_at": "2024-01-15T09:30:00Z",
                          "model": "model",
                          "name": "name",
                          "status": "uncommitted",
                          "total_logs_count": 1,
                          "updated_at": "2024-01-15T09:30:00Z",
                          "version_id": "version_id",
                          "version_logs_count": 1,
                        },
                      },
                    ],
                    "evaluators": [],
                    "id": "id",
                    "status": "pending",
                    "updated_at": "2024-01-15T09:30:00Z",
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/evaluations/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluation.",
                "type": "string",
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluationResponse",
            },
          },
          "getstats": {
            "auth": true,
            "display-name": "Get Evaluation Stats",
            "docs": "Get Evaluation Stats.

Retrieve aggregate stats for the specified Evaluation.
This includes the number of generated Logs for every evaluatee and Evaluator metrics
(such as the mean and percentiles for numeric Evaluators for every evaluatee).",
            "errors": [
              "root.EvaluationsGetStatsRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "overall_stats": {
                      "num_datapoints": 1,
                      "total_evaluator_logs": 1,
                      "total_logs": 1,
                    },
                    "version_stats": [
                      {
                        "evaluator_version_stats": [
                          {
                            "evaluator_version_id": "evaluator_version_id",
                            "mean": 0,
                            "num_errors": 1,
                            "num_judgments": 1,
                            "num_nulls": 1,
                            "percentiles": {
                              "0": -2.5,
                              "100": 2.5,
                              "25": -0.6745,
                              "50": 0,
                              "75": 0.6745,
                            },
                            "std": 1,
                            "total_logs": 1,
                          },
                        ],
                        "num_logs": 1,
                        "version_id": "version_id",
                      },
                    ],
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/evaluations/{id}/stats",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluation.",
                "type": "string",
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluationStats",
            },
          },
          "list": {
            "auth": true,
            "display-name": "List Evaluations for File",
            "docs": "List Evaluations for the given File.

Retrieve a list of Evaluations that evaluate versions of the specified File.",
            "errors": [
              "root.EvaluationsListRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "query-parameters": {
                  "file_id": "file_id",
                },
                "response": {
                  "body": {
                    "page": 1,
                    "records": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "created_by": {
                          "email_address": "email_address",
                          "id": "id",
                        },
                        "dataset": {
                          "created_at": "2024-01-15T09:30:00Z",
                          "datapoints_count": 1,
                          "id": "id",
                          "last_used_at": "2024-01-15T09:30:00Z",
                          "name": "name",
                          "status": "uncommitted",
                          "updated_at": "2024-01-15T09:30:00Z",
                          "version_id": "version_id",
                        },
                        "evaluatees": [
                          {
                            "orchestrated": true,
                            "version": {
                              "created_at": "2024-01-15T09:30:00Z",
                              "id": "id",
                              "inputs": [
                                {
                                  "name": "name",
                                },
                              ],
                              "last_used_at": "2024-01-15T09:30:00Z",
                              "model": "model",
                              "name": "name",
                              "status": "uncommitted",
                              "total_logs_count": 1,
                              "updated_at": "2024-01-15T09:30:00Z",
                              "version_id": "version_id",
                              "version_logs_count": 1,
                            },
                          },
                        ],
                        "evaluators": [],
                        "id": "id",
                        "status": "pending",
                        "updated_at": "2024-01-15T09:30:00Z",
                      },
                    ],
                    "size": 1,
                    "total": 1,
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/evaluations",
            "request": {
              "name": "EvaluationsListRequest",
              "query-parameters": {
                "file_id": {
                  "docs": "Filter by File ID. If provided, only Evaluation for the specified File will be returned.",
                  "type": "string",
                },
                "page": {
                  "docs": "Page number for pagination.",
                  "type": "optional<integer>",
                },
                "size": {
                  "docs": "Page size for pagination. Number of Evaluations to fetch.",
                  "type": "optional<integer>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PaginatedDataEvaluationResponse",
            },
          },
          "update": {
            "auth": true,
            "display-name": "Update Evaluation",
            "docs": "Update an Evaluation.

Update the setup of an Evaluation by specifying the Dataset, Evaluatees, and Evaluators.",
            "errors": [
              "root.EvaluationsUpdateRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {
                  "dataset": {
                    "version_id": "version_id",
                  },
                  "evaluatees": [
                    {
                      "version_id": "version_id",
                    },
                  ],
                  "evaluators": [
                    {
                      "version_id": "version_id",
                    },
                  ],
                },
                "response": {
                  "body": {
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "dataset": {
                      "commit_message": "commit_message",
                      "created_at": "2024-01-15T09:30:00Z",
                      "created_by": {
                        "email_address": "email_address",
                        "full_name": "full_name",
                        "id": "id",
                      },
                      "datapoints": [
                        {
                          "id": "id",
                        },
                      ],
                      "datapoints_count": 1,
                      "environments": [
                        {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "name": "name",
                          "tag": "default",
                        },
                      ],
                      "id": "id",
                      "last_used_at": "2024-01-15T09:30:00Z",
                      "name": "name",
                      "status": "uncommitted",
                      "updated_at": "2024-01-15T09:30:00Z",
                      "version_id": "version_id",
                    },
                    "evaluatees": [
                      {
                        "batch_id": "batch_id",
                        "orchestrated": true,
                        "version": {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "inputs": [
                            {
                              "name": "name",
                            },
                          ],
                          "last_used_at": "2024-01-15T09:30:00Z",
                          "model": "model",
                          "name": "name",
                          "status": "uncommitted",
                          "total_logs_count": 1,
                          "updated_at": "2024-01-15T09:30:00Z",
                          "version_id": "version_id",
                          "version_logs_count": 1,
                        },
                      },
                    ],
                    "evaluators": [],
                    "id": "id",
                    "status": "pending",
                    "updated_at": "2024-01-15T09:30:00Z",
                  },
                },
              },
            ],
            "method": "PATCH",
            "pagination": undefined,
            "path": "/evaluations/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluation.",
                "type": "string",
              },
            },
            "request": {
              "body": "root.CreateEvaluationRequest",
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluationResponse",
            },
          },
          "updatestatus": {
            "auth": true,
            "display-name": "Update Status",
            "docs": "Update the status of an Evaluation.

Can be used to cancel a running Evaluation, or mark an Evaluation that uses external or human evaluators
as completed.",
            "errors": [
              "root.EvaluationsUpdateStatusRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {
                  "status": "pending",
                },
                "response": {
                  "body": {
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "dataset": {
                      "commit_message": "commit_message",
                      "created_at": "2024-01-15T09:30:00Z",
                      "created_by": {
                        "email_address": "email_address",
                        "full_name": "full_name",
                        "id": "id",
                      },
                      "datapoints": [
                        {
                          "id": "id",
                        },
                      ],
                      "datapoints_count": 1,
                      "environments": [
                        {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "name": "name",
                          "tag": "default",
                        },
                      ],
                      "id": "id",
                      "last_used_at": "2024-01-15T09:30:00Z",
                      "name": "name",
                      "status": "uncommitted",
                      "updated_at": "2024-01-15T09:30:00Z",
                      "version_id": "version_id",
                    },
                    "evaluatees": [
                      {
                        "batch_id": "batch_id",
                        "orchestrated": true,
                        "version": {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "inputs": [
                            {
                              "name": "name",
                            },
                          ],
                          "last_used_at": "2024-01-15T09:30:00Z",
                          "model": "model",
                          "name": "name",
                          "status": "uncommitted",
                          "total_logs_count": 1,
                          "updated_at": "2024-01-15T09:30:00Z",
                          "version_id": "version_id",
                          "version_logs_count": 1,
                        },
                      },
                    ],
                    "evaluators": [],
                    "id": "id",
                    "status": "pending",
                    "updated_at": "2024-01-15T09:30:00Z",
                  },
                },
              },
            ],
            "method": "PATCH",
            "pagination": undefined,
            "path": "/evaluations/{id}/status",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluation.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "status": "root.EvaluationStatus",
                },
              },
              "headers": undefined,
              "name": "BodyEvaluationsUpdateStatus",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluationResponse",
            },
          },
        },
      },
    },
    "evaluators.yml": {
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "endpoints": {
          "commit": {
            "auth": true,
            "display-name": "Commit",
            "docs": "Commit the Evaluator Version with the given ID.",
            "errors": [
              "root.EvaluatorsCommitRequestUnprocessableEntityError",
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/evaluators/{id}/versions/{version_id}/commit",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
              "version_id": {
                "docs": "Unique identifier for the specific version of the Evaluator.",
                "type": "string",
              },
            },
            "request": {
              "body": "root.CommitRequest",
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluatorResponse",
            },
          },
          "create": {
            "auth": true,
            "display-name": "Create Evaluator",
            "docs": "Create an Evaluator.

Evaluators have immutable versions. When you call this endpoint
with the same Evaluator name but different spec, a new version of
the Evaluator will be created.

If you provide a commit message, then the new version will be committed;
otherwise it will be uncommitted. If you try to commit an already committed version,
an exception will be raised.",
            "errors": [
              "root.EvaluatorsCreateRequestUnprocessableEntityError",
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/evaluators",
            "request": {
              "body": {
                "properties": {
                  "commit_message": {
                    "docs": "Message describing the changes made.",
                    "type": "optional<string>",
                  },
                  "directory_id": {
                    "docs": "Unique identifier for the Directory of the Evaluator.",
                    "type": "optional<string>",
                  },
                  "name": {
                    "docs": "Name of the Evaluator, which is used as a unique identifier.",
                    "type": "optional<string>",
                  },
                  "spec": "Spec",
                },
              },
              "headers": undefined,
              "name": "EvaluatorRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluatorResponse",
            },
          },
          "debug": {
            "auth": true,
            "display-name": "Debug",
            "docs": "Run a synchronous evaluator execution on a collection of datapoints.",
            "errors": [
              "root.DebugEvaluatorsDebugPostRequestUnprocessableEntityError",
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/evaluators/debug",
            "request": {
              "body": {
                "properties": {
                  "datapoint_ids": {
                    "docs": "The IDs of the evaluation datapoints on which to run the draft evaluator. ",
                    "type": "optional<list<string>>",
                  },
                  "evaluator": "Evaluator",
                  "evaluator_version_id": {
                    "docs": "The ID of the Evaluator Version being debugged if it already exists and is being edited.",
                    "type": "optional<string>",
                  },
                  "file_id": {
                    "docs": "The ID of the Dataset that the datapoints belong to.",
                    "type": "string",
                  },
                  "log_ids": {
                    "docs": "The IDs of the logs on which to run the draft evaluator.Provide one of \`log_ids\` or \`datapoint_ids\`.",
                    "type": "optional<list<string>>",
                  },
                  "prompt_version_id": {
                    "docs": "The ID of the Prompt Version to use generate datapoints for the evaluation datapoints. Only required if \`datapoint\` is provided; has no effect otherwise.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "RunSyncEvaluationRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "list<root.EvaluationDebugResultResponse>",
            },
          },
          "delete": {
            "auth": true,
            "display-name": "Delete Evaluator",
            "docs": "Delete the Evaluator with the given ID.",
            "errors": [
              "root.EvaluatorsDeleteRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
              },
            ],
            "method": "DELETE",
            "pagination": undefined,
            "path": "/evaluators/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluator.",
                "type": "string",
              },
            },
          },
          "deploy": {
            "auth": true,
            "display-name": "Deploy",
            "docs": "Deploy Evaluator to Environment.

Set the deployed Version for the specified Environment. This Evaluator Version
will be used for calls made to the Evaluator in this Environment.",
            "errors": [
              "root.DeployEvaluatorsIdVersionsVersionIdDeployPostRequestUnprocessableEntityError",
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/evaluators/{id}/versions/{version_id}/deploy",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluator.",
                "type": "string",
              },
              "version_id": {
                "docs": "Unique identifier for the specific version of the Evaluator.",
                "type": "string",
              },
            },
            "request": {
              "name": "DeployEvaluatorsIdVersionsVersionIdDeployPostRequest",
              "query-parameters": {
                "environment_id": {
                  "docs": "Unique identifier for the Environment to deploy the Version to.",
                  "type": "string",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluatorResponse",
            },
          },
          "get": {
            "auth": true,
            "display-name": "Get Evaluator",
            "docs": "Retrieve the Evaluator with the given ID.

By default the deployed version of the Evaluator is returned. Use the query parameters
\`version_id\` or \`environment\` to target a specific version of the Evaluator.",
            "errors": [
              "root.EvaluatorsGetRequestUnprocessableEntityError",
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/evaluators/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluator.",
                "type": "string",
              },
            },
            "request": {
              "name": "EvaluatorsGetRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag to retrieve a deployed Version from.",
                  "type": "optional<string>",
                },
                "version_id": {
                  "docs": "A specific Version Id  of the Evaluator to retrieve.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluatorResponse",
            },
          },
          "list": {
            "auth": true,
            "display-name": "List ",
            "docs": "Get a list of Evaluators.",
            "errors": [
              "root.EvaluatorsListRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "response": {
                  "body": {
                    "records": [],
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/evaluators",
            "request": {
              "name": "EvaluatorsListRequest",
              "query-parameters": {
                "name": {
                  "docs": "Case-insensitive filter for Evaluator name.",
                  "type": "optional<string>",
                },
                "order": {
                  "docs": "Direction to sort by.",
                  "type": "optional<root.SortOrder>",
                },
                "page": {
                  "docs": "Page offset for pagination.",
                  "type": "optional<integer>",
                },
                "size": {
                  "docs": "Page size for pagination. Number of Evaluators to fetch.",
                  "type": "optional<integer>",
                },
                "sort_by": {
                  "docs": "Field to sort Evaluators by",
                  "type": "optional<root.ProjectSortBy>",
                },
                "user_filter": {
                  "docs": "Case-insensitive filter for users in the Evaluator. This filter matches against both email address and name of users.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ListEvaluators",
            },
          },
          "listdefault": {
            "auth": true,
            "display-name": "List Default Evaluators",
            "docs": "Get a list of default evaluators for the organization.",
            "errors": [
              "root.EvaluatorsListDefaultRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "response": {
                  "body": [],
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/evaluators/default",
            "response": {
              "docs": "Successful Response",
              "type": "list<root.EvaluatorResponse>",
            },
          },
          "listversions": {
            "auth": true,
            "display-name": "List Versions",
            "docs": "Get a list of all the versions of an Evaluator.",
            "errors": [
              "root.EvaluatorsListVersionsRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "records": [],
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/evaluators/{id}/versions",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for the Evaluator.",
                "type": "string",
              },
            },
            "request": {
              "name": "EvaluatorsListVersionsRequest",
              "query-parameters": {
                "environment": {
                  "docs": "Filter versions by environment tag. If no environment is provided, all versions are returned.",
                  "type": "optional<string>",
                },
                "evaluation_aggregates": "optional<boolean>",
                "status": {
                  "docs": "Filter versions by status: 'uncommitted', 'committed'. If no status is provided, all versions are returned.",
                  "type": "optional<root.VersionStatus>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ListEvaluators",
            },
          },
          "update": {
            "auth": true,
            "display-name": "Update Evaluator",
            "docs": "Update the Evaluator with the given ID.",
            "errors": [
              "root.EvaluatorsUpdateRequestUnprocessableEntityError",
            ],
            "method": "PATCH",
            "pagination": undefined,
            "path": "/evaluators/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluator.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "directory_id": {
                    "docs": "Unique identifier for the Directory of the Evaluator.",
                    "type": "optional<string>",
                  },
                  "name": {
                    "docs": "Name of the Evaluator, which is used as a unique identifier.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "UpdateEvaluatorRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluatorResponse",
            },
          },
        },
      },
      "types": {
        "Evaluator": {
          "base-properties": {},
          "discriminant": "evaluator_type",
          "docs": undefined,
          "union": {
            "human": "root.HumanEvaluatorRequest",
            "llm": "root.LLMEvaluatorRequest",
            "python": "root.CodeEvaluatorRequest",
          },
        },
        "Spec": {
          "base-properties": {},
          "discriminant": "evaluator_type",
          "docs": undefined,
          "union": {
            "human": "root.HumanEvaluatorRequest",
            "llm": "root.LLMEvaluatorRequest",
            "python": "root.CodeEvaluatorRequest",
          },
        },
      },
    },
    "logs.yml": {
      "docs": "Logs contain the inputs and outputs of each time a Prompt, Tool or Evaluator is called.

Humanloop automatically records the inputs and outputs when you Call a Prompt or Tool and saves a Log.
Evaluator Logs are also created when an Evaluator is run on a Log.

You can manually create Logs through the API.

...


",
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "display-name": "Logs",
        "endpoints": {
          "delete": {
            "auth": true,
            "display-name": "Delete",
            "docs": "Delete Logs with the given IDs.",
            "errors": [
              "root.LogsDeleteRequestUnprocessableEntityError",
            ],
            "method": "DELETE",
            "pagination": undefined,
            "path": "/logs",
            "request": {
              "name": "LogsDeleteRequest",
              "query-parameters": {
                "id": {
                  "allow-multiple": true,
                  "docs": "Unique identifiers for the Logs to delete.",
                  "type": "optional<string>",
                },
              },
            },
          },
          "get": {
            "auth": true,
            "display-name": "Get Log",
            "docs": "Retrieve the Log with the given ID.",
            "errors": [
              "root.LogsGetRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "batches": [
                      "batches",
                    ],
                    "created_at": "2024-01-15T09:30:00Z",
                    "environment": "environment",
                    "error": "error",
                    "finish_reason": "finish_reason",
                    "id": "id",
                    "inputs": {
                      "key": "value",
                    },
                    "messages": [
                      {
                        "content": "content",
                        "name": "name",
                        "role": "user",
                        "tool_call_id": "tool_call_id",
                        "tool_calls": [
                          {
                            "function": {
                              "name": "name",
                            },
                            "id": "id",
                            "type": "function",
                          },
                        ],
                      },
                    ],
                    "metadata": {
                      "key": "value",
                    },
                    "output": "output",
                    "output_cost": 1.1,
                    "output_message": {
                      "content": "content",
                      "name": "name",
                      "role": "user",
                      "tool_call_id": "tool_call_id",
                      "tool_calls": [
                        {
                          "function": {
                            "name": "name",
                          },
                          "id": "id",
                          "type": "function",
                        },
                      ],
                    },
                    "output_tokens": 1,
                    "parent_id": "parent_id",
                    "prompt": {
                      "commit_message": "commit_message",
                      "created_at": "2024-01-15T09:30:00Z",
                      "created_by": {
                        "email_address": "email_address",
                        "full_name": "full_name",
                        "id": "id",
                      },
                      "directory_id": "directory_id",
                      "endpoint": "complete",
                      "environments": [
                        {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "name": "name",
                          "tag": "default",
                        },
                      ],
                      "frequency_penalty": 1.1,
                      "id": "id",
                      "inputs": [
                        {
                          "name": "name",
                        },
                      ],
                      "last_used_at": "2024-01-15T09:30:00Z",
                      "linked_tools": [
                        {
                          "description": "description",
                          "id": "id",
                          "name": "name",
                          "version_id": "version_id",
                        },
                      ],
                      "max_tokens": 1,
                      "model": "model",
                      "name": "name",
                      "other": {
                        "key": "value",
                      },
                      "presence_penalty": 1.1,
                      "provider": "openai",
                      "response_format": {
                        "type": "json_object",
                      },
                      "seed": 1,
                      "status": "uncommitted",
                      "stop": "stop",
                      "temperature": 1.1,
                      "template": "template",
                      "tools": [
                        {
                          "description": "description",
                          "name": "name",
                        },
                      ],
                      "top_p": 1.1,
                      "total_logs_count": 1,
                      "updated_at": "2024-01-15T09:30:00Z",
                      "version_id": "version_id",
                      "version_logs_count": 1,
                    },
                    "prompt_cost": 1.1,
                    "prompt_tokens": 1,
                    "provider_latency": 1.1,
                    "provider_request": {
                      "key": "value",
                    },
                    "provider_response": {
                      "key": "value",
                    },
                    "raw_output": "raw_output",
                    "save": true,
                    "session_id": "session_id",
                    "source": "source",
                    "source_datapoint_id": "source_datapoint_id",
                    "tool_choice": "none",
                    "user": "user",
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/logs/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Log.",
                "type": "string",
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PromptLogResponse",
            },
          },
          "listLogsForFile": {
            "auth": true,
            "display-name": "List",
            "docs": "List Logs.",
            "errors": [
              "root.ListLogsForFileLogsGetRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "query-parameters": {
                  "file_id": "file_id",
                },
                "response": {
                  "body": {
                    "page": 1,
                    "records": [
                      {
                        "batches": [
                          "batches",
                        ],
                        "created_at": "2024-01-15T09:30:00Z",
                        "environment": "environment",
                        "error": "error",
                        "finish_reason": "finish_reason",
                        "id": "id",
                        "inputs": {
                          "key": "value",
                        },
                        "messages": [
                          {
                            "role": "user",
                          },
                        ],
                        "metadata": {
                          "key": "value",
                        },
                        "output": "output",
                        "output_cost": 1.1,
                        "output_message": {
                          "role": "user",
                        },
                        "output_tokens": 1,
                        "parent_id": "parent_id",
                        "prompt": {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "inputs": [
                            {
                              "name": "name",
                            },
                          ],
                          "last_used_at": "2024-01-15T09:30:00Z",
                          "model": "model",
                          "name": "name",
                          "status": "uncommitted",
                          "total_logs_count": 1,
                          "updated_at": "2024-01-15T09:30:00Z",
                          "version_id": "version_id",
                          "version_logs_count": 1,
                        },
                        "prompt_cost": 1.1,
                        "prompt_tokens": 1,
                        "provider_latency": 1.1,
                        "provider_request": {
                          "key": "value",
                        },
                        "provider_response": {
                          "key": "value",
                        },
                        "raw_output": "raw_output",
                        "save": true,
                        "session_id": "session_id",
                        "source": "source",
                        "source_datapoint_id": "source_datapoint_id",
                        "tool_choice": "none",
                        "user": "user",
                      },
                    ],
                    "size": 1,
                    "total": 1,
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/logs",
            "request": {
              "name": "ListLogsForFileLogsGetRequest",
              "query-parameters": {
                "end_date": {
                  "docs": "If provided, only Logs created before the specified date will be returned.",
                  "type": "optional<datetime>",
                },
                "file_id": {
                  "docs": "Unique identifier for the File to list Logs for.",
                  "type": "string",
                },
                "metadata_search": {
                  "docs": "If provided, only Logs that contain the provided string in its metadata will be returned.",
                  "type": "optional<string>",
                },
                "page": {
                  "docs": "Page number for pagination.",
                  "type": "optional<integer>",
                },
                "search": {
                  "docs": "If provided, only Logs that contain the provided string in its inputs and output will be returned.",
                  "type": "optional<string>",
                },
                "size": {
                  "docs": "Page size for pagination. Number of Logs to fetch.",
                  "type": "optional<integer>",
                },
                "start_date": {
                  "docs": "If provided, only Logs created after the specified date will be returned.",
                  "type": "optional<datetime>",
                },
                "version_id": {
                  "docs": "If provided, only Logs belonging to the specified Version will be returned.",
                  "type": "optional<string>",
                },
                "version_status": {
                  "docs": "If provided, only Logs belonging to Versions with the specified status will be returned.",
                  "type": "optional<root.VersionStatus>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PaginatedDataPromptLogResponse",
            },
          },
        },
      },
    },
    "prompts.yml": {
      "docs": "Prompts define how a large language model behaves.

#### What is a Prompt?

A Prompt on Humanloop encapsulates the instructions and other configuration for how a large language model should
perform a specific task.

Prompts have immutable versions that you can **Commit** and **Deploy**.
To use a Prompt, you can **Call** it to create a generation and you can **Log** generations manually.

#### Referencing a Prompt version

You can perform actions on a specific Prompt version by specifying either the \`version_id\`
or \`environment\` query parameter in the request. If you provide a \`version_id\`, Humanloop will
use the specified version of the Prompt. If you provide an \`environment\`, Humanloop will use the
version of the Prompt that is currently deployed to that Environment.
If you do not provide either a \`version_id\` or \`environment\`, Humanloop will use the Prompt version
that is deployed to the default Environment.

",
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "display-name": "Prompts",
        "endpoints": {
          "call": {
            "auth": true,
            "display-name": "Call",
            "docs": "Call a Prompt.

Calling a Prompt subsequently calls the model provider before logging
the data to Humanloop.

You can use query parameters version_id, or environment, to target
an existing version of the Prompt. Otherwise the default deployed version will be chosen.

Instead of targeting an existing version explicitly, you can instead pass in
Prompt details in the request body. In this case, we will check if the details correspond
to an existing version of the Prompt, if not we will create a new version. This is helpful
in the case where you are storing or deriving your Prompt details in code.",
            "errors": [
              "root.PromptsCallRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {},
                "response": {
                  "body": {
                    "batches": [
                      "batches",
                    ],
                    "environment": "environment",
                    "id": "id",
                    "inputs": {
                      "key": "value",
                    },
                    "logs": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "error": "error",
                        "finish_reason": "finish_reason",
                        "index": 1,
                        "output": "output",
                        "output_cost": 1.1,
                        "output_message": {
                          "role": "user",
                        },
                        "output_tokens": 1,
                        "prompt_cost": 1.1,
                        "prompt_tokens": 1,
                        "provider_latency": 1.1,
                        "raw_output": "raw_output",
                      },
                    ],
                    "messages": [
                      {
                        "content": "content",
                        "name": "name",
                        "role": "user",
                        "tool_call_id": "tool_call_id",
                        "tool_calls": [
                          {
                            "function": {
                              "name": "name",
                            },
                            "id": "id",
                            "type": "function",
                          },
                        ],
                      },
                    ],
                    "metadata": {
                      "key": "value",
                    },
                    "parent_id": "parent_id",
                    "prompt": {
                      "commit_message": "commit_message",
                      "created_at": "2024-01-15T09:30:00Z",
                      "created_by": {
                        "email_address": "email_address",
                        "full_name": "full_name",
                        "id": "id",
                      },
                      "directory_id": "directory_id",
                      "endpoint": "complete",
                      "environments": [
                        {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "name": "name",
                          "tag": "default",
                        },
                      ],
                      "frequency_penalty": 1.1,
                      "id": "id",
                      "inputs": [
                        {
                          "name": "name",
                        },
                      ],
                      "last_used_at": "2024-01-15T09:30:00Z",
                      "linked_tools": [
                        {
                          "description": "description",
                          "id": "id",
                          "name": "name",
                          "version_id": "version_id",
                        },
                      ],
                      "max_tokens": 1,
                      "model": "model",
                      "name": "name",
                      "other": {
                        "key": "value",
                      },
                      "presence_penalty": 1.1,
                      "provider": "openai",
                      "response_format": {
                        "type": "json_object",
                      },
                      "seed": 1,
                      "status": "uncommitted",
                      "stop": "stop",
                      "temperature": 1.1,
                      "template": "template",
                      "tools": [
                        {
                          "description": "description",
                          "name": "name",
                        },
                      ],
                      "top_p": 1.1,
                      "total_logs_count": 1,
                      "updated_at": "2024-01-15T09:30:00Z",
                      "version_id": "version_id",
                      "version_logs_count": 1,
                    },
                    "save": true,
                    "session_id": "session_id",
                    "source": "source",
                    "source_datapoint_id": "source_datapoint_id",
                    "tool_choice": "none",
                    "user": "user",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/prompts/{id}/call",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "batches": {
                    "docs": "Array of Batch Ids that this log is part of. Batches are used to group Logs together for offline Evaluations",
                    "type": "optional<list<string>>",
                  },
                  "environment": {
                    "docs": "The name of the Environment the Log is associated to.",
                    "name": "promptCallRequestEnvironment",
                    "type": "optional<string>",
                  },
                  "inputs": {
                    "docs": "The inputs passed to the prompt template.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "logprobs": {
                    "docs": "Include the log probabilities of the top n tokens in the provider_response",
                    "type": "optional<integer>",
                  },
                  "messages": {
                    "docs": "The messages passed to the to provider chat endpoint.",
                    "type": "optional<list<root.ChatMessage>>",
                  },
                  "metadata": {
                    "docs": "Any additional metadata to record.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "num_samples": {
                    "default": 1,
                    "docs": "The number of generations.",
                    "type": "optional<integer>",
                  },
                  "parent_id": {
                    "docs": "Unique identifier for the parent Log in a Session. Should only be provided if \`session_id\` is provided. If provided, the Log will be nested under the parent Log within the Session.",
                    "type": "optional<string>",
                  },
                  "prompt": {
                    "docs": "Details of your Prompt. A new Prompt version will be created if the provided details are new.",
                    "type": "optional<root.PromptKernelRequest>",
                  },
                  "provider_api_keys": {
                    "docs": "API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization.",
                    "type": "optional<root.ProviderApiKeys>",
                  },
                  "return_inputs": {
                    "default": true,
                    "docs": "Whether to return the inputs in the response. If false, the response will contain an empty dictionary under inputs. This is useful for reducing the size of the response. Defaults to true.",
                    "type": "optional<boolean>",
                  },
                  "save": {
                    "default": true,
                    "docs": "Whether the request/response payloads will be stored on Humanloop.",
                    "type": "optional<boolean>",
                  },
                  "session_id": {
                    "docs": "Unique identifier for the Session to associate the Log to. Allows you to record multiple Logs to a Session (using an ID kept by your internal systems) by passing the same \`session_id\` in subsequent log requests. ",
                    "type": "optional<string>",
                  },
                  "source": {
                    "docs": "Identifies where the model was called from.",
                    "type": "optional<string>",
                  },
                  "source_datapoint_id": {
                    "docs": "Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.",
                    "type": "optional<string>",
                  },
                  "stream": {
                    "default": false,
                    "docs": "If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.",
                    "type": "optional<boolean>",
                  },
                  "suffix": {
                    "docs": "The suffix that comes after a completion of inserted text. Useful for completions that act like inserts.",
                    "type": "optional<string>",
                  },
                  "tool_choice": {
                    "docs": "Controls how the model uses tools. The following options are supported: 
- \`'none'\` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt. 
- \`'auto'\` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt. 
- \`'required'\` means the model can decide to call one or more of the provided tools. 
- \`{'type': 'function', 'function': {name': <TOOL_NAME>}}\` forces the model to use the named function.",
                    "type": "optional<PromptCallRequestToolChoice>",
                  },
                  "user": {
                    "docs": "End-user ID related to the Log.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "PromptCallRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag of the deployed version to log to.",
                  "type": "optional<string>",
                },
                "version_id": {
                  "docs": "A specific version Id of the Prompt to log to.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "PromptsCallResponse",
            },
          },
          "commit": {
            "auth": true,
            "display-name": "Commit",
            "docs": "Commit the Prompt Version with the given ID.",
            "errors": [
              "root.PromptsCommitRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                  "version_id": "version_id",
                },
                "request": {
                  "commit_message": "commit_message",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "endpoint": "complete",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "frequency_penalty": 1.1,
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "linked_tools": [
                      {
                        "description": "description",
                        "id": "id",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                        "version_id": "version_id",
                      },
                    ],
                    "max_tokens": 1,
                    "model": "model",
                    "name": "name",
                    "other": {
                      "key": "value",
                    },
                    "presence_penalty": 1.1,
                    "provider": "openai",
                    "response_format": {
                      "type": "json_object",
                    },
                    "seed": 1,
                    "status": "uncommitted",
                    "stop": "stop",
                    "temperature": 1.1,
                    "template": "template",
                    "tools": [
                      {
                        "description": "description",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                      },
                    ],
                    "top_p": 1.1,
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/prompts/{id}/versions/{version_id}/commit",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
              "version_id": {
                "docs": "Unique identifier for the specific version of the Prompt.",
                "type": "string",
              },
            },
            "request": {
              "body": "root.CommitRequest",
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PromptResponse",
            },
          },
          "create": {
            "auth": true,
            "display-name": "Create Prompt",
            "docs": "Create a Prompt.

When you call this endpoint with the same Prompt name but different parameters,
a new version of the Prompt will be created.

If you provide a commit message, then the new version will be committed;
otherwise it will be uncommitted. If you try to commit an already committed version,
an exception will be raised.",
            "errors": [
              "root.PromptsCreateRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "request": {
                  "model": "model",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "endpoint": "complete",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "frequency_penalty": 1.1,
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "linked_tools": [
                      {
                        "description": "description",
                        "id": "id",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                        "version_id": "version_id",
                      },
                    ],
                    "max_tokens": 1,
                    "model": "model",
                    "name": "name",
                    "other": {
                      "key": "value",
                    },
                    "presence_penalty": 1.1,
                    "provider": "openai",
                    "response_format": {
                      "type": "json_object",
                    },
                    "seed": 1,
                    "status": "uncommitted",
                    "stop": "stop",
                    "temperature": 1.1,
                    "template": "template",
                    "tools": [
                      {
                        "description": "description",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                      },
                    ],
                    "top_p": 1.1,
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/prompts",
            "request": {
              "body": {
                "properties": {
                  "commit_message": {
                    "docs": "Message describing the changes made.",
                    "type": "optional<string>",
                  },
                  "directory_id": {
                    "docs": "Unique identifier for the Directory of the Prompt. ",
                    "type": "optional<string>",
                  },
                  "endpoint": {
                    "docs": "The provider model endpoint used.",
                    "type": "optional<root.ModelEndpoints>",
                  },
                  "frequency_penalty": {
                    "default": 0,
                    "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
                    "type": "optional<double>",
                  },
                  "linked_tools": {
                    "docs": "The IDs of the Tools in your organization that the model can choose to call if Tool calling is supported. The default deployed version of that tool is called.",
                    "type": "optional<list<string>>",
                  },
                  "max_tokens": {
                    "default": -1,
                    "docs": "The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt",
                    "type": "optional<integer>",
                  },
                  "model": {
                    "docs": "The model instance used, e.g. \`gpt-4\`. See [supported models](https://humanloop.com/docs/supported-models)",
                    "type": "string",
                  },
                  "name": {
                    "docs": "Name of the Prompt, which is used as a unique identifier.",
                    "type": "optional<string>",
                  },
                  "other": {
                    "docs": "Other parameter values to be passed to the provider call.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "presence_penalty": {
                    "default": 0,
                    "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
                    "type": "optional<double>",
                  },
                  "provider": {
                    "docs": "The company providing the underlying model service.",
                    "type": "optional<root.ModelProviders>",
                  },
                  "response_format": {
                    "docs": "The format of the response. Only \`{"type": "json_object"}\` is currently supported for chat.",
                    "type": "optional<root.ResponseFormat>",
                  },
                  "seed": {
                    "docs": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed.",
                    "type": "optional<integer>",
                  },
                  "stop": {
                    "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
                    "type": "optional<PromptRequestStop>",
                  },
                  "temperature": {
                    "default": 1,
                    "docs": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
                    "type": "optional<double>",
                  },
                  "template": {
                    "docs": "For chat endpoint, provide a Chat template. For completion endpoint, provide a Prompt template. Input variables within the template should be specified with double curly bracket syntax: {{INPUT_NAME}}.",
                    "type": "optional<Template>",
                  },
                  "tools": {
                    "docs": "The tool specification that the model can choose to call if Tool calling is supported.",
                    "type": "optional<list<root.ToolFunction>>",
                  },
                  "top_p": {
                    "default": 1,
                    "docs": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
                    "type": "optional<double>",
                  },
                },
              },
              "headers": undefined,
              "name": "PromptRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PromptResponse",
            },
          },
          "delete": {
            "auth": true,
            "display-name": "Delete Prompt",
            "docs": "Delete the Prompt with the given ID.",
            "errors": [
              "root.PromptsDeleteRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
              },
            ],
            "method": "DELETE",
            "pagination": undefined,
            "path": "/prompts/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
            },
          },
          "deploy": {
            "auth": true,
            "display-name": "Deploy",
            "docs": "Deploy Prompt to Environment.

Set the deployed Version for the specified Environment. This Prompt Version
will be used for calls made to the Prompt in this Environment.",
            "errors": [
              "root.DeployPromptsIdVersionsVersionIdDeployPostRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                  "version_id": "version_id",
                },
                "query-parameters": {
                  "environment_id": "environment_id",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "endpoint": "complete",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "frequency_penalty": 1.1,
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "linked_tools": [
                      {
                        "description": "description",
                        "id": "id",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                        "version_id": "version_id",
                      },
                    ],
                    "max_tokens": 1,
                    "model": "model",
                    "name": "name",
                    "other": {
                      "key": "value",
                    },
                    "presence_penalty": 1.1,
                    "provider": "openai",
                    "response_format": {
                      "type": "json_object",
                    },
                    "seed": 1,
                    "status": "uncommitted",
                    "stop": "stop",
                    "temperature": 1.1,
                    "template": "template",
                    "tools": [
                      {
                        "description": "description",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                      },
                    ],
                    "top_p": 1.1,
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/prompts/{id}/versions/{version_id}/deploy",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
              "version_id": {
                "docs": "Unique identifier for the specific version of the Prompt.",
                "type": "string",
              },
            },
            "request": {
              "name": "DeployPromptsIdVersionsVersionIdDeployPostRequest",
              "query-parameters": {
                "environment_id": {
                  "docs": "Unique identifier for the Environment to deploy the Version to.",
                  "type": "string",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PromptResponse",
            },
          },
          "get": {
            "auth": true,
            "display-name": "Get Prompt",
            "docs": "Retrieve the Prompt with the given ID.

By default the deployed version of the Prompt is returned. Use the query parameters
\`version_id\` or \`environment\` to target a specific version of the Prompt.",
            "errors": [
              "root.PromptsGetRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "endpoint": "complete",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "frequency_penalty": 1.1,
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "linked_tools": [
                      {
                        "description": "description",
                        "id": "id",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                        "version_id": "version_id",
                      },
                    ],
                    "max_tokens": 1,
                    "model": "model",
                    "name": "name",
                    "other": {
                      "key": "value",
                    },
                    "presence_penalty": 1.1,
                    "provider": "openai",
                    "response_format": {
                      "type": "json_object",
                    },
                    "seed": 1,
                    "status": "uncommitted",
                    "stop": "stop",
                    "temperature": 1.1,
                    "template": "template",
                    "tools": [
                      {
                        "description": "description",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                      },
                    ],
                    "top_p": 1.1,
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/prompts/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
            },
            "request": {
              "name": "PromptsGetRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag to retrieve a deployed Version from.",
                  "type": "optional<string>",
                },
                "version_id": {
                  "docs": "A specific Version Id  of the Prompt to retrieve.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PromptResponse",
            },
          },
          "list": {
            "auth": true,
            "display-name": "List ",
            "docs": "Get a list of Prompts.",
            "errors": [
              "root.PromptsListRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "response": {
                  "body": {
                    "records": [
                      {
                        "commit_message": "commit_message",
                        "created_at": "2024-01-15T09:30:00Z",
                        "created_by": {
                          "email_address": "email_address",
                          "id": "id",
                        },
                        "directory_id": "directory_id",
                        "endpoint": "complete",
                        "environments": [
                          {
                            "created_at": "2024-01-15T09:30:00Z",
                            "id": "id",
                            "name": "name",
                            "tag": "default",
                          },
                        ],
                        "frequency_penalty": 1.1,
                        "id": "id",
                        "inputs": [
                          {
                            "name": "name",
                          },
                        ],
                        "last_used_at": "2024-01-15T09:30:00Z",
                        "linked_tools": [
                          {
                            "description": "description",
                            "id": "id",
                            "name": "name",
                            "version_id": "version_id",
                          },
                        ],
                        "max_tokens": 1,
                        "model": "model",
                        "name": "name",
                        "other": {
                          "key": "value",
                        },
                        "presence_penalty": 1.1,
                        "provider": "openai",
                        "response_format": {
                          "type": "json_object",
                        },
                        "seed": 1,
                        "status": "uncommitted",
                        "stop": "stop",
                        "temperature": 1.1,
                        "template": "template",
                        "tools": [
                          {
                            "description": "description",
                            "name": "name",
                          },
                        ],
                        "top_p": 1.1,
                        "total_logs_count": 1,
                        "updated_at": "2024-01-15T09:30:00Z",
                        "version_id": "version_id",
                        "version_logs_count": 1,
                      },
                    ],
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/prompts",
            "request": {
              "name": "PromptsListRequest",
              "query-parameters": {
                "name": {
                  "docs": "Case-insensitive filter for Prompt name.",
                  "type": "optional<string>",
                },
                "order": {
                  "docs": "Direction to sort by.",
                  "type": "optional<root.SortOrder>",
                },
                "page": {
                  "docs": "Page number for pagination.",
                  "type": "optional<integer>",
                },
                "size": {
                  "docs": "Page size for pagination. Number of Prompts to fetch.",
                  "type": "optional<integer>",
                },
                "sort_by": {
                  "docs": "Field to sort Prompts by",
                  "type": "optional<root.ProjectSortBy>",
                },
                "user_filter": {
                  "docs": "Case-insensitive filter for users in the Prompt. This filter matches against both email address and name of users.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ListPrompts",
            },
          },
          "listversions": {
            "auth": true,
            "display-name": "List Versions",
            "docs": "Get a list of all the versions of a Prompt.",
            "errors": [
              "root.PromptsListVersionsRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "records": [
                      {
                        "commit_message": "commit_message",
                        "created_at": "2024-01-15T09:30:00Z",
                        "created_by": {
                          "email_address": "email_address",
                          "id": "id",
                        },
                        "directory_id": "directory_id",
                        "endpoint": "complete",
                        "environments": [
                          {
                            "created_at": "2024-01-15T09:30:00Z",
                            "id": "id",
                            "name": "name",
                            "tag": "default",
                          },
                        ],
                        "frequency_penalty": 1.1,
                        "id": "id",
                        "inputs": [
                          {
                            "name": "name",
                          },
                        ],
                        "last_used_at": "2024-01-15T09:30:00Z",
                        "linked_tools": [
                          {
                            "description": "description",
                            "id": "id",
                            "name": "name",
                            "version_id": "version_id",
                          },
                        ],
                        "max_tokens": 1,
                        "model": "model",
                        "name": "name",
                        "other": {
                          "key": "value",
                        },
                        "presence_penalty": 1.1,
                        "provider": "openai",
                        "response_format": {
                          "type": "json_object",
                        },
                        "seed": 1,
                        "status": "uncommitted",
                        "stop": "stop",
                        "temperature": 1.1,
                        "template": "template",
                        "tools": [
                          {
                            "description": "description",
                            "name": "name",
                          },
                        ],
                        "top_p": 1.1,
                        "total_logs_count": 1,
                        "updated_at": "2024-01-15T09:30:00Z",
                        "version_id": "version_id",
                        "version_logs_count": 1,
                      },
                    ],
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/prompts/{id}/versions",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
            },
            "request": {
              "name": "PromptsListVersionsRequest",
              "query-parameters": {
                "environment": {
                  "docs": "Filter versions by environment tag. If no environment is provided, all versions are returned.",
                  "type": "optional<string>",
                },
                "evaluation_aggregates": "optional<boolean>",
                "status": {
                  "docs": "Filter versions by status: 'uncommitted', 'committed'. If no status is provided, all versions are returned.",
                  "type": "optional<root.VersionStatus>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ListPrompts",
            },
          },
          "log": {
            "auth": true,
            "display-name": "Log",
            "docs": "Log to a Prompt.

You can use query parameters version_id, or environment, to target
an existing version of the Prompt. Otherwise the default deployed version will be chosen.

Instead of targeting an existing version explicitly, you can instead pass in
Prompt details in the request body. In this case, we will check if the details correspond
to an existing version of the Prompt, if not we will create a new version. This is helpful
in the case where you are storing or deriving your Prompt details in code.",
            "errors": [
              "root.PromptsLogRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {},
                "response": {
                  "body": {
                    "id": "id",
                    "prompt_id": "prompt_id",
                    "session_id": "session_id",
                    "version_id": "version_id",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/prompts/{id}/log",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "batches": {
                    "docs": "Array of Batch Ids that this log is part of. Batches are used to group Logs together for offline Evaluations",
                    "type": "optional<list<string>>",
                  },
                  "created_at": {
                    "docs": "User defined timestamp for when the log was created. ",
                    "type": "optional<datetime>",
                  },
                  "environment": {
                    "docs": "The name of the Environment the Log is associated to.",
                    "name": "promptLogRequestEnvironment",
                    "type": "optional<string>",
                  },
                  "error": {
                    "docs": "Error message if the log is an error.",
                    "type": "optional<string>",
                  },
                  "finish_reason": {
                    "docs": "Reason the generation finished.",
                    "type": "optional<string>",
                  },
                  "inputs": {
                    "docs": "The inputs passed to the prompt template.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "messages": {
                    "docs": "The messages passed to the to provider chat endpoint.",
                    "type": "optional<list<root.ChatMessage>>",
                  },
                  "metadata": {
                    "docs": "Any additional metadata to record.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "output": {
                    "docs": "Generated output from your model for the provided inputs. Can be \`None\` if logging an error, or if creating a parent Log with the intention to populate it later.",
                    "type": "optional<string>",
                  },
                  "output_cost": {
                    "docs": "Cost in dollars associated to the tokens in the output.",
                    "type": "optional<double>",
                  },
                  "output_message": {
                    "docs": "The message returned by the provider.",
                    "type": "optional<root.ChatMessage>",
                  },
                  "output_tokens": {
                    "docs": "Number of tokens in the output generated by the model.",
                    "type": "optional<integer>",
                  },
                  "parent_id": {
                    "docs": "Unique identifier for the parent Log in a Session. Should only be provided if \`session_id\` is provided. If provided, the Log will be nested under the parent Log within the Session.",
                    "type": "optional<string>",
                  },
                  "prompt": {
                    "docs": "Details of your Prompt. A new Prompt version will be created if the provided details are new.",
                    "type": "optional<root.PromptKernelRequest>",
                  },
                  "prompt_cost": {
                    "docs": "Cost in dollars associated to the tokens in the prompt.",
                    "type": "optional<double>",
                  },
                  "prompt_tokens": {
                    "docs": "Number of tokens in the prompt used to generate the output.",
                    "type": "optional<integer>",
                  },
                  "provider_latency": {
                    "docs": "Duration of the logged event in seconds.",
                    "type": "optional<double>",
                  },
                  "provider_request": {
                    "docs": "Raw request sent to provider.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "provider_response": {
                    "docs": "Raw response received the provider.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "raw_output": {
                    "docs": "Raw output from the provider.",
                    "type": "optional<string>",
                  },
                  "save": {
                    "default": true,
                    "docs": "Whether the request/response payloads will be stored on Humanloop.",
                    "type": "optional<boolean>",
                  },
                  "session_id": {
                    "docs": "Unique identifier for the Session to associate the Log to. Allows you to record multiple Logs to a Session (using an ID kept by your internal systems) by passing the same \`session_id\` in subsequent log requests. ",
                    "type": "optional<string>",
                  },
                  "source": {
                    "docs": "Identifies where the model was called from.",
                    "type": "optional<string>",
                  },
                  "source_datapoint_id": {
                    "docs": "Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.",
                    "type": "optional<string>",
                  },
                  "tool_choice": {
                    "docs": "Controls how the model uses tools. The following options are supported: 
- \`'none'\` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt. 
- \`'auto'\` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt. 
- \`'required'\` means the model can decide to call one or more of the provided tools. 
- \`{'type': 'function', 'function': {name': <TOOL_NAME>}}\` forces the model to use the named function.",
                    "type": "optional<PromptLogRequestToolChoice>",
                  },
                  "user": {
                    "docs": "End-user ID related to the Log.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "PromptLogRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag of the deployed version to log to.",
                  "type": "optional<string>",
                },
                "version_id": {
                  "docs": "A specific version Id of the Prompt to log to.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.CreatePromptLogResponse",
            },
          },
          "update": {
            "auth": true,
            "display-name": "Update Prompt",
            "docs": "Update the Prompt with the given ID.",
            "errors": [
              "root.PromptsUpdateRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {},
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "endpoint": "complete",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "frequency_penalty": 1.1,
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "linked_tools": [
                      {
                        "description": "description",
                        "id": "id",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                        "version_id": "version_id",
                      },
                    ],
                    "max_tokens": 1,
                    "model": "model",
                    "name": "name",
                    "other": {
                      "key": "value",
                    },
                    "presence_penalty": 1.1,
                    "provider": "openai",
                    "response_format": {
                      "type": "json_object",
                    },
                    "seed": 1,
                    "status": "uncommitted",
                    "stop": "stop",
                    "temperature": 1.1,
                    "template": "template",
                    "tools": [
                      {
                        "description": "description",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                      },
                    ],
                    "top_p": 1.1,
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "PATCH",
            "pagination": undefined,
            "path": "/prompts/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "directory_id": {
                    "docs": "Unique identifier for the Directory of the Prompt. ",
                    "type": "optional<string>",
                  },
                  "name": {
                    "docs": "Name of the Prompt, which is used as a unique identifier.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "UpdatePromptRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PromptResponse",
            },
          },
          "updateEvaluators": {
            "auth": true,
            "display-name": "Update Evaluators",
            "docs": "Activate and deactivate Evaluators for the Prompt.

An activated Evaluator will automatically be run on all new Logs
within the Prompt for monitoring purposes.",
            "errors": [
              "root.UpdateEvaluatorsPromptsIdEvaluatorsPostRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {},
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "endpoint": "complete",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "frequency_penalty": 1.1,
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "linked_tools": [
                      {
                        "description": "description",
                        "id": "id",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                        "version_id": "version_id",
                      },
                    ],
                    "max_tokens": 1,
                    "model": "model",
                    "name": "name",
                    "other": {
                      "key": "value",
                    },
                    "presence_penalty": 1.1,
                    "provider": "openai",
                    "response_format": {
                      "type": "json_object",
                    },
                    "seed": 1,
                    "status": "uncommitted",
                    "stop": "stop",
                    "temperature": 1.1,
                    "template": "template",
                    "tools": [
                      {
                        "description": "description",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                      },
                    ],
                    "top_p": 1.1,
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/prompts/{id}/evaluators",
            "path-parameters": {
              "id": "string",
            },
            "request": {
              "body": "root.EvaluatorActivationDeactivationRequest",
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PromptResponse",
            },
          },
        },
      },
      "types": {
        "PromptCallRequestToolChoice": {
          "discriminated": false,
          "docs": "Controls how the model uses tools. The following options are supported: 
- \`'none'\` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt. 
- \`'auto'\` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt. 
- \`'required'\` means the model can decide to call one or more of the provided tools. 
- \`{'type': 'function', 'function': {name': <TOOL_NAME>}}\` forces the model to use the named function.",
          "union": [
            "literal<"none">",
            "literal<"auto">",
            "literal<"required">",
            "root.ToolChoice",
          ],
        },
        "PromptLogRequestToolChoice": {
          "discriminated": false,
          "docs": "Controls how the model uses tools. The following options are supported: 
- \`'none'\` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt. 
- \`'auto'\` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt. 
- \`'required'\` means the model can decide to call one or more of the provided tools. 
- \`{'type': 'function', 'function': {name': <TOOL_NAME>}}\` forces the model to use the named function.",
          "union": [
            "literal<"none">",
            "literal<"auto">",
            "literal<"required">",
            "root.ToolChoice",
          ],
        },
        "PromptRequestStop": {
          "discriminated": false,
          "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
          "union": [
            "string",
            "list<string>",
          ],
        },
        "PromptsCallResponse": {
          "discriminated": false,
          "docs": undefined,
          "union": [
            "root.PromptCallResponse",
            "root.PromptCallStreamResponse",
          ],
        },
        "Template": {
          "discriminated": false,
          "docs": "For chat endpoint, provide a Chat template. For completion endpoint, provide a Prompt template. Input variables within the template should be specified with double curly bracket syntax: {{INPUT_NAME}}.",
          "union": [
            "string",
            "list<root.ChatMessage>",
          ],
        },
      },
    },
    "sessions.yml": {
      "docs": "Sessions are groups of Logs that track sequences of LLM actions.

Sessions enable you to trace through related Logs across different Files. For
example, a Session can contain a Prompt Log recording an LLM generation, a Tool
Log recording a retrieval step, and Evaluator Logs measuring the quality of the
generated text.

Logs within a Session may be nested within each other. When Evaluators are run
for monitoring, the Evaluator Logs are added to the Session that the evaluated
Log is in, nested within the evaluated Log.

",
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "display-name": "Sessions",
        "endpoints": {
          "delete": {
            "auth": true,
            "display-name": "Delete",
            "docs": "Delete the Session with the given ID.",
            "errors": [
              "root.SessionsDeleteRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
              },
            ],
            "method": "DELETE",
            "pagination": undefined,
            "path": "/sessions/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Session.",
                "type": "string",
              },
            },
          },
          "get": {
            "auth": true,
            "display-name": "Get",
            "docs": "Retrieve the Session with the given ID.",
            "errors": [
              "root.SessionsGetRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "created_at": "2024-01-15T09:30:00Z",
                    "id": "id",
                    "logs": [
                      {
                        "batches": [
                          "batches",
                        ],
                        "created_at": "2024-01-15T09:30:00Z",
                        "environment": "environment",
                        "error": "error",
                        "finish_reason": "finish_reason",
                        "id": "id",
                        "inputs": {
                          "key": "value",
                        },
                        "messages": [
                          {
                            "role": "user",
                          },
                        ],
                        "metadata": {
                          "key": "value",
                        },
                        "output": "output",
                        "output_cost": 1.1,
                        "output_message": {
                          "role": "user",
                        },
                        "output_tokens": 1,
                        "parent_id": "parent_id",
                        "prompt": {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "inputs": [
                            {
                              "name": "name",
                            },
                          ],
                          "last_used_at": "2024-01-15T09:30:00Z",
                          "model": "model",
                          "name": "name",
                          "status": "uncommitted",
                          "total_logs_count": 1,
                          "updated_at": "2024-01-15T09:30:00Z",
                          "version_id": "version_id",
                          "version_logs_count": 1,
                        },
                        "prompt_cost": 1.1,
                        "prompt_tokens": 1,
                        "provider_latency": 1.1,
                        "provider_request": {
                          "key": "value",
                        },
                        "provider_response": {
                          "key": "value",
                        },
                        "raw_output": "raw_output",
                        "save": true,
                        "session_id": "session_id",
                        "source": "source",
                        "source_datapoint_id": "source_datapoint_id",
                        "tool_choice": "none",
                        "user": "user",
                      },
                    ],
                    "updated_at": "2024-01-15T09:30:00Z",
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/sessions/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Session.",
                "type": "string",
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.SessionResponse",
            },
          },
          "list": {
            "auth": true,
            "display-name": "List ",
            "docs": "Get a list of Sessions.",
            "errors": [
              "root.SessionsListRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "response": {
                  "body": {
                    "page": 1,
                    "records": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "logs": [
                          {
                            "id": "id",
                            "prompt": {
                              "created_at": "2024-01-15T09:30:00Z",
                              "id": "id",
                              "inputs": [
                                {
                                  "name": "name",
                                },
                              ],
                              "last_used_at": "2024-01-15T09:30:00Z",
                              "model": "model",
                              "name": "name",
                              "status": "uncommitted",
                              "total_logs_count": 1,
                              "updated_at": "2024-01-15T09:30:00Z",
                              "version_id": "version_id",
                              "version_logs_count": 1,
                            },
                          },
                        ],
                        "updated_at": "2024-01-15T09:30:00Z",
                      },
                    ],
                    "size": 1,
                    "total": 1,
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/sessions",
            "request": {
              "name": "SessionsListRequest",
              "query-parameters": {
                "file_id": {
                  "docs": "Unique identifier for File to return Sessions for. Sessions that contain any Logs associated to this File will be returned.",
                  "type": "optional<string>",
                },
                "page": {
                  "docs": "Page number for pagination.",
                  "type": "optional<integer>",
                },
                "size": {
                  "docs": "Page size for pagination. Number of Sessions to fetch.",
                  "type": "optional<integer>",
                },
                "version_id": {
                  "docs": "Unique identifier for Version to return Sessions for. Sessions that contain any Logs associated to this Version will be returned.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PaginatedDataSessionResponse",
            },
          },
        },
      },
    },
    "tools.yml": {
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "endpoints": {
          "commit": {
            "auth": true,
            "display-name": "Commit",
            "docs": "Commit the Tool Version with the given ID.",
            "errors": [
              "root.ToolsCommitRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                  "version_id": "version_id",
                },
                "request": {
                  "commit_message": "commit_message",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "function": {
                      "description": "description",
                      "name": "name",
                      "parameters": {
                        "key": "value",
                      },
                    },
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "setup_values": {
                      "key": "value",
                    },
                    "signature": "signature",
                    "source_code": "source_code",
                    "status": "uncommitted",
                    "tool_type": "pinecone_search",
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/tools/{id}/versions/{version_id}/commit",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Tool.",
                "type": "string",
              },
              "version_id": {
                "docs": "Unique identifier for the specific version of the Tool.",
                "type": "string",
              },
            },
            "request": {
              "body": "root.CommitRequest",
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ToolResponse",
            },
          },
          "create": {
            "auth": true,
            "display-name": "Create Tool",
            "docs": "Create a Tool.

Tools have immutable versions. When you call this endpoint
with the same Tool name but different parameters, a new version of
the Tool will be created.

If you provide a commit message, then the new version will be committed;
otherwise it will be uncommitted. If you try to commit an already committed version,
an exception will be raised.",
            "errors": [
              "root.ToolsCreateRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "request": {},
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "function": {
                      "description": "description",
                      "name": "name",
                      "parameters": {
                        "key": "value",
                      },
                    },
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "setup_values": {
                      "key": "value",
                    },
                    "signature": "signature",
                    "source_code": "source_code",
                    "status": "uncommitted",
                    "tool_type": "pinecone_search",
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/tools",
            "request": {
              "body": {
                "properties": {
                  "commit_message": {
                    "docs": "Message describing the changes made.",
                    "type": "optional<string>",
                  },
                  "directory_id": {
                    "docs": "Unique identifier for the Directory of the Prompt. ",
                    "type": "optional<string>",
                  },
                  "function": {
                    "docs": "Callable function specification of the Tool shown to the model for tool calling.",
                    "type": "optional<root.ToolFunction>",
                  },
                  "name": {
                    "docs": "Name of the Tool, which is used as a unique identifier.",
                    "type": "optional<string>",
                  },
                  "setup_values": {
                    "docs": "Values needed to setup the Tool, defined in JSON Schema format: https://json-schema.org/",
                    "type": "optional<map<string, unknown>>",
                  },
                  "source_code": {
                    "docs": "Code source of the Tool.",
                    "type": "optional<string>",
                  },
                  "tool_type": {
                    "docs": "Type of Tool.",
                    "type": "optional<root.ToolType>",
                  },
                },
              },
              "headers": undefined,
              "name": "ToolRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ToolResponse",
            },
          },
          "delete": {
            "auth": true,
            "display-name": "Delete Tool",
            "docs": "Delete the Tool with the given ID.",
            "errors": [
              "root.ToolsDeleteRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
              },
            ],
            "method": "DELETE",
            "pagination": undefined,
            "path": "/tools/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Tool.",
                "type": "string",
              },
            },
          },
          "deploy": {
            "auth": true,
            "display-name": "Deploy",
            "docs": "Deploy Tool to Environment.

Set the deployed Version for the specified Environment. This Tool Version
will be used for calls made to the Tool in this Environment.",
            "errors": [
              "root.DeployToolsIdVersionsVersionIdDeployPostRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                  "version_id": "version_id",
                },
                "query-parameters": {
                  "environment_id": "environment_id",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "function": {
                      "description": "description",
                      "name": "name",
                      "parameters": {
                        "key": "value",
                      },
                    },
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "setup_values": {
                      "key": "value",
                    },
                    "signature": "signature",
                    "source_code": "source_code",
                    "status": "uncommitted",
                    "tool_type": "pinecone_search",
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/tools/{id}/versions/{version_id}/deploy",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Tool.",
                "type": "string",
              },
              "version_id": {
                "docs": "Unique identifier for the specific version of the Tool.",
                "type": "string",
              },
            },
            "request": {
              "name": "DeployToolsIdVersionsVersionIdDeployPostRequest",
              "query-parameters": {
                "environment_id": {
                  "docs": "Unique identifier for the Environment to deploy the Version to.",
                  "type": "string",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ToolResponse",
            },
          },
          "get": {
            "auth": true,
            "display-name": "Get Tool",
            "docs": "Retrieve the Tool with the given ID.

By default the deployed version of the Tool is returned. Use the query parameters
\`version_id\` or \`environment\` to target a specific version of the Tool.",
            "errors": [
              "root.ToolsGetRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "function": {
                      "description": "description",
                      "name": "name",
                      "parameters": {
                        "key": "value",
                      },
                    },
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "setup_values": {
                      "key": "value",
                    },
                    "signature": "signature",
                    "source_code": "source_code",
                    "status": "uncommitted",
                    "tool_type": "pinecone_search",
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/tools/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Tool.",
                "type": "string",
              },
            },
            "request": {
              "name": "ToolsGetRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag to retrieve a deployed Version from.",
                  "type": "optional<string>",
                },
                "version_id": {
                  "docs": "A specific Version Id  of the Tool to retrieve.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ToolResponse",
            },
          },
          "list": {
            "auth": true,
            "display-name": "List ",
            "docs": "Get a list of Tools.",
            "errors": [
              "root.ToolsListRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "response": {
                  "body": {
                    "records": [
                      {
                        "commit_message": "commit_message",
                        "created_at": "2024-01-15T09:30:00Z",
                        "created_by": {
                          "email_address": "email_address",
                          "id": "id",
                        },
                        "directory_id": "directory_id",
                        "environments": [
                          {
                            "created_at": "2024-01-15T09:30:00Z",
                            "id": "id",
                            "name": "name",
                            "tag": "default",
                          },
                        ],
                        "function": {
                          "description": "description",
                          "name": "name",
                        },
                        "id": "id",
                        "inputs": [
                          {
                            "name": "name",
                          },
                        ],
                        "last_used_at": "2024-01-15T09:30:00Z",
                        "name": "name",
                        "setup_values": {
                          "key": "value",
                        },
                        "signature": "signature",
                        "source_code": "source_code",
                        "status": "uncommitted",
                        "tool_type": "pinecone_search",
                        "total_logs_count": 1,
                        "updated_at": "2024-01-15T09:30:00Z",
                        "version_id": "version_id",
                        "version_logs_count": 1,
                      },
                    ],
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/tools",
            "request": {
              "name": "ToolsListRequest",
              "query-parameters": {
                "name": {
                  "docs": "Case-insensitive filter for Tool name.",
                  "type": "optional<string>",
                },
                "order": {
                  "docs": "Direction to sort by.",
                  "type": "optional<root.SortOrder>",
                },
                "page": {
                  "docs": "Page offset for pagination.",
                  "type": "optional<integer>",
                },
                "size": {
                  "docs": "Page size for pagination. Number of Tools to fetch.",
                  "type": "optional<integer>",
                },
                "sort_by": {
                  "docs": "Field to sort Tools by",
                  "type": "optional<root.ProjectSortBy>",
                },
                "user_filter": {
                  "docs": "Case-insensitive filter for users in the Tool. This filter matches against both email address and name of users.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ListTools",
            },
          },
          "listTemplates": {
            "auth": true,
            "display-name": "List Templates",
            "docs": undefined,
            "errors": [
              "root.ListTemplatesToolsTemplatesGetRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "response": {
                  "body": [
                    {
                      "description": "description",
                      "name": "name",
                      "parameters": {
                        "key": "value",
                      },
                      "setup_schema": {
                        "key": "value",
                      },
                      "signature": "signature",
                    },
                  ],
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/tools/templates",
            "request": {
              "name": "ListTemplatesToolsTemplatesGetRequest",
              "query-parameters": {
                "tool_type": {
                  "docs": "Type of tool to return the template",
                  "type": "optional<root.ToolType>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "list<root.ToolTemplateResponse>",
            },
          },
          "listversions": {
            "auth": true,
            "display-name": "List Versions",
            "docs": "Get a list of all the versions of a Tool.",
            "errors": [
              "root.ToolsListVersionsRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "records": [
                      {
                        "commit_message": "commit_message",
                        "created_at": "2024-01-15T09:30:00Z",
                        "created_by": {
                          "email_address": "email_address",
                          "id": "id",
                        },
                        "directory_id": "directory_id",
                        "environments": [
                          {
                            "created_at": "2024-01-15T09:30:00Z",
                            "id": "id",
                            "name": "name",
                            "tag": "default",
                          },
                        ],
                        "function": {
                          "description": "description",
                          "name": "name",
                        },
                        "id": "id",
                        "inputs": [
                          {
                            "name": "name",
                          },
                        ],
                        "last_used_at": "2024-01-15T09:30:00Z",
                        "name": "name",
                        "setup_values": {
                          "key": "value",
                        },
                        "signature": "signature",
                        "source_code": "source_code",
                        "status": "uncommitted",
                        "tool_type": "pinecone_search",
                        "total_logs_count": 1,
                        "updated_at": "2024-01-15T09:30:00Z",
                        "version_id": "version_id",
                        "version_logs_count": 1,
                      },
                    ],
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/tools/{id}/versions",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for the Tool.",
                "type": "string",
              },
            },
            "request": {
              "name": "ToolsListVersionsRequest",
              "query-parameters": {
                "environment": {
                  "docs": "Filter versions by environment tag. If no environment is provided, all versions are returned.",
                  "type": "optional<string>",
                },
                "evaluation_aggregates": "optional<boolean>",
                "status": {
                  "docs": "Filter versions by status: 'uncommitted', 'committed'. If no status is provided, all versions are returned.",
                  "type": "optional<root.VersionStatus>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ListTools",
            },
          },
          "log": {
            "auth": true,
            "display-name": "Log",
            "docs": "Log to a Tool.

You can use query parameters version_id, or environment, to target
an existing version of the Tool. Otherwise the default deployed version will be chosen.

Instead of targeting an existing version explicitly, you can instead pass in
Tool details in the request body. In this case, we will check if the details correspond
to an existing version of the Tool, if not we will create a new version. This is helpful
in the case where you are storing or deriving your Tool details in code.",
            "errors": [
              "root.ToolsLogRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {},
                "response": {
                  "body": {
                    "id": "id",
                    "session_id": "session_id",
                    "tool_id": "tool_id",
                    "version_id": "version_id",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/tools/{id}/log",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Tool.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "batches": {
                    "docs": "Array of Batch Ids that this log is part of. Batches are used to group Logs together for offline Evaluations",
                    "type": "optional<list<string>>",
                  },
                  "created_at": {
                    "docs": "User defined timestamp for when the log was created. ",
                    "type": "optional<datetime>",
                  },
                  "environment": {
                    "docs": "The name of the Environment the Log is associated to.",
                    "name": "toolLogRequestEnvironment",
                    "type": "optional<string>",
                  },
                  "error": {
                    "docs": "Error message if the log is an error.",
                    "type": "optional<string>",
                  },
                  "inputs": {
                    "docs": "The inputs passed to the prompt template.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "metadata": {
                    "docs": "Any additional metadata to record.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "output": {
                    "docs": "Generated output from your model for the provided inputs. Can be \`None\` if logging an error, or if creating a parent Log with the intention to populate it later.",
                    "type": "optional<string>",
                  },
                  "parent_id": {
                    "docs": "Unique identifier for the parent Log in a Session. Should only be provided if \`session_id\` is provided. If provided, the Log will be nested under the parent Log within the Session.",
                    "type": "optional<string>",
                  },
                  "provider_latency": {
                    "docs": "Duration of the logged event in seconds.",
                    "type": "optional<double>",
                  },
                  "provider_request": {
                    "docs": "Raw request sent to provider.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "provider_response": {
                    "docs": "Raw response received the provider.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "raw_output": {
                    "docs": "Raw output from the provider.",
                    "type": "optional<string>",
                  },
                  "save": {
                    "default": true,
                    "docs": "Whether the request/response payloads will be stored on Humanloop.",
                    "type": "optional<boolean>",
                  },
                  "session_id": {
                    "docs": "Unique identifier for the Session to associate the Log to. Allows you to record multiple Logs to a Session (using an ID kept by your internal systems) by passing the same \`session_id\` in subsequent log requests. ",
                    "type": "optional<string>",
                  },
                  "source": {
                    "docs": "Identifies where the model was called from.",
                    "type": "optional<string>",
                  },
                  "source_datapoint_id": {
                    "docs": "Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.",
                    "type": "optional<string>",
                  },
                  "tool": {
                    "docs": "Details of your Tool. A new Tool version will be created if the provided details are new.",
                    "type": "optional<root.ToolKernelRequest>",
                  },
                  "user": {
                    "docs": "End-user ID related to the Log.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "ToolLogRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag of the deployed version to log to.",
                  "type": "optional<string>",
                },
                "version_id": {
                  "docs": "A specific version Id of the Tool to log to.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.CreateToolLogResponse",
            },
          },
          "update": {
            "auth": true,
            "display-name": "Update Tool",
            "docs": "Update the Tool with the given ID.",
            "errors": [
              "root.ToolsUpdateRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {},
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "function": {
                      "description": "description",
                      "name": "name",
                      "parameters": {
                        "key": "value",
                      },
                    },
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "setup_values": {
                      "key": "value",
                    },
                    "signature": "signature",
                    "source_code": "source_code",
                    "status": "uncommitted",
                    "tool_type": "pinecone_search",
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "PATCH",
            "pagination": undefined,
            "path": "/tools/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Tool.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "directory_id": {
                    "docs": "Unique identifier for the Directory of the Prompt. ",
                    "type": "optional<string>",
                  },
                  "name": {
                    "docs": "Name of the Tool, which is used as a unique identifier.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "UpdateToolRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ToolResponse",
            },
          },
          "updateEvaluators": {
            "auth": true,
            "display-name": "Update Evaluators",
            "docs": "Activate and deactivate Evaluators for the Tool.

An activated Evaluator will automatically be run on all new Logs
within the Tool for monitoring purposes.",
            "errors": [
              "root.UpdateEvaluatorsToolsIdEvaluatorsPostRequestUnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {},
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "function": {
                      "description": "description",
                      "name": "name",
                      "parameters": {
                        "key": "value",
                      },
                    },
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "setup_values": {
                      "key": "value",
                    },
                    "signature": "signature",
                    "source_code": "source_code",
                    "status": "uncommitted",
                    "tool_type": "pinecone_search",
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/tools/{id}/evaluators",
            "path-parameters": {
              "id": "string",
            },
            "request": {
              "body": "root.EvaluatorActivationDeactivationRequest",
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ToolResponse",
            },
          },
        },
      },
    },
  },
  "packageMarkerFile": {
    "errors": {
      "DatasetsCommitRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "DatasetsCreateRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "DatasetsDeleteRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "DatasetsGetRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "DatasetsListDatapointsRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "DatasetsListRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "DatasetsListVersionsRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "DatasetsUpdateRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "DebugEvaluatorsDebugPostRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "DeployDatasetsIdVersionsVersionIdDeployPostRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "DeployEvaluatorsIdVersionsVersionIdDeployPostRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "DeployPromptsIdVersionsVersionIdDeployPostRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "DeployToolsIdVersionsVersionIdDeployPostRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "EvaluationsCreateRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "EvaluationsDeleteRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "EvaluationsGetRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "EvaluationsGetStatsRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "EvaluationsListRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "EvaluationsUpdateRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "EvaluationsUpdateStatusRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "EvaluatorsCommitRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "EvaluatorsCreateRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "EvaluatorsDeleteRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "EvaluatorsGetRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "EvaluatorsListDefaultRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "EvaluatorsListRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "EvaluatorsListVersionsRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "EvaluatorsUpdateRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "ListLogsForFileLogsGetRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "ListTemplatesToolsTemplatesGetRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "LogsDeleteRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "LogsGetRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "PromptsCallRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "PromptsCommitRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "PromptsCreateRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "PromptsDeleteRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "PromptsGetRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "PromptsListRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "PromptsListVersionsRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "PromptsLogRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "PromptsUpdateRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "SessionsDeleteRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "SessionsGetRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "SessionsListRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "ToolsCommitRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "ToolsCreateRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "ToolsDeleteRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "ToolsGetRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "ToolsListRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "ToolsListVersionsRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "ToolsLogRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "ToolsUpdateRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "UpdateEvaluatorsPromptsIdEvaluatorsPostRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
      "UpdateEvaluatorsToolsIdEvaluatorsPostRequestUnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
    },
    "types": {
      "AgentConfigResponse": {
        "docs": undefined,
        "properties": {
          "agent_class": {
            "docs": "Class of the agent.",
            "type": "string",
          },
          "created_by": {
            "docs": "The user who created the config.",
            "type": "optional<UserResponse>",
          },
          "description": {
            "docs": "Description of config.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "String ID of config. Starts with \`config_\`.",
            "type": "string",
          },
          "model_config": {
            "docs": "Model config associated with the agent.",
            "type": "ModelConfigRequest",
          },
          "name": {
            "docs": "Name of config.",
            "type": "string",
          },
          "other": {
            "docs": "Other parameters that define the config.",
            "type": "optional<map<string, unknown>>",
          },
          "status": {
            "docs": "Whether the config is committed or not.",
            "type": "string",
          },
          "tools": {
            "docs": "Tools associated with the agent.",
            "type": "optional<list<ToolConfigRequest>>",
          },
        },
      },
      "BooleanEvaluatorVersionStats": {
        "docs": "Base attributes for stats for an Evaluator Version-Evaluated Version pair
in the Evaluation Report.",
        "properties": {
          "evaluator_version_id": {
            "docs": "Unique identifier for the Evaluator Version.",
            "type": "string",
          },
          "num_errors": {
            "docs": "The total number of errored Evaluators for this Evaluator Version.",
            "type": "integer",
          },
          "num_false": {
            "docs": "The total number of \`False\` judgments for this Evaluator Version.",
            "type": "integer",
          },
          "num_judgments": {
            "docs": "The total number of Evaluator judgments for this Evaluator Version. This excludes Nulls and Errors.",
            "type": "integer",
          },
          "num_nulls": {
            "docs": "The total number of null judgments (i.e. abstentions) for this Evaluator Version.",
            "type": "integer",
          },
          "num_true": {
            "docs": "The total number of \`True\` judgments for this Evaluator Version.",
            "type": "integer",
          },
          "total_logs": {
            "docs": "The total number of Logs generated by this Evaluator Version on the Evaluated Version's Logs. This includes Nulls and Errors.",
            "type": "integer",
          },
        },
      },
      "CategoricalFeedbackLabel": {
        "docs": undefined,
        "properties": {
          "sentiment": {
            "docs": "Whether the feedback sentiment is positive or negative.",
            "type": "LabelSentiment",
          },
          "status": {
            "docs": "Whether the feedback label is active or inactive.",
            "type": "FeedbackLabelStatus",
          },
          "value": "string",
        },
      },
      "ChatMessage": {
        "docs": undefined,
        "properties": {
          "content": {
            "docs": "The content of the message.",
            "type": "optional<Content>",
          },
          "name": {
            "docs": "Optional name of the message author.",
            "type": "optional<string>",
          },
          "role": {
            "docs": "Role of the message author.",
            "type": "ChatRole",
          },
          "tool_call_id": {
            "docs": "Tool call that this message is responding to.",
            "type": "optional<string>",
          },
          "tool_calls": {
            "docs": "A list of tool calls requested by the assistant.",
            "type": "optional<list<ToolCall>>",
          },
        },
      },
      "ChatMessageContentItem": {
        "base-properties": {},
        "discriminant": "type",
        "docs": undefined,
        "union": {
          "image_url": "ImageChatContent",
          "text": "TextChatContent",
        },
      },
      "ChatMessageWithToolCall": {
        "docs": undefined,
        "properties": {
          "content": {
            "docs": "The content of the message.",
            "type": "optional<Content>",
          },
          "name": {
            "docs": "Optional name of the message author.",
            "type": "optional<string>",
          },
          "role": {
            "docs": "Role of the message author.",
            "type": "ChatRole",
          },
          "tool_call": {
            "availability": "deprecated",
            "docs": "NB: Deprecated in favour of tool_calls. A tool call requested by the assistant.",
            "type": "optional<FunctionTool>",
          },
          "tool_call_id": {
            "docs": "Tool call that this message is responding to.",
            "type": "optional<string>",
          },
          "tool_calls": {
            "docs": "A list of tool calls requested by the assistant.",
            "type": "optional<list<ToolCall>>",
          },
        },
      },
      "ChatMessageWithToolCallContentItem": {
        "base-properties": {},
        "discriminant": "type",
        "docs": undefined,
        "union": {
          "image_url": "ImageChatContent",
          "text": "TextChatContent",
        },
      },
      "ChatRole": {
        "docs": "An enumeration.",
        "enum": [
          "user",
          "assistant",
          "system",
          "tool",
        ],
      },
      "CodeEvaluatorRequest": {
        "docs": undefined,
        "properties": {
          "arguments_type": {
            "docs": "Whether this evaluator is target-free or target-required.",
            "type": "EvaluatorArgumentsType",
          },
          "code": {
            "docs": "The code for the evaluator. This code will be executed in a sandboxed environment.",
            "type": "optional<string>",
          },
          "return_type": {
            "docs": "The type of the return value of the evaluator.",
            "type": "EvaluatorReturnTypeEnum",
          },
        },
      },
      "CommitRequest": {
        "docs": undefined,
        "properties": {
          "commit_message": {
            "docs": "Message describing the changes made.",
            "type": "string",
          },
        },
      },
      "ConfigResponse": {
        "base-properties": {},
        "discriminant": "type",
        "docs": undefined,
        "union": {
          "agent": "AgentConfigResponse",
          "evaluator": "EvaluatorConfigResponse",
          "generic": "GenericConfigResponse",
          "model": "ModelConfigResponse",
          "tool": "ToolConfigResponse",
        },
      },
      "Content": {
        "discriminated": false,
        "docs": "The content of the message.",
        "union": [
          "string",
          "list<ChatMessageWithToolCallContentItem>",
        ],
      },
      "CreateDatapointRequest": {
        "docs": undefined,
        "properties": {
          "inputs": {
            "docs": "The inputs to the prompt template.",
            "type": "optional<map<string, string>>",
          },
          "messages": {
            "docs": "List of chat messages to provide to the model.",
            "type": "optional<list<ChatMessage>>",
          },
          "target": {
            "docs": "Object with criteria necessary to evaluate generations with this Datapoint. This is passed in as an argument to Evaluators when used in an Evaluation.",
            "type": "optional<map<string, CreateDatapointRequestTargetValue>>",
          },
        },
      },
      "CreateDatapointRequestTargetValue": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "string",
          "integer",
          "double",
          "boolean",
          "map<string, unknown>",
          "list<unknown>",
        ],
      },
      "CreateEvaluationRequest": {
        "docs": "Request model for creating an Evaluation.

Evaluation benchmark your Prompt/Tool Versions. With the Datapoints in a Dataset Version,
Logs corresponding to the Datapoint and each Evaluated Version are evaluated by the specified Evaluator Versions.
Aggregated statistics are then calculated and presented in the Evaluation.",
        "properties": {
          "dataset": {
            "docs": "The Dataset Version to use in this Evaluation.",
            "type": "DatasetRequest",
          },
          "evaluatees": {
            "docs": "Unique identifiers for the Prompt/Tool Versions to include in the Evaluation Report.",
            "type": "list<EvaluateeRequest>",
          },
          "evaluators": {
            "docs": "The Evaluators used to evaluate.",
            "type": "list<EvaluatorRequest>",
          },
        },
      },
      "CreatePromptLogResponse": {
        "docs": undefined,
        "properties": {
          "id": {
            "docs": "String ID of log.",
            "type": "string",
          },
          "prompt_id": {
            "docs": "ID of the Prompt the log belongs to.",
            "type": "string",
          },
          "session_id": {
            "docs": "String ID of session the log belongs to.",
            "type": "optional<string>",
          },
          "version_id": {
            "docs": "ID of the specific version of the Prompt.",
            "type": "string",
          },
        },
      },
      "CreateToolLogResponse": {
        "docs": undefined,
        "properties": {
          "id": {
            "docs": "String ID of log.",
            "type": "string",
          },
          "session_id": {
            "docs": "String ID of session the log belongs to.",
            "type": "optional<string>",
          },
          "tool_id": {
            "docs": "ID of the Prompt the log belongs to.",
            "type": "string",
          },
          "version_id": {
            "docs": "ID of the specific version of the Tool.",
            "type": "string",
          },
        },
      },
      "DashboardConfiguration": {
        "docs": undefined,
        "properties": {
          "model_config_ids": "list<string>",
          "time_range_days": "integer",
          "time_unit": "TimeUnit",
        },
      },
      "DatapointResponse": {
        "docs": undefined,
        "properties": {
          "id": {
            "docs": "Unique identifier for the Datapoint. Starts with \`dp_\`.",
            "type": "string",
          },
          "inputs": {
            "docs": "The inputs to the prompt template.",
            "type": "optional<map<string, string>>",
          },
          "messages": {
            "docs": "List of chat messages to provide to the model.",
            "type": "optional<list<ChatMessage>>",
          },
          "target": {
            "docs": "Object with criteria necessary to evaluate generations with this Datapoint. This is passed in as an argument to Evaluators when used in an Evaluation.",
            "type": "optional<map<string, DatapointResponseTargetValue>>",
          },
        },
      },
      "DatapointResponseTargetValue": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "string",
          "integer",
          "double",
          "boolean",
          "map<string, unknown>",
          "list<unknown>",
        ],
      },
      "DatasetRequest": {
        "docs": undefined,
        "properties": {
          "version_id": {
            "docs": "Unique identifier for the Dataset Version to use in this evaluation. Starts with \`dsv_\`.",
            "type": "string",
          },
        },
      },
      "DatasetResponse": {
        "docs": "Base type that all File Responses should inherit from.

Attributes defined here are common to all File Responses and should be overridden
in the inheriting classes with documentation and appropriate Field definitions.",
        "properties": {
          "commit_message": {
            "docs": "Message describing the changes made. If provided, a committed version of the Dataset is created. Otherwise, an uncommitted version is created.",
            "type": "optional<string>",
          },
          "created_at": "datetime",
          "created_by": {
            "docs": "The user who created the Dataset.",
            "type": "optional<UserResponse>",
          },
          "datapoints": {
            "docs": "The list of Datapoints in this Dataset version. Only provided if explicitly requested.",
            "type": "optional<list<DatapointResponse>>",
          },
          "datapoints_count": {
            "docs": "The number of Datapoints in this Dataset version.",
            "type": "integer",
          },
          "environments": {
            "docs": "The list of environments the Dataset Version is deployed to.",
            "type": "optional<list<EnvironmentResponse>>",
          },
          "id": {
            "docs": "Unique identifier for the Dataset. Starts with \`ds_\`.",
            "type": "string",
          },
          "last_used_at": "datetime",
          "name": {
            "docs": "Name of the Dataset, which is used as a unique identifier.",
            "type": "string",
          },
          "status": {
            "docs": "The status of the Dataset Version.",
            "type": "VersionStatus",
          },
          "updated_at": "datetime",
          "version_id": {
            "docs": "Unique identifier for the specific Dataset Version. If no query params provided, the default deployed Dataset Version is returned. Starts with \`dsv_\`.",
            "type": "string",
          },
        },
      },
      "EnvironmentResponse": {
        "docs": undefined,
        "properties": {
          "created_at": "datetime",
          "id": "string",
          "name": "string",
          "tag": "EnvironmentTag",
        },
      },
      "EnvironmentTag": {
        "docs": "An enumeration.",
        "enum": [
          "default",
          "other",
        ],
      },
      "EvaluatedVersionResponse": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "PromptResponse",
          "ToolResponse",
        ],
      },
      "EvaluateeRequest": {
        "docs": undefined,
        "properties": {
          "batch_id": {
            "docs": "Unique identifier for the batch of Logs to include in the Evaluation Report.",
            "type": "optional<string>",
          },
          "orchestrated": {
            "default": true,
            "docs": "Whether the Prompt/Tool is orchestrated by Humanloop. Default is \`True\`. If \`False\`, a log for the Prompt/Tool should be submitted by the user via the API.",
            "type": "optional<boolean>",
          },
          "version_id": {
            "docs": "Unique identifier for the Prompt/Tool Version to include in the Evaluation Report. Starts with \`pv_\` for Prompts and \`tv_\` for Tools.",
            "type": "string",
          },
        },
      },
      "EvaluateeResponse": {
        "docs": undefined,
        "properties": {
          "batch_id": {
            "docs": "Unique identifier for the batch of Logs to include in the Evaluation Report. ",
            "type": "optional<string>",
          },
          "orchestrated": {
            "docs": "Whether the Prompt/Tool is orchestrated by Humanloop. Default is \`True\`. If \`False\`, a log for the Prompt/Tool should be submitted by the user via the API.",
            "type": "boolean",
          },
          "version": "EvaluatedVersionResponse",
        },
      },
      "EvaluationDebugResultResponse": {
        "docs": "This is similar to an \`EvaluationResult\` but is ephemeral as it is only for synchronous
debug runs. It does not have an ID, or a reference to an evaluation run or even an evaluation
function.",
        "properties": {
          "datapoint_id": "optional<string>",
          "error": "optional<string>",
          "llm_evaluation_log": "optional<LogResponse>",
          "log": "LogResponse",
          "log_id": "string",
          "value": "optional<Value>",
        },
      },
      "EvaluationEvaluatorResponse": {
        "docs": undefined,
        "properties": {
          "orchestrated": {
            "docs": "Whether the Evaluator is orchestrated by Humanloop. Default is \`True\`. If \`False\`, a log for the Evaluator should be submitted by the user via the API.",
            "type": "boolean",
          },
          "version": "EvaluatorResponse",
        },
      },
      "EvaluationResponse": {
        "docs": undefined,
        "properties": {
          "created_at": "datetime",
          "created_by": "optional<UserResponse>",
          "dataset": {
            "docs": "The Dataset Version used in the Evaluation.",
            "type": "DatasetResponse",
          },
          "evaluatees": {
            "docs": "The Prompt/Tool Versions included in the Evaluation.",
            "type": "list<EvaluateeResponse>",
          },
          "evaluators": {
            "docs": "The Evaluator Versions used to evaluate.",
            "type": "list<EvaluationEvaluatorResponse>",
          },
          "id": {
            "docs": "Unique identifier for the Evaluation. Starts with \`evr\`.",
            "type": "string",
          },
          "status": {
            "docs": "The current status of the Evaluation.

- \`"pending"\`: The Evaluation has been created but is not actively being worked on by Humanloop.
- \`"running"\`: Humanloop is checking for any missing Logs and Evaluator Logs, and will generate them where appropriate.
- \`"completed"\`: All Logs an Evaluator Logs have been generated.
- \`"cancelled"\`: The Evaluation has been cancelled by the user. Humanloop will stop generating Logs and Evaluator Logs.
",
            "type": "EvaluationStatus",
          },
          "updated_at": "datetime",
        },
      },
      "EvaluationResultResponse": {
        "docs": undefined,
        "properties": {
          "created_at": "datetime",
          "error": "optional<string>",
          "evaluation_id": "optional<string>",
          "evaluator_id": "string",
          "evaluator_version_id": "string",
          "id": "string",
          "llm_evaluator_log": "optional<LogResponse>",
          "log": "optional<LogResponse>",
          "log_id": "string",
          "updated_at": "datetime",
          "value": "optional<Value>",
          "version": "optional<unknown>",
          "version_id": "optional<string>",
        },
      },
      "EvaluationStats": {
        "docs": undefined,
        "properties": {
          "overall_stats": {
            "docs": "Stats for the Evaluation Report as a whole.",
            "type": "OverallStats",
          },
          "version_stats": {
            "docs": "Stats for each Evaluated Version in the Evaluation Report.",
            "type": "list<VersionStats>",
          },
        },
      },
      "EvaluationStatus": {
        "docs": "Status of an evaluation.",
        "enum": [
          "pending",
          "running",
          "completed",
          "cancelled",
          "failed",
        ],
      },
      "EvaluatorActivationDeactivationRequest": {
        "docs": undefined,
        "properties": {
          "evaluators_to_activate": {
            "docs": "Monitoring Evaluators to activate. These will be automatically run on new Logs.",
            "type": "optional<list<EvaluatorActivationDeactivationRequestEvaluatorsToActivateItem>>",
          },
          "evaluators_to_deactivate": {
            "docs": "Evaluators to deactivate. These will not be run on new Logs.",
            "type": "optional<list<EvaluatorActivationDeactivationRequestEvaluatorsToDeactivateItem>>",
          },
        },
      },
      "EvaluatorActivationDeactivationRequestEvaluatorsToActivateItem": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "MonitoringEvaluatorVersionRequest",
          "MonitoringEvaluatorEnvironmentRequest",
        ],
      },
      "EvaluatorActivationDeactivationRequestEvaluatorsToDeactivateItem": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "MonitoringEvaluatorVersionRequest",
          "MonitoringEvaluatorEnvironmentRequest",
        ],
      },
      "EvaluatorArgumentsType": {
        "docs": "Enum representing the possible argument types of an evaluator.",
        "enum": [
          "target_free",
          "target_required",
        ],
      },
      "EvaluatorConfigResponse": {
        "docs": undefined,
        "properties": {
          "arguments_type": {
            "docs": "Whether this evaluator is target-free or target-required.",
            "type": "optional<EvaluatorArgumentsType>",
          },
          "code": {
            "docs": "The code for the evaluator. This code will be executed in a sandboxed environment.",
            "type": "optional<string>",
          },
          "created_by": {
            "docs": "The user who created the config.",
            "type": "optional<UserResponse>",
          },
          "description": {
            "docs": "Description of config.",
            "type": "optional<string>",
          },
          "evaluator_type": {
            "docs": "Type of evaluator.",
            "type": "string",
          },
          "id": {
            "docs": "String ID of config. Starts with \`config_\`.",
            "type": "string",
          },
          "model_config": {
            "docs": "The model config defining the LLM evaluator.",
            "type": "optional<ModelConfigResponse>",
          },
          "name": {
            "docs": "Name of config.",
            "type": "string",
          },
          "other": {
            "docs": "Other parameters that define the config.",
            "type": "optional<map<string, unknown>>",
          },
          "return_type": {
            "docs": "The type of the return value of the evaluator.",
            "type": "optional<EvaluatorReturnTypeEnum>",
          },
          "status": {
            "docs": "Whether the config is committed or not.",
            "type": "string",
          },
        },
      },
      "EvaluatorRequest": {
        "docs": undefined,
        "properties": {
          "orchestrated": {
            "default": true,
            "docs": "Whether the Evaluator is orchestrated by Humanloop. Default is \`True\`. If \`False\`, a log for the Evaluator should be submitted by the user via the API.",
            "type": "optional<boolean>",
          },
          "version_id": {
            "docs": "Unique identifier for the Evaluator Version to use in this evaluation. Starts with \`evv_\`.",
            "type": "string",
          },
        },
      },
      "EvaluatorResponse": {
        "docs": "Request model for creating a new Evaluator",
        "properties": {
          "commit_message": {
            "docs": "Message describing the changes made.",
            "type": "optional<string>",
          },
          "created_at": "datetime",
          "created_by": {
            "docs": "The user who created the Prompt.",
            "type": "optional<UserResponse>",
          },
          "directory_id": {
            "docs": "Unique identifier for the Directory of the Evaluator.",
            "type": "optional<string>",
          },
          "environments": {
            "docs": "The list of environments the Prompt Version is deployed to.",
            "type": "optional<list<EnvironmentResponse>>",
          },
          "id": {
            "docs": "Unique identifier for the Evaluator.",
            "type": "string",
          },
          "inputs": {
            "docs": "Inputs associated to the Prompt. Inputs correspond to any of the variables used within the Prompt template.",
            "type": "list<InputResponse>",
          },
          "last_used_at": "datetime",
          "name": {
            "docs": "Name of the Evaluator, which is used as a unique identifier.",
            "type": "string",
          },
          "spec": "Spec",
          "status": "VersionStatus",
          "total_logs_count": {
            "docs": "The number of logs that have been generated across all Prompt Versions",
            "type": "integer",
          },
          "updated_at": "datetime",
          "version_id": {
            "docs": "Unique identifier for the specific Evaluator Version. If no query params provided, the default deployed Evaluator Version is returned.",
            "type": "string",
          },
          "version_logs_count": {
            "docs": "The number of logs that have been generated for this Prompt Version",
            "type": "integer",
          },
        },
      },
      "EvaluatorReturnTypeEnum": {
        "docs": "Enum representing the possible return types of an evaluator.",
        "enum": [
          "boolean",
          "number",
        ],
      },
      "FeedbackClass": {
        "docs": "An enumeration.",
        "enum": [
          "select",
          "multi_select",
          "text",
          "number",
        ],
      },
      "FeedbackLabelStatus": {
        "docs": "Controls whether the label is displayed in the UI.",
        "enum": [
          "unset",
          "active",
          "inactive",
        ],
      },
      "FeedbackResponse": {
        "docs": undefined,
        "properties": {
          "created_at": {
            "docs": "User defined timestamp for when the feedback was created. ",
            "type": "optional<datetime>",
          },
          "data_id": {
            "docs": "ID to associate the feedback to a previously logged datapoint.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "String ID of user feedback. Starts with \`ann_\`, short for annotation.",
            "type": "string",
          },
          "type": {
            "docs": "The type of feedback. The default feedback types available are 'rating', 'action', 'issue', 'correction', and 'comment'.",
            "type": "FeedbackResponseType",
          },
          "user": {
            "docs": "A unique identifier to who provided the feedback.",
            "type": "optional<string>",
          },
          "value": {
            "docs": "The feedback value to set. This would be the appropriate text for 'correction' or 'comment', or a label to apply for 'rating', 'action', or 'issue'.",
            "type": "FeedbackResponseValue",
          },
        },
      },
      "FeedbackResponseType": {
        "discriminated": false,
        "docs": "The type of feedback. The default feedback types available are 'rating', 'action', 'issue', 'correction', and 'comment'.",
        "union": [
          "FeedbackType",
          "string",
        ],
      },
      "FeedbackResponseValue": {
        "discriminated": false,
        "docs": "The feedback value to set. This would be the appropriate text for 'correction' or 'comment', or a label to apply for 'rating', 'action', or 'issue'.",
        "union": [
          "double",
          "string",
        ],
      },
      "FeedbackType": {
        "docs": "An enumeration.",
        "enum": [
          "rating",
          "action",
          "issue",
          "correction",
          "comment",
        ],
      },
      "FeedbackTypeModel": {
        "docs": undefined,
        "properties": {
          "type": {
            "docs": "The type of feedback. The default feedback types available are 'rating', 'action', 'issue', 'correction', and 'comment'.",
            "type": "FeedbackTypeModelType",
          },
          "values": {
            "docs": "The allowed values for categorical feedback types. Not populated for \`correction\` and \`comment\`.",
            "type": "optional<list<CategoricalFeedbackLabel>>",
          },
        },
      },
      "FeedbackTypeModelType": {
        "discriminated": false,
        "docs": "The type of feedback. The default feedback types available are 'rating', 'action', 'issue', 'correction', and 'comment'.",
        "union": [
          "FeedbackType",
          "string",
        ],
      },
      "FeedbackTypes": "list<FeedbackTypeModel>",
      "File": {
        "discriminated": false,
        "docs": "The File that the deployed Version belongs to.",
        "union": [
          "PromptResponse",
          "ToolResponse",
          "DatasetResponse",
          "EvaluatorResponse",
        ],
      },
      "FunctionTool": {
        "docs": "A function tool to be called by the model where user owns runtime.",
        "properties": {
          "arguments": "optional<string>",
          "name": "string",
        },
      },
      "FunctionToolChoice": {
        "docs": "A function tool to be called by the model where user owns runtime.",
        "properties": {
          "name": "string",
        },
      },
      "GenericConfigResponse": {
        "docs": undefined,
        "properties": {
          "created_by": {
            "docs": "The user who created the config.",
            "type": "optional<UserResponse>",
          },
          "description": {
            "docs": "Description of config.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "String ID of config. Starts with \`config_\`.",
            "type": "string",
          },
          "name": {
            "docs": "Name of config.",
            "type": "string",
          },
          "other": {
            "docs": "Other parameters that define the config.",
            "type": "optional<map<string, unknown>>",
          },
          "status": {
            "docs": "Whether the config is committed or not.",
            "type": "string",
          },
        },
      },
      "HTTPValidationError": {
        "docs": undefined,
        "properties": {
          "detail": "optional<list<ValidationError>>",
        },
      },
      "HumanEvaluatorRequest": {
        "docs": undefined,
        "properties": {
          "arguments_type": {
            "docs": "Whether this evaluator is target-free or target-required.",
            "type": "EvaluatorArgumentsType",
          },
          "return_type": {
            "docs": "The type of the return value of the evaluator.",
            "type": "EvaluatorReturnTypeEnum",
          },
        },
      },
      "ImageChatContent": {
        "docs": undefined,
        "properties": {
          "image_url": {
            "docs": "The message's image content.",
            "type": "ImageUrl",
          },
        },
      },
      "ImageUrl": {
        "docs": undefined,
        "properties": {
          "detail": {
            "docs": "Specify the detail level of the image provided to the model. For more details see: https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding",
            "type": "optional<ImageUrlDetail>",
          },
          "url": {
            "docs": "Either a URL of the image or the base64 encoded image data.",
            "type": "string",
          },
        },
      },
      "ImageUrlDetail": {
        "docs": "Specify the detail level of the image provided to the model. For more details see: https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding",
        "enum": [
          "high",
          "low",
          "auto",
        ],
      },
      "InputResponse": {
        "docs": undefined,
        "properties": {
          "name": {
            "docs": "Type of input.",
            "type": "string",
          },
        },
      },
      "Judgment": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "boolean",
          "double",
        ],
      },
      "LLMEvaluatorRequest": {
        "docs": undefined,
        "properties": {
          "arguments_type": {
            "docs": "Whether this evaluator is target-free or target-required.",
            "type": "EvaluatorArgumentsType",
          },
          "prompt": {
            "docs": "The prompt parameters used to generate.",
            "type": "optional<PromptKernelRequest>",
          },
          "return_type": {
            "docs": "The type of the return value of the evaluator.",
            "type": "EvaluatorReturnTypeEnum",
          },
        },
      },
      "LabelSentiment": {
        "docs": "How a label should be treated in calculating Version performance.

Used by a File's PAPV (Positive Action Per View) metric.",
        "enum": [
          "positive",
          "negative",
          "neutral",
          "unset",
        ],
      },
      "LinkedToolRequest": {
        "docs": undefined,
        "properties": {
          "description": {
            "docs": "The description of the linked tool.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "The ID of the linked tool. Starts with "oc_"",
            "type": "string",
          },
          "name": {
            "docs": "The name of the linked tool.",
            "type": "optional<string>",
          },
          "parameters": {
            "docs": "The parameters of the linked tool.",
            "type": "optional<map<string, unknown>>",
          },
          "source": {
            "docs": "The source of the linked tool. For a linked tool it should be \`organization\`",
            "type": "literal<"organization">",
          },
        },
      },
      "LinkedToolResponse": {
        "docs": undefined,
        "properties": {
          "description": {
            "docs": "Description of the tool referenced by the model",
            "type": "string",
          },
          "id": {
            "docs": "Unique identifier for the Tool linked.",
            "type": "string",
          },
          "name": {
            "docs": "Name for the tool referenced by the model.",
            "type": "string",
          },
          "parameters": {
            "docs": "Parameters needed to run the Tool, defined in JSON Schema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
          "version_id": {
            "docs": "Unique identifier for the Tool Version linked.",
            "type": "string",
          },
        },
      },
      "ListDatasets": {
        "docs": undefined,
        "properties": {
          "records": {
            "docs": "The list of Datasets.",
            "type": "list<DatasetResponse>",
          },
        },
      },
      "ListEvaluators": {
        "docs": undefined,
        "properties": {
          "records": {
            "docs": "The list of Evaluators.",
            "type": "list<EvaluatorResponse>",
          },
        },
      },
      "ListPrompts": {
        "docs": undefined,
        "properties": {
          "records": {
            "docs": "The list of Prompts.",
            "type": "list<PromptResponse>",
          },
        },
      },
      "ListTools": {
        "docs": undefined,
        "properties": {
          "records": {
            "docs": "The list of Tools.",
            "type": "list<ToolResponse>",
          },
        },
      },
      "LogResponse": {
        "docs": "Request model for logging a datapoint.",
        "properties": {
          "batch_ids": {
            "docs": "List of batch IDs the log belongs to.",
            "type": "optional<list<string>>",
          },
          "config": "ConfigResponse",
          "config_id": {
            "docs": "Unique ID of a config to associate to the log.",
            "type": "optional<string>",
          },
          "created_at": {
            "docs": "User defined timestamp for when the log was created. ",
            "type": "optional<datetime>",
          },
          "duration": {
            "docs": "Duration of the logged event in seconds.",
            "type": "optional<double>",
          },
          "environment": {
            "docs": "The environment name used to create the log.",
            "type": "optional<string>",
          },
          "error": {
            "docs": "Error message if the log is an error.",
            "type": "optional<string>",
          },
          "evaluation_results": "list<EvaluationResultResponse>",
          "feedback": "optional<list<FeedbackResponse>>",
          "finish_reason": {
            "docs": "Reason the generation finished.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "String ID of logged datapoint. Starts with \`data_\`.",
            "type": "string",
          },
          "inputs": {
            "docs": "The inputs passed to the prompt template.",
            "type": "optional<map<string, unknown>>",
          },
          "judgment": "optional<Judgment>",
          "messages": {
            "docs": "The messages passed to the to provider chat endpoint.",
            "type": "optional<list<ChatMessageWithToolCall>>",
          },
          "metadata": {
            "docs": "Any additional metadata to record.",
            "type": "optional<map<string, unknown>>",
          },
          "metric_values": "optional<list<MetricValueResponse>>",
          "observability_status": "ObservabilityStatus",
          "output": {
            "docs": "Generated output from your model for the provided inputs. Can be \`None\` if logging an error, or if logging a parent datapoint with the intention to populate it later",
            "type": "optional<string>",
          },
          "output_cost": {
            "docs": "Cost in dollars associated to the tokens in the output.",
            "type": "optional<double>",
          },
          "output_message": {
            "docs": "The message returned by the provider.",
            "type": "optional<ChatMessageWithToolCall>",
          },
          "output_tokens": {
            "docs": "Number of tokens in the output generated by the model.",
            "type": "optional<integer>",
          },
          "parent_id": {
            "docs": "ID associated to the parent datapoint in a session.",
            "type": "optional<string>",
          },
          "parent_reference_id": {
            "docs": "A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as \`parent_id\` in a prior log request. Specify at most one of this or \`parent_id\`. Note that this cannot refer to a datapoint being logged in the same request.",
            "type": "optional<string>",
          },
          "project": {
            "docs": "The name of the project associated with this log",
            "type": "optional<string>",
          },
          "project_id": {
            "docs": "The unique ID of the project associated with this log.",
            "type": "optional<string>",
          },
          "prompt_cost": {
            "docs": "Cost in dollars associated to the tokens in the prompt.",
            "type": "optional<double>",
          },
          "prompt_tokens": {
            "docs": "Number of tokens in the prompt used to generate the output.",
            "type": "optional<integer>",
          },
          "provider_latency": {
            "docs": "Latency of provider response.",
            "type": "optional<double>",
          },
          "provider_request": {
            "docs": "Raw request sent to provider.",
            "type": "optional<map<string, unknown>>",
          },
          "provider_response": {
            "docs": "Raw response received the provider.",
            "type": "optional<map<string, unknown>>",
          },
          "raw_output": {
            "docs": "Raw output from the provider.",
            "type": "optional<string>",
          },
          "reference_id": {
            "docs": "Unique user-provided string identifying the datapoint.",
            "type": "optional<string>",
          },
          "save": {
            "default": true,
            "docs": "Whether the request/response payloads will be stored on Humanloop.",
            "type": "optional<boolean>",
          },
          "session_id": {
            "docs": "ID of the session to associate the datapoint.",
            "type": "optional<string>",
          },
          "session_reference_id": {
            "docs": "A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same \`session_reference_id\` in subsequent log requests. Specify at most one of this or \`session_id\`.",
            "type": "optional<string>",
          },
          "source": {
            "docs": "Identifies where the model was called from.",
            "type": "optional<string>",
          },
          "source_datapoint_id": {
            "docs": "ID of the source datapoint if this is a log derived from a datapoint in a dataset.",
            "type": "optional<string>",
          },
          "tokens": {
            "docs": "Total number of tokens in the prompt and output.",
            "type": "optional<integer>",
          },
          "tool_choice": {
            "docs": "Controls how the model uses tools. The following options are supported: 'none' forces the model to not call a tool; the default when no tools are provided as part of the model config. 'auto' the model can decide to call one of the provided tools; the default when tools are provided as part of the model config. Providing {'type': 'function', 'function': {name': <TOOL_NAME>}} forces the model to use the named function.",
            "type": "optional<LogResponseToolChoice>",
          },
          "tools": "optional<list<ToolResultResponse>>",
          "trial_id": {
            "docs": "Unique ID of an experiment trial to associate to the log.",
            "type": "optional<string>",
          },
          "updated_at": "datetime",
          "user": {
            "docs": "User email address provided when creating the datapoint.",
            "type": "optional<string>",
          },
        },
      },
      "LogResponseToolChoice": {
        "discriminated": false,
        "docs": "Controls how the model uses tools. The following options are supported: 'none' forces the model to not call a tool; the default when no tools are provided as part of the model config. 'auto' the model can decide to call one of the provided tools; the default when tools are provided as part of the model config. Providing {'type': 'function', 'function': {name': <TOOL_NAME>}} forces the model to use the named function.",
        "union": [
          "literal<"none">",
          "literal<"auto">",
          "literal<"required">",
          "ToolChoice",
        ],
      },
      "MetricValueResponse": {
        "docs": undefined,
        "properties": {
          "metric_id": "string",
          "metric_name": "string",
          "metric_value": "double",
        },
      },
      "ModelConfigRequest": {
        "docs": "Model config used for logging both chat and completion.",
        "properties": {
          "chat_template": {
            "docs": "Messages prepended to the list of messages sent to the provider. These messages that will take your specified inputs to form your final request to the provider model. Input variables within the template should be specified with syntax: {{INPUT_NAME}}.",
            "type": "optional<list<ChatMessageWithToolCall>>",
          },
          "description": {
            "docs": "A description of the model config.",
            "type": "optional<string>",
          },
          "endpoint": {
            "docs": "The provider model endpoint used.",
            "type": "optional<ModelEndpoints>",
          },
          "frequency_penalty": {
            "default": 0,
            "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "type": "optional<double>",
          },
          "max_tokens": {
            "default": -1,
            "docs": "The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt",
            "type": "optional<integer>",
          },
          "model": {
            "docs": "The model instance used. E.g. text-davinci-002.",
            "type": "string",
          },
          "name": {
            "docs": "A friendly display name for the model config. If not provided, a name will be generated.",
            "type": "optional<string>",
          },
          "other": {
            "docs": "Other parameter values to be passed to the provider call.",
            "type": "optional<map<string, unknown>>",
          },
          "presence_penalty": {
            "default": 0,
            "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "type": "optional<double>",
          },
          "prompt_template": {
            "docs": "Prompt template that will take your specified inputs to form your final request to the model. Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.",
            "type": "optional<string>",
          },
          "provider": {
            "docs": "The company providing the underlying model service.",
            "type": "optional<ModelProviders>",
          },
          "response_format": {
            "docs": "The format of the response. Only type json_object is currently supported for chat.",
            "type": "optional<ResponseFormat>",
          },
          "seed": {
            "docs": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed.",
            "type": "optional<integer>",
          },
          "stop": {
            "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
            "type": "optional<ModelConfigRequestStop>",
          },
          "temperature": {
            "default": 1,
            "docs": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "type": "optional<double>",
          },
          "tools": {
            "docs": "Make tools available to OpenAIs chat model as functions.",
            "type": "optional<list<ModelConfigRequestToolsItem>>",
          },
          "top_p": {
            "default": 1,
            "docs": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "type": "optional<double>",
          },
          "type": "optional<literal<"model">>",
        },
      },
      "ModelConfigRequestStop": {
        "discriminated": false,
        "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
        "union": [
          "string",
          "list<string>",
        ],
      },
      "ModelConfigRequestToolsItem": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "LinkedToolRequest",
          "ModelConfigToolRequest",
        ],
      },
      "ModelConfigResponse": {
        "docs": "Model config request.

Contains fields that are common to all (i.e. both chat and complete) endpoints.",
        "properties": {
          "chat_template": {
            "docs": "Messages prepended to the list of messages sent to the provider. These messages that will take your specified inputs to form your final request to the provider model. NB: Input variables within the template should be specified with syntax: {{INPUT_NAME}}.",
            "type": "optional<list<ChatMessageWithToolCall>>",
          },
          "description": {
            "docs": "A description of the model config.",
            "type": "optional<string>",
          },
          "endpoint": {
            "docs": "The provider model endpoint used.",
            "type": "optional<ModelEndpoints>",
          },
          "frequency_penalty": {
            "default": 0,
            "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "type": "optional<double>",
          },
          "id": {
            "docs": "String ID of config. Starts with \`config_\`.",
            "type": "string",
          },
          "max_tokens": {
            "default": -1,
            "docs": "The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt",
            "type": "optional<integer>",
          },
          "model": {
            "docs": "The model instance used. E.g. text-davinci-002.",
            "type": "string",
          },
          "name": {
            "docs": "A friendly display name for the model config. If not provided, a name will be generated.",
            "type": "optional<string>",
          },
          "other": {
            "docs": "Other parameter values to be passed to the provider call.",
            "type": "optional<map<string, unknown>>",
          },
          "presence_penalty": {
            "default": 0,
            "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "type": "optional<double>",
          },
          "prompt_template": {
            "docs": "Prompt template that will take your specified inputs to form your final request to the model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.",
            "type": "optional<string>",
          },
          "provider": {
            "docs": "The company providing the underlying model service.",
            "type": "optional<ModelProviders>",
          },
          "response_format": {
            "docs": "The format of the response. Only type json_object is currently supported for chat.",
            "type": "optional<ResponseFormat>",
          },
          "seed": {
            "docs": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed.",
            "type": "optional<integer>",
          },
          "stop": {
            "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
            "type": "optional<ModelConfigResponseStop>",
          },
          "temperature": {
            "default": 1,
            "docs": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "type": "optional<double>",
          },
          "tool_configs": {
            "availability": "deprecated",
            "docs": "NB: Deprecated with tools field. Definition of tools shown to the model.",
            "type": "optional<list<ToolConfigResponse>>",
          },
          "tools": {
            "docs": "Tools shown to the model.",
            "type": "optional<list<ToolResponse>>",
          },
          "top_p": {
            "default": 1,
            "docs": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "type": "optional<double>",
          },
        },
      },
      "ModelConfigResponseStop": {
        "discriminated": false,
        "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
        "union": [
          "string",
          "list<string>",
        ],
      },
      "ModelConfigToolRequest": {
        "docs": "Definition of tool within a model config.

The subset of ToolConfig parameters received by the chat endpoint.
Does not have things like the signature or setup schema.",
        "properties": {
          "description": {
            "docs": "The description of the tool shown to the model.",
            "type": "optional<string>",
          },
          "name": {
            "docs": "The name of the tool shown to the model.",
            "type": "string",
          },
          "other": {
            "docs": "Other parameters that define the config.",
            "type": "optional<map<string, unknown>>",
          },
          "parameters": {
            "docs": "Definition of parameters needed to run the tool. Provided in jsonschema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
          "preset_name": {
            "docs": "If is_preset = true, this is the name of the preset tool on Humanloop. This is used as the key to look up the Humanloop runtime of the tool",
            "type": "optional<string>",
          },
          "source": {
            "docs": "Source of the tool. If defined at an organization level will be 'organization' else 'inline'.",
            "type": "optional<ToolSource>",
          },
          "source_code": {
            "docs": "Code source of the tool.",
            "type": "optional<string>",
          },
        },
      },
      "ModelEndpoints": {
        "docs": "Supported model provider endpoints.",
        "enum": [
          "complete",
          "chat",
          "edit",
        ],
      },
      "ModelProviders": {
        "docs": "Supported model providers.",
        "enum": [
          "openai",
          "openai_azure",
          "ai21",
          "mock",
          "anthropic",
          "langchain",
          "cohere",
          "replicate",
          "google",
          "groq",
        ],
      },
      "MonitoringEvaluatorEnvironmentRequest": {
        "docs": undefined,
        "properties": {
          "environment_id": {
            "docs": "Unique identifier for the Environment. The Evaluator Version deployed to this Environment will be used for monitoring.",
            "type": "string",
          },
          "evaluator_id": {
            "docs": "Unique identifier for the Evaluator to be used for monitoring.",
            "type": "string",
          },
        },
      },
      "MonitoringEvaluatorResponse": {
        "docs": undefined,
        "properties": {
          "created_at": "datetime",
          "state": {
            "docs": "The state of the Monitoring Evaluator. Either \`active\` or \`inactive\`",
            "type": "MonitoringEvaluatorState",
          },
          "updated_at": "datetime",
          "version": {
            "docs": "The deployed Version.",
            "type": "optional<EvaluatorResponse>",
          },
          "version_reference": {
            "docs": "The Evaluator Version used for monitoring. This can be a specific Version by ID, or a Version deployed to an Environment.",
            "type": "VersionReferenceResponse",
          },
        },
      },
      "MonitoringEvaluatorState": {
        "docs": "State of an evaluator connected to a file",
        "enum": [
          "active",
          "inactive",
        ],
      },
      "MonitoringEvaluatorVersionRequest": {
        "docs": undefined,
        "properties": {
          "evaluator_version_id": {
            "docs": "Unique identifier for the Evaluator Version to be used for monitoring.",
            "type": "string",
          },
        },
      },
      "NumericEvaluatorVersionStats": {
        "docs": "Base attributes for stats for an Evaluator Version-Evaluated Version pair
in the Evaluation Report.",
        "properties": {
          "evaluator_version_id": {
            "docs": "Unique identifier for the Evaluator Version.",
            "type": "string",
          },
          "mean": "optional<double>",
          "num_errors": {
            "docs": "The total number of errored Evaluators for this Evaluator Version.",
            "type": "integer",
          },
          "num_judgments": {
            "docs": "The total number of Evaluator judgments for this Evaluator Version. This excludes Nulls and Errors.",
            "type": "integer",
          },
          "num_nulls": {
            "docs": "The total number of null judgments (i.e. abstentions) for this Evaluator Version.",
            "type": "integer",
          },
          "percentiles": "map<string, double>",
          "std": "optional<double>",
          "total_logs": {
            "docs": "The total number of Logs generated by this Evaluator Version on the Evaluated Version's Logs. This includes Nulls and Errors.",
            "type": "integer",
          },
        },
      },
      "ObservabilityStatus": {
        "docs": "Status of a Log for observability.

Observability is implemented by running monitoring Evaluators on Logs.",
        "enum": [
          "pending",
          "running",
          "completed",
          "failed",
        ],
      },
      "OverallStats": {
        "docs": undefined,
        "properties": {
          "num_datapoints": {
            "docs": "The total number of Datapoints in the Evaluation Report's Dataset Version.",
            "type": "integer",
          },
          "total_evaluator_logs": {
            "docs": "The total number of Evaluator Logs in the Evaluation Report.",
            "type": "integer",
          },
          "total_logs": {
            "docs": "The total number of Logs in the Evaluation Report.",
            "type": "integer",
          },
        },
      },
      "PaginatedDataDatapointResponse": {
        "docs": undefined,
        "properties": {
          "page": "integer",
          "records": "list<DatapointResponse>",
          "size": "integer",
          "total": "integer",
        },
      },
      "PaginatedDataDatasetResponse": {
        "docs": undefined,
        "properties": {
          "page": "integer",
          "records": "list<DatasetResponse>",
          "size": "integer",
          "total": "integer",
        },
      },
      "PaginatedDataEvaluationResponse": {
        "docs": undefined,
        "properties": {
          "page": "integer",
          "records": "list<EvaluationResponse>",
          "size": "integer",
          "total": "integer",
        },
      },
      "PaginatedDataPromptLogResponse": {
        "docs": undefined,
        "properties": {
          "page": "integer",
          "records": "list<PromptLogResponse>",
          "size": "integer",
          "total": "integer",
        },
      },
      "PaginatedDataSessionResponse": {
        "docs": undefined,
        "properties": {
          "page": "integer",
          "records": "list<SessionResponse>",
          "size": "integer",
          "total": "integer",
        },
      },
      "PlatformAccessEnum": {
        "docs": "An enumeration.",
        "enum": [
          "superadmin",
          "supportadmin",
          "user",
        ],
      },
      "ProjectSortBy": {
        "docs": "An enumeration.",
        "enum": [
          "created_at",
          "updated_at",
          "name",
        ],
      },
      "PromptCallLogResponse": {
        "docs": "Sample specific response details for a Prompt call",
        "properties": {
          "created_at": {
            "docs": "User defined timestamp for when the log was created. ",
            "type": "optional<datetime>",
          },
          "error": {
            "docs": "Error message if the log is an error.",
            "type": "optional<string>",
          },
          "finish_reason": {
            "docs": "Reason the generation finished.",
            "type": "optional<string>",
          },
          "index": {
            "docs": "The index of the sample in the batch.",
            "type": "integer",
          },
          "output": {
            "docs": "Generated output from your model for the provided inputs. Can be \`None\` if logging an error, or if creating a parent Log with the intention to populate it later.",
            "type": "optional<string>",
          },
          "output_cost": {
            "docs": "Cost in dollars associated to the tokens in the output.",
            "type": "optional<double>",
          },
          "output_message": {
            "docs": "The message returned by the provider.",
            "type": "optional<ChatMessage>",
          },
          "output_tokens": {
            "docs": "Number of tokens in the output generated by the model.",
            "type": "optional<integer>",
          },
          "prompt_cost": {
            "docs": "Cost in dollars associated to the tokens in the prompt.",
            "type": "optional<double>",
          },
          "prompt_tokens": {
            "docs": "Number of tokens in the prompt used to generate the output.",
            "type": "optional<integer>",
          },
          "provider_latency": {
            "docs": "Duration of the logged event in seconds.",
            "type": "optional<double>",
          },
          "raw_output": {
            "docs": "Raw output from the provider.",
            "type": "optional<string>",
          },
        },
      },
      "PromptCallResponse": {
        "docs": "Response model for a Prompt call with potentially multiple log samples.",
        "properties": {
          "batches": {
            "docs": "Array of Batch Ids that this log is part of. Batches are used to group Logs together for offline Evaluations",
            "type": "optional<list<string>>",
          },
          "environment": {
            "docs": "The name of the Environment the Log is associated to.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "ID of the log.",
            "type": "string",
          },
          "inputs": {
            "docs": "The inputs passed to the prompt template.",
            "type": "optional<map<string, unknown>>",
          },
          "logs": {
            "docs": "The logs generated by the Prompt call.",
            "type": "list<PromptCallLogResponse>",
          },
          "messages": {
            "docs": "The messages passed to the to provider chat endpoint.",
            "type": "optional<list<ChatMessage>>",
          },
          "metadata": {
            "docs": "Any additional metadata to record.",
            "type": "optional<map<string, unknown>>",
          },
          "parent_id": {
            "docs": "Unique identifier for the parent Log in a Session. Should only be provided if \`session_id\` is provided. If provided, the Log will be nested under the parent Log within the Session.",
            "type": "optional<string>",
          },
          "prompt": {
            "docs": "Prompt details used to generate the log.",
            "type": "PromptResponse",
          },
          "save": {
            "default": true,
            "docs": "Whether the request/response payloads will be stored on Humanloop.",
            "type": "optional<boolean>",
          },
          "session_id": {
            "docs": "Unique identifier for the Session to associate the Log to. Allows you to record multiple Logs to a Session (using an ID kept by your internal systems) by passing the same \`session_id\` in subsequent log requests. ",
            "type": "optional<string>",
          },
          "source": {
            "docs": "Identifies where the model was called from.",
            "type": "optional<string>",
          },
          "source_datapoint_id": {
            "docs": "Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.",
            "type": "optional<string>",
          },
          "tool_choice": {
            "docs": "Controls how the model uses tools. The following options are supported: 
- \`'none'\` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt. 
- \`'auto'\` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt. 
- \`'required'\` means the model can decide to call one or more of the provided tools. 
- \`{'type': 'function', 'function': {name': <TOOL_NAME>}}\` forces the model to use the named function.",
            "type": "optional<PromptCallResponseToolChoice>",
          },
          "user": {
            "docs": "End-user ID related to the Log.",
            "type": "optional<string>",
          },
        },
      },
      "PromptCallResponseToolChoice": {
        "discriminated": false,
        "docs": "Controls how the model uses tools. The following options are supported: 
- \`'none'\` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt. 
- \`'auto'\` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt. 
- \`'required'\` means the model can decide to call one or more of the provided tools. 
- \`{'type': 'function', 'function': {name': <TOOL_NAME>}}\` forces the model to use the named function.",
        "union": [
          "literal<"none">",
          "literal<"auto">",
          "literal<"required">",
          "ToolChoice",
        ],
      },
      "PromptCallStreamResponse": {
        "docs": "Response model for calling Prompt in streaming mode.",
        "properties": {
          "created_at": {
            "docs": "User defined timestamp for when the log was created. ",
            "type": "optional<datetime>",
          },
          "error": {
            "docs": "Error message if the log is an error.",
            "type": "optional<string>",
          },
          "finish_reason": {
            "docs": "Reason the generation finished.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "ID of the log.",
            "type": "string",
          },
          "index": {
            "docs": "The index of the sample in the batch.",
            "type": "integer",
          },
          "output": {
            "docs": "Generated output from your model for the provided inputs. Can be \`None\` if logging an error, or if creating a parent Log with the intention to populate it later.",
            "type": "optional<string>",
          },
          "output_cost": {
            "docs": "Cost in dollars associated to the tokens in the output.",
            "type": "optional<double>",
          },
          "output_message": {
            "docs": "The message returned by the provider.",
            "type": "optional<ChatMessage>",
          },
          "output_tokens": {
            "docs": "Number of tokens in the output generated by the model.",
            "type": "optional<integer>",
          },
          "prompt_cost": {
            "docs": "Cost in dollars associated to the tokens in the prompt.",
            "type": "optional<double>",
          },
          "prompt_id": {
            "docs": "ID of the Prompt the log belongs to.",
            "type": "string",
          },
          "prompt_tokens": {
            "docs": "Number of tokens in the prompt used to generate the output.",
            "type": "optional<integer>",
          },
          "provider_latency": {
            "docs": "Duration of the logged event in seconds.",
            "type": "optional<double>",
          },
          "raw_output": {
            "docs": "Raw output from the provider.",
            "type": "optional<string>",
          },
          "version_id": {
            "docs": "ID of the specific version of the Prompt.",
            "type": "string",
          },
        },
      },
      "PromptKernelRequest": {
        "docs": undefined,
        "properties": {
          "endpoint": {
            "docs": "The provider model endpoint used.",
            "type": "optional<ModelEndpoints>",
          },
          "frequency_penalty": {
            "default": 0,
            "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "type": "optional<double>",
          },
          "linked_tools": {
            "docs": "The IDs of the Tools in your organization that the model can choose to call if Tool calling is supported. The default deployed version of that tool is called.",
            "type": "optional<list<string>>",
          },
          "max_tokens": {
            "default": -1,
            "docs": "The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt",
            "type": "optional<integer>",
          },
          "model": {
            "docs": "The model instance used, e.g. \`gpt-4\`. See [supported models](https://humanloop.com/docs/supported-models)",
            "type": "string",
          },
          "other": {
            "docs": "Other parameter values to be passed to the provider call.",
            "type": "optional<map<string, unknown>>",
          },
          "presence_penalty": {
            "default": 0,
            "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "type": "optional<double>",
          },
          "provider": {
            "docs": "The company providing the underlying model service.",
            "type": "optional<ModelProviders>",
          },
          "response_format": {
            "docs": "The format of the response. Only \`{"type": "json_object"}\` is currently supported for chat.",
            "type": "optional<ResponseFormat>",
          },
          "seed": {
            "docs": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed.",
            "type": "optional<integer>",
          },
          "stop": {
            "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
            "type": "optional<PromptKernelRequestStop>",
          },
          "temperature": {
            "default": 1,
            "docs": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "type": "optional<double>",
          },
          "template": {
            "docs": "For chat endpoint, provide a Chat template. For completion endpoint, provide a Prompt template. Input variables within the template should be specified with double curly bracket syntax: {{INPUT_NAME}}.",
            "type": "optional<Template>",
          },
          "tools": {
            "docs": "The tool specification that the model can choose to call if Tool calling is supported.",
            "type": "optional<list<ToolFunction>>",
          },
          "top_p": {
            "default": 1,
            "docs": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "type": "optional<double>",
          },
        },
      },
      "PromptKernelRequestStop": {
        "discriminated": false,
        "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
        "union": [
          "string",
          "list<string>",
        ],
      },
      "PromptLogResponse": {
        "docs": "Request for creating a Prompt log.",
        "properties": {
          "batches": {
            "docs": "Array of Batch Ids that this log is part of. Batches are used to group Logs together for offline Evaluations",
            "type": "optional<list<string>>",
          },
          "created_at": {
            "docs": "User defined timestamp for when the log was created. ",
            "type": "optional<datetime>",
          },
          "environment": {
            "docs": "The name of the Environment the Log is associated to.",
            "type": "optional<string>",
          },
          "error": {
            "docs": "Error message if the log is an error.",
            "type": "optional<string>",
          },
          "finish_reason": {
            "docs": "Reason the generation finished.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "Unique identifier for the Log.",
            "type": "string",
          },
          "inputs": {
            "docs": "The inputs passed to the prompt template.",
            "type": "optional<map<string, unknown>>",
          },
          "messages": {
            "docs": "The messages passed to the to provider chat endpoint.",
            "type": "optional<list<ChatMessage>>",
          },
          "metadata": {
            "docs": "Any additional metadata to record.",
            "type": "optional<map<string, unknown>>",
          },
          "output": {
            "docs": "Generated output from your model for the provided inputs. Can be \`None\` if logging an error, or if creating a parent Log with the intention to populate it later.",
            "type": "optional<string>",
          },
          "output_cost": {
            "docs": "Cost in dollars associated to the tokens in the output.",
            "type": "optional<double>",
          },
          "output_message": {
            "docs": "The message returned by the provider.",
            "type": "optional<ChatMessage>",
          },
          "output_tokens": {
            "docs": "Number of tokens in the output generated by the model.",
            "type": "optional<integer>",
          },
          "parent_id": {
            "docs": "Unique identifier for the parent Log in a Session. Should only be provided if \`session_id\` is provided. If provided, the Log will be nested under the parent Log within the Session.",
            "type": "optional<string>",
          },
          "prompt": {
            "docs": "Prompt details used to generate the log.",
            "type": "PromptResponse",
          },
          "prompt_cost": {
            "docs": "Cost in dollars associated to the tokens in the prompt.",
            "type": "optional<double>",
          },
          "prompt_tokens": {
            "docs": "Number of tokens in the prompt used to generate the output.",
            "type": "optional<integer>",
          },
          "provider_latency": {
            "docs": "Duration of the logged event in seconds.",
            "type": "optional<double>",
          },
          "provider_request": {
            "docs": "Raw request sent to provider.",
            "type": "optional<map<string, unknown>>",
          },
          "provider_response": {
            "docs": "Raw response received the provider.",
            "type": "optional<map<string, unknown>>",
          },
          "raw_output": {
            "docs": "Raw output from the provider.",
            "type": "optional<string>",
          },
          "save": {
            "default": true,
            "docs": "Whether the request/response payloads will be stored on Humanloop.",
            "type": "optional<boolean>",
          },
          "session_id": {
            "docs": "Unique identifier for the Session to associate the Log to. Allows you to record multiple Logs to a Session (using an ID kept by your internal systems) by passing the same \`session_id\` in subsequent log requests. ",
            "type": "optional<string>",
          },
          "source": {
            "docs": "Identifies where the model was called from.",
            "type": "optional<string>",
          },
          "source_datapoint_id": {
            "docs": "Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.",
            "type": "optional<string>",
          },
          "tool_choice": {
            "docs": "Controls how the model uses tools. The following options are supported: 
- \`'none'\` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt. 
- \`'auto'\` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt. 
- \`'required'\` means the model can decide to call one or more of the provided tools. 
- \`{'type': 'function', 'function': {name': <TOOL_NAME>}}\` forces the model to use the named function.",
            "type": "optional<PromptLogResponseToolChoice>",
          },
          "user": {
            "docs": "End-user ID related to the Log.",
            "type": "optional<string>",
          },
        },
      },
      "PromptLogResponseToolChoice": {
        "discriminated": false,
        "docs": "Controls how the model uses tools. The following options are supported: 
- \`'none'\` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt. 
- \`'auto'\` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt. 
- \`'required'\` means the model can decide to call one or more of the provided tools. 
- \`{'type': 'function', 'function': {name': <TOOL_NAME>}}\` forces the model to use the named function.",
        "union": [
          "literal<"none">",
          "literal<"auto">",
          "literal<"required">",
          "ToolChoice",
        ],
      },
      "PromptResponse": {
        "docs": "Request model for creating a new Prompt",
        "properties": {
          "commit_message": {
            "docs": "Message describing the changes made.",
            "type": "optional<string>",
          },
          "created_at": "datetime",
          "created_by": {
            "docs": "The user who created the Prompt.",
            "type": "optional<UserResponse>",
          },
          "directory_id": {
            "docs": "Unique identifier for the Directory of the Prompt. ",
            "type": "optional<string>",
          },
          "endpoint": {
            "docs": "The provider model endpoint used.",
            "type": "optional<ModelEndpoints>",
          },
          "environments": {
            "docs": "The list of environments the Prompt Version is deployed to.",
            "type": "optional<list<EnvironmentResponse>>",
          },
          "frequency_penalty": {
            "default": 0,
            "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "type": "optional<double>",
          },
          "id": {
            "docs": "Unique identifier for the Prompt.",
            "type": "string",
          },
          "inputs": {
            "docs": "Inputs associated to the Prompt. Inputs correspond to any of the variables used within the Prompt template.",
            "type": "list<InputResponse>",
          },
          "last_used_at": "datetime",
          "linked_tools": {
            "docs": "The IDs of the Tools in your organization that the model can choose to call if Tool calling is supported. The default deployed version of that tool is called.",
            "type": "optional<list<LinkedToolResponse>>",
          },
          "max_tokens": {
            "default": -1,
            "docs": "The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt",
            "type": "optional<integer>",
          },
          "model": {
            "docs": "The model instance used, e.g. \`gpt-4\`. See [supported models](https://humanloop.com/docs/supported-models)",
            "type": "string",
          },
          "name": {
            "docs": "Name of the Prompt, which is used as a unique identifier.",
            "type": "string",
          },
          "other": {
            "docs": "Other parameter values to be passed to the provider call.",
            "type": "optional<map<string, unknown>>",
          },
          "presence_penalty": {
            "default": 0,
            "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "type": "optional<double>",
          },
          "provider": {
            "docs": "The company providing the underlying model service.",
            "type": "optional<ModelProviders>",
          },
          "response_format": {
            "docs": "The format of the response. Only \`{"type": "json_object"}\` is currently supported for chat.",
            "type": "optional<ResponseFormat>",
          },
          "seed": {
            "docs": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed.",
            "type": "optional<integer>",
          },
          "status": {
            "docs": "The status of the Prompt Version.",
            "type": "VersionStatus",
          },
          "stop": {
            "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
            "type": "optional<PromptResponseStop>",
          },
          "temperature": {
            "default": 1,
            "docs": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "type": "optional<double>",
          },
          "template": {
            "docs": "For chat endpoint, provide a Chat template. For completion endpoint, provide a Prompt template. Input variables within the template should be specified with double curly bracket syntax: {{INPUT_NAME}}.",
            "type": "optional<Template>",
          },
          "tools": {
            "docs": "The tool specification that the model can choose to call if Tool calling is supported.",
            "type": "optional<list<ToolFunction>>",
          },
          "top_p": {
            "default": 1,
            "docs": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "type": "optional<double>",
          },
          "total_logs_count": {
            "docs": "The number of logs that have been generated across all Prompt Versions",
            "type": "integer",
          },
          "updated_at": "datetime",
          "version_id": {
            "docs": "Unique identifier for the specific Prompt Version. If no query params provided, the default deployed Prompt Version is returned.",
            "type": "string",
          },
          "version_logs_count": {
            "docs": "The number of logs that have been generated for this Prompt Version",
            "type": "integer",
          },
        },
      },
      "PromptResponseStop": {
        "discriminated": false,
        "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
        "union": [
          "string",
          "list<string>",
        ],
      },
      "ProviderApiKeys": {
        "docs": undefined,
        "properties": {
          "ai21": "optional<string>",
          "anthropic": "optional<string>",
          "cohere": "optional<string>",
          "mock": "optional<string>",
          "openai": "optional<string>",
          "openai_azure": "optional<string>",
          "openai_azure_endpoint": "optional<string>",
        },
      },
      "ResponseFormat": {
        "docs": "Response format of the model.",
        "properties": {
          "type": "literal<"json_object">",
        },
      },
      "SessionResponse": {
        "docs": undefined,
        "properties": {
          "created_at": "datetime",
          "id": {
            "docs": "Unique identifier for the Session.",
            "type": "string",
          },
          "logs": {
            "docs": "List of Logs associated with this Session.",
            "type": "list<PromptLogResponse>",
          },
          "updated_at": "datetime",
        },
      },
      "SortOrder": {
        "docs": "An enumeration.",
        "enum": [
          "asc",
          "desc",
        ],
      },
      "Spec": {
        "base-properties": {},
        "discriminant": "evaluator_type",
        "docs": undefined,
        "union": {
          "human": "HumanEvaluatorRequest",
          "llm": "LLMEvaluatorRequest",
          "python": "CodeEvaluatorRequest",
        },
      },
      "Template": {
        "discriminated": false,
        "docs": "For chat endpoint, provide a Chat template. For completion endpoint, provide a Prompt template. Input variables within the template should be specified with double curly bracket syntax: {{INPUT_NAME}}.",
        "union": [
          "string",
          "list<ChatMessage>",
        ],
      },
      "TextChatContent": {
        "docs": undefined,
        "properties": {
          "text": {
            "docs": "The message's text content.",
            "type": "string",
          },
        },
      },
      "TimeUnit": {
        "docs": "An enumeration.",
        "enum": [
          "day",
          "week",
          "month",
        ],
      },
      "ToolCall": {
        "docs": "A tool call to be made.",
        "properties": {
          "function": "FunctionTool",
          "id": "string",
          "type": "ToolType",
        },
      },
      "ToolChoice": {
        "docs": "Tool choice to force the model to use a tool.",
        "properties": {
          "function": "FunctionToolChoice",
          "type": "ToolType",
        },
      },
      "ToolConfigRequest": {
        "docs": "Definition of tool within a model config.

The subset of ToolConfig parameters received by the chat endpoint.
Does not have things like the signature or setup schema.",
        "properties": {
          "description": {
            "docs": "The description of the tool shown to the model.",
            "type": "optional<string>",
          },
          "name": {
            "docs": "The name of the tool shown to the model.",
            "type": "string",
          },
          "other": {
            "docs": "Other parameters that define the config.",
            "type": "optional<map<string, unknown>>",
          },
          "parameters": {
            "docs": "Definition of parameters needed to run the tool. Provided in jsonschema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
          "preset_name": {
            "docs": "If is_preset = true, this is the name of the preset tool on Humanloop. This is used as the key to look up the Humanloop runtime of the tool",
            "type": "optional<string>",
          },
          "source": {
            "docs": "Source of the tool. If defined at an organization level will be 'organization' else 'inline'.",
            "type": "optional<ToolSource>",
          },
          "source_code": {
            "docs": "Code source of the tool.",
            "type": "optional<string>",
          },
          "type": "literal<"tool">",
        },
      },
      "ToolConfigResponse": {
        "docs": undefined,
        "properties": {
          "created_by": {
            "docs": "The user who created the config.",
            "type": "optional<UserResponse>",
          },
          "description": {
            "docs": "Description of the tool referenced by the model",
            "type": "optional<string>",
          },
          "id": {
            "docs": "String ID of config. Starts with \`config_\`.",
            "type": "string",
          },
          "is_preset": {
            "docs": "Whether the tool is one where Humanloop defines runtime or not.",
            "type": "optional<boolean>",
          },
          "name": {
            "docs": "Name for the tool referenced by the model.",
            "type": "string",
          },
          "other": {
            "docs": "Other parameters that define the config.",
            "type": "optional<map<string, unknown>>",
          },
          "parameters": {
            "docs": "Definition of parameters needed to run the tool. Provided in jsonschema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
          "preset_name": {
            "docs": "If is_preset = true, this is the name of the preset tool on Humanloop. This is used as the key to lookup the Humanloop runtime of the tool",
            "type": "optional<string>",
          },
          "setup_schema": {
            "docs": "Definition of parameters needed to run the tool. Provided in jsonschema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
          "signature": {
            "docs": "The function signature of the tool when being called.",
            "type": "optional<string>",
          },
          "source": {
            "docs": "Source of the tool. If defined at an organization level will be 'organization' else 'inline'.",
            "type": "optional<ToolSource>",
          },
          "source_code": {
            "docs": "Code source of the tool.",
            "type": "optional<string>",
          },
          "status": {
            "docs": "Whether the config is committed or not.",
            "type": "string",
          },
        },
      },
      "ToolFunction": {
        "docs": undefined,
        "properties": {
          "description": {
            "docs": "Description of the tool referenced by the model",
            "type": "string",
          },
          "name": {
            "docs": "Name for the tool referenced by the model.",
            "type": "string",
          },
          "parameters": {
            "docs": "Parameters needed to run the Tool, defined in JSON Schema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
        },
      },
      "ToolKernelRequest": {
        "docs": undefined,
        "properties": {
          "function": {
            "docs": "Callable function specification of the Tool shown to the model for tool calling.",
            "type": "optional<ToolFunction>",
          },
          "setup_values": {
            "docs": "Values needed to setup the Tool, defined in JSON Schema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
          "source_code": {
            "docs": "Code source of the Tool.",
            "type": "optional<string>",
          },
        },
      },
      "ToolResponse": {
        "docs": "Request to create a new Tool.",
        "properties": {
          "commit_message": {
            "docs": "Message describing the changes made.",
            "type": "optional<string>",
          },
          "created_at": "datetime",
          "created_by": {
            "docs": "The user who created the Prompt.",
            "type": "optional<UserResponse>",
          },
          "directory_id": {
            "docs": "Unique identifier for the Directory of the Prompt. ",
            "type": "optional<string>",
          },
          "environments": {
            "docs": "The list of environments the Prompt Version is deployed to.",
            "type": "optional<list<EnvironmentResponse>>",
          },
          "function": {
            "docs": "Callable function specification of the Tool shown to the model for tool calling.",
            "type": "optional<ToolFunction>",
          },
          "id": {
            "docs": "Unique identifier for Tool.",
            "type": "string",
          },
          "inputs": {
            "docs": "Inputs associated to the Prompt. Inputs correspond to any of the variables used within the Prompt template.",
            "type": "list<InputResponse>",
          },
          "last_used_at": "datetime",
          "name": {
            "docs": "Name of the Tool, which is used as a unique identifier.",
            "type": "string",
          },
          "setup_values": {
            "docs": "Values needed to setup the Tool, defined in JSON Schema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
          "signature": {
            "docs": "Signature of the Tool.",
            "type": "optional<string>",
          },
          "source_code": {
            "docs": "Code source of the Tool.",
            "type": "optional<string>",
          },
          "status": {
            "docs": "The status of the Prompt Version.",
            "type": "VersionStatus",
          },
          "tool_type": {
            "docs": "Type of Tool.",
            "type": "optional<ToolType>",
          },
          "total_logs_count": {
            "docs": "The number of logs that have been generated across all Prompt Versions",
            "type": "integer",
          },
          "updated_at": "datetime",
          "version_id": {
            "docs": "Unique identifier for the specific Tool Version. If no query params provided, the default deployed Tool Version is returned.",
            "type": "string",
          },
          "version_logs_count": {
            "docs": "The number of logs that have been generated for this Prompt Version",
            "type": "integer",
          },
        },
      },
      "ToolResultResponse": {
        "docs": "A result from a tool used to populate the prompt template",
        "properties": {
          "id": "string",
          "name": "string",
          "result": "string",
          "signature": "string",
        },
      },
      "ToolSource": {
        "docs": "Source of tool. Used to differentiate between tools and tool versions when they are combined in a list.

V4 uses organization and inline. Those are deprecated and will be removed in favour of tool and tool_version.",
        "enum": [
          "organization",
          "inline",
        ],
      },
      "ToolTemplateResponse": {
        "docs": "Template for a Humanloop runnable tool.",
        "properties": {
          "description": {
            "docs": "Description of the tool referenced by the model",
            "type": "string",
          },
          "name": {
            "docs": "Name for the tool referenced by the model.",
            "type": "string",
          },
          "parameters": {
            "docs": "Parameters needed to run the Tool, defined in JSON Schema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
          "setup_schema": {
            "docs": "Schema required to setup the Tool runtime, e.g. API keys.",
            "type": "optional<map<string, unknown>>",
          },
          "signature": {
            "docs": "Signature of the Tool.",
            "type": "optional<string>",
          },
        },
      },
      "ToolType": {
        "docs": "Type of tool.",
        "enum": [
          "pinecone_search",
          "google",
          "mock",
          "snippet",
          "json_schema",
          "get_api_call",
        ],
      },
      "UpdateDatesetAction": {
        "docs": "An enumeration.",
        "enum": [
          "set",
          "add",
          "remove",
        ],
      },
      "UserResponse": {
        "docs": undefined,
        "properties": {
          "email_address": {
            "docs": "The User's email address.",
            "type": "string",
          },
          "full_name": {
            "docs": "The User's full name.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "Unique identifier for User. Starts with \`usr\`.",
            "type": "string",
          },
        },
      },
      "ValidationError": {
        "docs": undefined,
        "properties": {
          "loc": "list<ValidationErrorLocItem>",
          "msg": "string",
          "type": "string",
        },
      },
      "ValidationErrorLocItem": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "string",
          "integer",
        ],
      },
      "Value": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "boolean",
          "double",
        ],
      },
      "Version": {
        "discriminated": false,
        "docs": "The specific Version being referenced.",
        "union": [
          "PromptResponse",
          "ToolResponse",
          "DatasetResponse",
          "EvaluatorResponse",
        ],
      },
      "VersionDeploymentResponse": {
        "docs": "A variable reference to the Version deployed to an Environment",
        "properties": {
          "environment": {
            "docs": "The Environment that the Version is deployed to.",
            "type": "EnvironmentResponse",
          },
          "file": {
            "docs": "The File that the deployed Version belongs to.",
            "type": "File",
          },
        },
      },
      "VersionIdResponse": {
        "docs": "A reference to a specific Version by its ID",
        "properties": {
          "version": {
            "docs": "The specific Version being referenced.",
            "type": "Version",
          },
        },
      },
      "VersionReferenceResponse": {
        "base-properties": {},
        "discriminant": "type",
        "docs": undefined,
        "union": {
          "environment": "VersionDeploymentResponse",
          "version": "VersionIdResponse",
        },
      },
      "VersionStats": {
        "docs": "Stats for an Evaluated Version in the Evaluation Report.",
        "properties": {
          "evaluator_version_stats": {
            "docs": "Stats for each Evaluator Version used to evaluate this Evaluated Version.",
            "type": "list<VersionStatsEvaluatorVersionStatsItem>",
          },
          "num_logs": {
            "docs": "The total number of existing Logs for this Evaluated Version within the Evaluation Report. These are Logs that have been generated by this Evaluated Version on a Datapoint belonging to the Evaluation Report's Dataset Version.",
            "type": "integer",
          },
          "version_id": {
            "docs": "Unique identifier for the Evaluated Version.",
            "type": "string",
          },
        },
      },
      "VersionStatsEvaluatorVersionStatsItem": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "NumericEvaluatorVersionStats",
          "BooleanEvaluatorVersionStats",
        ],
      },
      "VersionStatus": {
        "docs": "An enumeration.",
        "enum": [
          "uncommitted",
          "committed",
          "deleted",
        ],
      },
    },
  },
  "rootApiFile": {
    "auth": "APIKeyHeader",
    "auth-schemes": {
      "APIKeyHeader": {
        "header": "X-API-KEY",
        "name": "apiKey",
        "type": "string",
      },
    },
    "default-environment": "Default",
    "display-name": "Humanloop API",
    "environments": {
      "Default": "https://api.humanloop.com/v5",
    },
    "error-discrimination": {
      "strategy": "status-code",
    },
    "name": "api",
  },
}
`;

exports[`open api ir to fern humanloop simple 1`] = `
{
  "definitionFiles": {
    "datasets.yml": {
      "docs": "Datasets are collections of input-output pairs that you can use within Humanloop for Evaluations.

#### What is a Dataset?

A Dataset is a collection of unique Datapoints. These Datapoints contain \`inputs\` and \`target\` fields. The \`inputs\`
are used to populate a Prompt's template and the \`target\` can be referenced by Evaluators to evaluate the quality of
the generated output.

Note that Humanloop automatically deduplicates Datapoints. If you try to add a Datapoint that already exists, it will
be ignored. If you intentionally want to add a duplicate Datapoint, you can add a unique identifier to the Datapoint's
inputs such as \`{_dedupe_id: <unique ID>}\`.

#### Creating Dataset versions

Datasets have immutable versions. To add/remove Datapoint to/from an existing version, use the **Create** endpoint
and specify \`action\` as \`"add"\` or \`"remove"\` respectively. You may also specify the \`version_id\` or \`environment\`
query parameters to identify the existing version to base the new version on. If neither is provided, the version
deployed to the default Environment will be used.

",
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "display-name": "Datasets",
        "endpoints": {
          "commit": {
            "auth": true,
            "display-name": "Commit",
            "docs": "Commit the Dataset Version with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                  "version_id": "version_id",
                },
                "request": {
                  "commit_message": "commit_message",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "datapoints": [
                      {
                        "id": "id",
                        "inputs": {
                          "key": "value",
                        },
                        "messages": [
                          {
                            "role": "user",
                          },
                        ],
                        "target": {
                          "key": "value",
                        },
                      },
                    ],
                    "datapoints_count": 1,
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "id": "id",
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "status": "uncommitted",
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/datasets/{id}/versions/{version_id}/commit",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Dataset.",
                "type": "string",
              },
              "version_id": {
                "docs": "Unique identifier for the specific version of the Dataset.",
                "type": "string",
              },
            },
            "request": {
              "body": "root.CommitRequest",
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.DatasetResponse",
            },
          },
          "create": {
            "auth": true,
            "display-name": "Create Dataset",
            "docs": "Create a Dataset.

Dataset have immutable versions. When you call this endpoint
with the same Dataset name but different parameters, a new version of
the Dataset will be created.

If you provide a commit message, then the new version will be committed;
otherwise it will be uncommitted. If you try to commit an already committed version,
an exception will be raised.

By default, the new Dataset version will be set to the list of Datapoints provided in
the request.
You can create a new version by adding or removing Datapoints from an existing version
by specifying \`action\` as \`add\` or \`remove\` respectively. In this case, you may specify
the \`version_id\` or \`environment\` query parameters to identify the existing version to base
the new version on. If neither is provided, the default deployed version will be used.

Humanloop also deduplicates Datapoints. If you try to add a Datapoint that already
exists, it will be ignored.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "request": {
                  "datapoints": [
                    {},
                  ],
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "datapoints": [
                      {
                        "id": "id",
                        "inputs": {
                          "key": "value",
                        },
                        "messages": [
                          {
                            "role": "user",
                          },
                        ],
                        "target": {
                          "key": "value",
                        },
                      },
                    ],
                    "datapoints_count": 1,
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "id": "id",
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "status": "uncommitted",
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/datasets",
            "request": {
              "body": {
                "properties": {
                  "action": {
                    "docs": "The action to take with the provided Datapoints.

 - If \`"set"\`, the created version will only contain the Datapoints provided in this request. 
 - If \`"add"\`, the created version will contain the Datapoints provided in this request in addition to the Datapoints in the target version. 
 - If \`"remove"\`, the created version will contain the Datapoints in the target version except for the Datapoints provided in this request. 

If \`"add"\` or \`"remove"\`, one of the \`version_id\` or \`environment\` query parameters may be provided.",
                    "type": "optional<root.UpdateDatesetAction>",
                  },
                  "commit_message": {
                    "docs": "Message describing the changes made. If provided, a committed version of the Dataset is created. Otherwise, an uncommitted version is created.",
                    "type": "optional<string>",
                  },
                  "datapoints": {
                    "docs": "The Datapoints to create this Dataset version with. Modify the \`action\` field to determine how these Datapoints are used.",
                    "type": "list<root.CreateDatapointRequest>",
                  },
                  "name": {
                    "docs": "Name of the Dataset, which is used as a unique identifier.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "DatasetRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag to identify a deployed Version to base the created Version on. Only used when \`action\` is \`"add"\` or \`"remove"\`.",
                  "type": "optional<string>",
                },
                "version_id": {
                  "docs": "ID of the specific Dataset version to base the created Version on. Only used when \`action\` is \`"add"\` or \`"remove"\`.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.DatasetResponse",
            },
          },
          "delete": {
            "auth": true,
            "display-name": "Delete Dataset",
            "docs": "Delete the Dataset with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
              },
            ],
            "method": "DELETE",
            "pagination": undefined,
            "path": "/datasets/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Dataset.",
                "type": "string",
              },
            },
          },
          "deploy": {
            "auth": true,
            "display-name": "Deploy",
            "docs": "Deploy Dataset to Environment.

Set the deployed Version for the specified Environment.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                  "version_id": "version_id",
                },
                "query-parameters": {
                  "environment_id": "environment_id",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "datapoints": [
                      {
                        "id": "id",
                        "inputs": {
                          "key": "value",
                        },
                        "messages": [
                          {
                            "role": "user",
                          },
                        ],
                        "target": {
                          "key": "value",
                        },
                      },
                    ],
                    "datapoints_count": 1,
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "id": "id",
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "status": "uncommitted",
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/datasets/{id}/versions/{version_id}/deploy",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Dataset.",
                "type": "string",
              },
              "version_id": {
                "docs": "Unique identifier for the specific version of the Dataset.",
                "type": "string",
              },
            },
            "request": {
              "name": "DeployDatasetsIdVersionsVersionIdDeployPostRequest",
              "query-parameters": {
                "environment_id": {
                  "docs": "Unique identifier for the Environment to deploy the Version to.",
                  "type": "string",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.DatasetResponse",
            },
          },
          "get": {
            "auth": true,
            "display-name": "Get Dataset",
            "docs": "Retrieve the Dataset with the given ID.

Unless \`include_datapoints\` is set to \`true\`, the response will not include
the Datapoints.
Use the List Datapoints endpoint (\`GET /{id}/datapoints\`) to efficiently
retrieve Datapoints for a large Dataset.

By default the deployed version of the Dataset is returned. Use the query parameters
\`version_id\` or \`environment\` to target a specific version of the Dataset.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "datapoints": [
                      {
                        "id": "id",
                        "inputs": {
                          "key": "value",
                        },
                        "messages": [
                          {
                            "role": "user",
                          },
                        ],
                        "target": {
                          "key": "value",
                        },
                      },
                    ],
                    "datapoints_count": 1,
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "id": "id",
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "status": "uncommitted",
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/datasets/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Dataset.",
                "type": "string",
              },
            },
            "request": {
              "name": "DatasetsGetRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag to retrieve a deployed Version from.",
                  "type": "optional<string>",
                },
                "include_datapoints": {
                  "docs": "If set to \`true\`, include all Datapoints in the response. Defaults to \`false\`. Consider using the paginated List Datapoints endpoint instead.",
                  "type": "optional<boolean>",
                },
                "version_id": {
                  "docs": "A specific Version ID of the Dataset to retrieve.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.DatasetResponse",
            },
          },
          "list": {
            "auth": true,
            "display-name": "List ",
            "docs": "Get a list of Datasets.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "response": {
                  "body": {
                    "page": 1,
                    "records": [
                      {
                        "commit_message": "commit_message",
                        "created_at": "2024-01-15T09:30:00Z",
                        "created_by": {
                          "email_address": "email_address",
                          "id": "id",
                        },
                        "datapoints": [
                          {
                            "id": "id",
                          },
                        ],
                        "datapoints_count": 1,
                        "environments": [
                          {
                            "created_at": "2024-01-15T09:30:00Z",
                            "id": "id",
                            "name": "name",
                            "tag": "default",
                          },
                        ],
                        "id": "id",
                        "last_used_at": "2024-01-15T09:30:00Z",
                        "name": "name",
                        "status": "uncommitted",
                        "updated_at": "2024-01-15T09:30:00Z",
                        "version_id": "version_id",
                      },
                    ],
                    "size": 1,
                    "total": 1,
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/datasets",
            "request": {
              "name": "DatasetsListRequest",
              "query-parameters": {
                "name": {
                  "docs": "Case-insensitive filter for Dataset name.",
                  "type": "optional<string>",
                },
                "order": {
                  "docs": "Direction to sort by.",
                  "type": "optional<root.SortOrder>",
                },
                "page": {
                  "docs": "Page offset for pagination.",
                  "type": "optional<integer>",
                },
                "size": {
                  "docs": "Page size for pagination. Number of Datasets to fetch.",
                  "type": "optional<integer>",
                },
                "sort_by": {
                  "docs": "Field to sort Datasets by",
                  "type": "optional<root.ProjectSortBy>",
                },
                "user_filter": {
                  "docs": "Case-insensitive filter for users in the Dataset. This filter matches against both email address and name of users.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PaginatedDataDatasetResponse",
            },
          },
          "listdatapoints": {
            "auth": true,
            "display-name": "List Datapoints",
            "docs": "List all Datapoints for the Dataset with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "page": 1,
                    "records": [
                      {
                        "id": "id",
                        "inputs": {
                          "key": "value",
                        },
                        "messages": [
                          {
                            "role": "user",
                          },
                        ],
                        "target": {
                          "key": "value",
                        },
                      },
                    ],
                    "size": 1,
                    "total": 1,
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/datasets/{id}/datapoints",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Dataset.",
                "type": "string",
              },
            },
            "request": {
              "name": "DatasetsListDatapointsRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag to retrieve a deployed Version from.",
                  "type": "optional<string>",
                },
                "page": {
                  "docs": "Page number for pagination.",
                  "type": "optional<integer>",
                },
                "size": {
                  "docs": "Page size for pagination. Number of Datapoints to fetch.",
                  "type": "optional<integer>",
                },
                "version_id": {
                  "docs": "A specific Version ID of the Dataset to retrieve.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PaginatedDataDatapointResponse",
            },
          },
          "listversions": {
            "auth": true,
            "display-name": "List Versions",
            "docs": "Get a list of the versions for a Dataset.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "records": [
                      {
                        "commit_message": "commit_message",
                        "created_at": "2024-01-15T09:30:00Z",
                        "created_by": {
                          "email_address": "email_address",
                          "id": "id",
                        },
                        "datapoints": [
                          {
                            "id": "id",
                          },
                        ],
                        "datapoints_count": 1,
                        "environments": [
                          {
                            "created_at": "2024-01-15T09:30:00Z",
                            "id": "id",
                            "name": "name",
                            "tag": "default",
                          },
                        ],
                        "id": "id",
                        "last_used_at": "2024-01-15T09:30:00Z",
                        "name": "name",
                        "status": "uncommitted",
                        "updated_at": "2024-01-15T09:30:00Z",
                        "version_id": "version_id",
                      },
                    ],
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/datasets/{id}/versions",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Dataset.",
                "type": "string",
              },
            },
            "request": {
              "name": "DatasetsListVersionsRequest",
              "query-parameters": {
                "environment": {
                  "docs": "Filter versions by environment tag. If no environment is provided, all versions are returned.",
                  "type": "optional<string>",
                },
                "evaluation_aggregates": "optional<boolean>",
                "status": {
                  "docs": "Filter versions by status: 'uncommitted', 'committed'. If no status is provided, all versions are returned.",
                  "type": "optional<root.VersionStatus>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ListDatasets",
            },
          },
          "update": {
            "auth": true,
            "display-name": "Update Dataset",
            "docs": "Update the Dataset with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {},
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "datapoints": [
                      {
                        "id": "id",
                        "inputs": {
                          "key": "value",
                        },
                        "messages": [
                          {
                            "role": "user",
                          },
                        ],
                        "target": {
                          "key": "value",
                        },
                      },
                    ],
                    "datapoints_count": 1,
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "id": "id",
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "status": "uncommitted",
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                  },
                },
              },
            ],
            "method": "PATCH",
            "pagination": undefined,
            "path": "/datasets/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Dataset.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "name": {
                    "docs": "Name of the Dataset, which is used as a unique identifier.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "UpdateDatasetRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.DatasetResponse",
            },
          },
        },
      },
    },
    "evaluations.yml": {
      "docs": "Evaluations help you measure the performance of your Prompts, Tools and LLM Evaluators.

An Evaluation consists of a Dataset, Evaluatees (i.e. Versions to evaluate), and Evaluators.
When an Evaluation is created, Humanloop will start generating Logs, iterating through Datapoints in the Dataset,
for each Evaluatee. The Evaluators will then be run on these Logs.

Aggregate stats can be viewed in the Humanloop app or retrieved with the **Get Evaluation Stats** endpoint.

Note that when an Evaluation is created, Humanloop will attempt to reuse any existing Logs for each Datapoint-Evaluatee
pair. This means that you can create multiple Evaluations without generating new Logs unnecessarily.

",
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "display-name": "Evaluations",
        "endpoints": {
          "create": {
            "auth": true,
            "display-name": "Create Evaluation",
            "docs": "Create an Evaluation.

Create a new Evaluation by specifying the Dataset, Evaluatees, and Evaluators.
Humanloop will automatically start generating Logs and running Evaluators.

To keep updated on the progress of the Evaluation, you can poll the Evaluation
and check its status.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "request": {
                  "dataset": {
                    "version_id": "version_id",
                  },
                  "evaluatees": [
                    {
                      "version_id": "version_id",
                    },
                  ],
                  "evaluators": [
                    {
                      "version_id": "version_id",
                    },
                  ],
                },
                "response": {
                  "body": {
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "dataset": {
                      "commit_message": "commit_message",
                      "created_at": "2024-01-15T09:30:00Z",
                      "created_by": {
                        "email_address": "email_address",
                        "full_name": "full_name",
                        "id": "id",
                      },
                      "datapoints": [
                        {
                          "id": "id",
                        },
                      ],
                      "datapoints_count": 1,
                      "environments": [
                        {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "name": "name",
                          "tag": "default",
                        },
                      ],
                      "id": "id",
                      "last_used_at": "2024-01-15T09:30:00Z",
                      "name": "name",
                      "status": "uncommitted",
                      "updated_at": "2024-01-15T09:30:00Z",
                      "version_id": "version_id",
                    },
                    "evaluatees": [
                      {
                        "batch_id": "batch_id",
                        "orchestrated": true,
                        "version": {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "inputs": [
                            {
                              "name": "name",
                            },
                          ],
                          "last_used_at": "2024-01-15T09:30:00Z",
                          "model": "model",
                          "name": "name",
                          "status": "uncommitted",
                          "total_logs_count": 1,
                          "updated_at": "2024-01-15T09:30:00Z",
                          "version_id": "version_id",
                          "version_logs_count": 1,
                        },
                      },
                    ],
                    "evaluators": [],
                    "id": "id",
                    "status": "pending",
                    "updated_at": "2024-01-15T09:30:00Z",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/evaluations",
            "request": {
              "body": "root.CreateEvaluationRequest",
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluationResponse",
            },
          },
          "delete": {
            "auth": true,
            "display-name": "Delete Evaluation",
            "docs": "Delete an Evaluation.

Remove an Evaluation from Humanloop. The Logs and Versions used in the Evaluation
will not be deleted.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
              },
            ],
            "method": "DELETE",
            "pagination": undefined,
            "path": "/evaluations/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluation.",
                "type": "string",
              },
            },
          },
          "get": {
            "auth": true,
            "display-name": "Get Evaluation",
            "docs": "Get an Evaluation.

Retrieve the Evaluation with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "dataset": {
                      "commit_message": "commit_message",
                      "created_at": "2024-01-15T09:30:00Z",
                      "created_by": {
                        "email_address": "email_address",
                        "full_name": "full_name",
                        "id": "id",
                      },
                      "datapoints": [
                        {
                          "id": "id",
                        },
                      ],
                      "datapoints_count": 1,
                      "environments": [
                        {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "name": "name",
                          "tag": "default",
                        },
                      ],
                      "id": "id",
                      "last_used_at": "2024-01-15T09:30:00Z",
                      "name": "name",
                      "status": "uncommitted",
                      "updated_at": "2024-01-15T09:30:00Z",
                      "version_id": "version_id",
                    },
                    "evaluatees": [
                      {
                        "batch_id": "batch_id",
                        "orchestrated": true,
                        "version": {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "inputs": [
                            {
                              "name": "name",
                            },
                          ],
                          "last_used_at": "2024-01-15T09:30:00Z",
                          "model": "model",
                          "name": "name",
                          "status": "uncommitted",
                          "total_logs_count": 1,
                          "updated_at": "2024-01-15T09:30:00Z",
                          "version_id": "version_id",
                          "version_logs_count": 1,
                        },
                      },
                    ],
                    "evaluators": [],
                    "id": "id",
                    "status": "pending",
                    "updated_at": "2024-01-15T09:30:00Z",
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/evaluations/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluation.",
                "type": "string",
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluationResponse",
            },
          },
          "getstats": {
            "auth": true,
            "display-name": "Get Evaluation Stats",
            "docs": "Get Evaluation Stats.

Retrieve aggregate stats for the specified Evaluation.
This includes the number of generated Logs for every evaluatee and Evaluator metrics
(such as the mean and percentiles for numeric Evaluators for every evaluatee).",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "overall_stats": {
                      "num_datapoints": 1,
                      "total_evaluator_logs": 1,
                      "total_logs": 1,
                    },
                    "version_stats": [
                      {
                        "evaluator_version_stats": [
                          {
                            "evaluator_version_id": "evaluator_version_id",
                            "mean": 0,
                            "num_errors": 1,
                            "num_judgments": 1,
                            "num_nulls": 1,
                            "percentiles": {
                              "0": -2.5,
                              "100": 2.5,
                              "25": -0.6745,
                              "50": 0,
                              "75": 0.6745,
                            },
                            "std": 1,
                            "total_logs": 1,
                          },
                        ],
                        "num_logs": 1,
                        "version_id": "version_id",
                      },
                    ],
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/evaluations/{id}/stats",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluation.",
                "type": "string",
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluationStats",
            },
          },
          "list": {
            "auth": true,
            "display-name": "List Evaluations for File",
            "docs": "List Evaluations for the given File.

Retrieve a list of Evaluations that evaluate versions of the specified File.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "query-parameters": {
                  "file_id": "file_id",
                },
                "response": {
                  "body": {
                    "page": 1,
                    "records": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "created_by": {
                          "email_address": "email_address",
                          "id": "id",
                        },
                        "dataset": {
                          "created_at": "2024-01-15T09:30:00Z",
                          "datapoints_count": 1,
                          "id": "id",
                          "last_used_at": "2024-01-15T09:30:00Z",
                          "name": "name",
                          "status": "uncommitted",
                          "updated_at": "2024-01-15T09:30:00Z",
                          "version_id": "version_id",
                        },
                        "evaluatees": [
                          {
                            "orchestrated": true,
                            "version": {
                              "created_at": "2024-01-15T09:30:00Z",
                              "id": "id",
                              "inputs": [
                                {
                                  "name": "name",
                                },
                              ],
                              "last_used_at": "2024-01-15T09:30:00Z",
                              "model": "model",
                              "name": "name",
                              "status": "uncommitted",
                              "total_logs_count": 1,
                              "updated_at": "2024-01-15T09:30:00Z",
                              "version_id": "version_id",
                              "version_logs_count": 1,
                            },
                          },
                        ],
                        "evaluators": [],
                        "id": "id",
                        "status": "pending",
                        "updated_at": "2024-01-15T09:30:00Z",
                      },
                    ],
                    "size": 1,
                    "total": 1,
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/evaluations",
            "request": {
              "name": "EvaluationsListRequest",
              "query-parameters": {
                "file_id": {
                  "docs": "Filter by File ID. If provided, only Evaluation for the specified File will be returned.",
                  "type": "string",
                },
                "page": {
                  "docs": "Page number for pagination.",
                  "type": "optional<integer>",
                },
                "size": {
                  "docs": "Page size for pagination. Number of Evaluations to fetch.",
                  "type": "optional<integer>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PaginatedDataEvaluationResponse",
            },
          },
          "update": {
            "auth": true,
            "display-name": "Update Evaluation",
            "docs": "Update an Evaluation.

Update the setup of an Evaluation by specifying the Dataset, Evaluatees, and Evaluators.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {
                  "dataset": {
                    "version_id": "version_id",
                  },
                  "evaluatees": [
                    {
                      "version_id": "version_id",
                    },
                  ],
                  "evaluators": [
                    {
                      "version_id": "version_id",
                    },
                  ],
                },
                "response": {
                  "body": {
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "dataset": {
                      "commit_message": "commit_message",
                      "created_at": "2024-01-15T09:30:00Z",
                      "created_by": {
                        "email_address": "email_address",
                        "full_name": "full_name",
                        "id": "id",
                      },
                      "datapoints": [
                        {
                          "id": "id",
                        },
                      ],
                      "datapoints_count": 1,
                      "environments": [
                        {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "name": "name",
                          "tag": "default",
                        },
                      ],
                      "id": "id",
                      "last_used_at": "2024-01-15T09:30:00Z",
                      "name": "name",
                      "status": "uncommitted",
                      "updated_at": "2024-01-15T09:30:00Z",
                      "version_id": "version_id",
                    },
                    "evaluatees": [
                      {
                        "batch_id": "batch_id",
                        "orchestrated": true,
                        "version": {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "inputs": [
                            {
                              "name": "name",
                            },
                          ],
                          "last_used_at": "2024-01-15T09:30:00Z",
                          "model": "model",
                          "name": "name",
                          "status": "uncommitted",
                          "total_logs_count": 1,
                          "updated_at": "2024-01-15T09:30:00Z",
                          "version_id": "version_id",
                          "version_logs_count": 1,
                        },
                      },
                    ],
                    "evaluators": [],
                    "id": "id",
                    "status": "pending",
                    "updated_at": "2024-01-15T09:30:00Z",
                  },
                },
              },
            ],
            "method": "PATCH",
            "pagination": undefined,
            "path": "/evaluations/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluation.",
                "type": "string",
              },
            },
            "request": {
              "body": "root.CreateEvaluationRequest",
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluationResponse",
            },
          },
          "updatestatus": {
            "auth": true,
            "display-name": "Update Status",
            "docs": "Update the status of an Evaluation.

Can be used to cancel a running Evaluation, or mark an Evaluation that uses external or human evaluators
as completed.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {
                  "status": "pending",
                },
                "response": {
                  "body": {
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "dataset": {
                      "commit_message": "commit_message",
                      "created_at": "2024-01-15T09:30:00Z",
                      "created_by": {
                        "email_address": "email_address",
                        "full_name": "full_name",
                        "id": "id",
                      },
                      "datapoints": [
                        {
                          "id": "id",
                        },
                      ],
                      "datapoints_count": 1,
                      "environments": [
                        {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "name": "name",
                          "tag": "default",
                        },
                      ],
                      "id": "id",
                      "last_used_at": "2024-01-15T09:30:00Z",
                      "name": "name",
                      "status": "uncommitted",
                      "updated_at": "2024-01-15T09:30:00Z",
                      "version_id": "version_id",
                    },
                    "evaluatees": [
                      {
                        "batch_id": "batch_id",
                        "orchestrated": true,
                        "version": {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "inputs": [
                            {
                              "name": "name",
                            },
                          ],
                          "last_used_at": "2024-01-15T09:30:00Z",
                          "model": "model",
                          "name": "name",
                          "status": "uncommitted",
                          "total_logs_count": 1,
                          "updated_at": "2024-01-15T09:30:00Z",
                          "version_id": "version_id",
                          "version_logs_count": 1,
                        },
                      },
                    ],
                    "evaluators": [],
                    "id": "id",
                    "status": "pending",
                    "updated_at": "2024-01-15T09:30:00Z",
                  },
                },
              },
            ],
            "method": "PATCH",
            "pagination": undefined,
            "path": "/evaluations/{id}/status",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluation.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "status": "root.EvaluationStatus",
                },
              },
              "headers": undefined,
              "name": "BodyEvaluationsUpdateStatus",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluationResponse",
            },
          },
        },
      },
    },
    "evaluators.yml": {
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "endpoints": {
          "commit": {
            "auth": true,
            "display-name": "Commit",
            "docs": "Commit the Evaluator Version with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/evaluators/{id}/versions/{version_id}/commit",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
              "version_id": {
                "docs": "Unique identifier for the specific version of the Evaluator.",
                "type": "string",
              },
            },
            "request": {
              "body": "root.CommitRequest",
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluatorResponse",
            },
          },
          "create": {
            "auth": true,
            "display-name": "Create Evaluator",
            "docs": "Create an Evaluator.

Evaluators have immutable versions. When you call this endpoint
with the same Evaluator name but different spec, a new version of
the Evaluator will be created.

If you provide a commit message, then the new version will be committed;
otherwise it will be uncommitted. If you try to commit an already committed version,
an exception will be raised.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/evaluators",
            "request": {
              "body": {
                "properties": {
                  "commit_message": {
                    "docs": "Message describing the changes made.",
                    "type": "optional<string>",
                  },
                  "directory_id": {
                    "docs": "Unique identifier for the Directory of the Evaluator.",
                    "type": "optional<string>",
                  },
                  "name": {
                    "docs": "Name of the Evaluator, which is used as a unique identifier.",
                    "type": "optional<string>",
                  },
                  "spec": "Spec",
                },
              },
              "headers": undefined,
              "name": "EvaluatorRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluatorResponse",
            },
          },
          "debug": {
            "auth": true,
            "display-name": "Debug",
            "docs": "Run a synchronous evaluator execution on a collection of datapoints.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/evaluators/debug",
            "request": {
              "body": {
                "properties": {
                  "datapoint_ids": {
                    "docs": "The IDs of the evaluation datapoints on which to run the draft evaluator. ",
                    "type": "optional<list<string>>",
                  },
                  "evaluator": "Evaluator",
                  "evaluator_version_id": {
                    "docs": "The ID of the Evaluator Version being debugged if it already exists and is being edited.",
                    "type": "optional<string>",
                  },
                  "file_id": {
                    "docs": "The ID of the Dataset that the datapoints belong to.",
                    "type": "string",
                  },
                  "log_ids": {
                    "docs": "The IDs of the logs on which to run the draft evaluator.Provide one of \`log_ids\` or \`datapoint_ids\`.",
                    "type": "optional<list<string>>",
                  },
                  "prompt_version_id": {
                    "docs": "The ID of the Prompt Version to use generate datapoints for the evaluation datapoints. Only required if \`datapoint\` is provided; has no effect otherwise.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "RunSyncEvaluationRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "list<root.EvaluationDebugResultResponse>",
            },
          },
          "delete": {
            "auth": true,
            "display-name": "Delete Evaluator",
            "docs": "Delete the Evaluator with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
              },
            ],
            "method": "DELETE",
            "pagination": undefined,
            "path": "/evaluators/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluator.",
                "type": "string",
              },
            },
          },
          "deploy": {
            "auth": true,
            "display-name": "Deploy",
            "docs": "Deploy Evaluator to Environment.

Set the deployed Version for the specified Environment. This Evaluator Version
will be used for calls made to the Evaluator in this Environment.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/evaluators/{id}/versions/{version_id}/deploy",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluator.",
                "type": "string",
              },
              "version_id": {
                "docs": "Unique identifier for the specific version of the Evaluator.",
                "type": "string",
              },
            },
            "request": {
              "name": "DeployEvaluatorsIdVersionsVersionIdDeployPostRequest",
              "query-parameters": {
                "environment_id": {
                  "docs": "Unique identifier for the Environment to deploy the Version to.",
                  "type": "string",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluatorResponse",
            },
          },
          "get": {
            "auth": true,
            "display-name": "Get Evaluator",
            "docs": "Retrieve the Evaluator with the given ID.

By default the deployed version of the Evaluator is returned. Use the query parameters
\`version_id\` or \`environment\` to target a specific version of the Evaluator.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/evaluators/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluator.",
                "type": "string",
              },
            },
            "request": {
              "name": "EvaluatorsGetRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag to retrieve a deployed Version from.",
                  "type": "optional<string>",
                },
                "version_id": {
                  "docs": "A specific Version Id  of the Evaluator to retrieve.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluatorResponse",
            },
          },
          "list": {
            "auth": true,
            "display-name": "List ",
            "docs": "Get a list of Evaluators.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "response": {
                  "body": {
                    "records": [],
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/evaluators",
            "request": {
              "name": "EvaluatorsListRequest",
              "query-parameters": {
                "name": {
                  "docs": "Case-insensitive filter for Evaluator name.",
                  "type": "optional<string>",
                },
                "order": {
                  "docs": "Direction to sort by.",
                  "type": "optional<root.SortOrder>",
                },
                "page": {
                  "docs": "Page offset for pagination.",
                  "type": "optional<integer>",
                },
                "size": {
                  "docs": "Page size for pagination. Number of Evaluators to fetch.",
                  "type": "optional<integer>",
                },
                "sort_by": {
                  "docs": "Field to sort Evaluators by",
                  "type": "optional<root.ProjectSortBy>",
                },
                "user_filter": {
                  "docs": "Case-insensitive filter for users in the Evaluator. This filter matches against both email address and name of users.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ListEvaluators",
            },
          },
          "listdefault": {
            "auth": true,
            "display-name": "List Default Evaluators",
            "docs": "Get a list of default evaluators for the organization.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "response": {
                  "body": [],
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/evaluators/default",
            "response": {
              "docs": "Successful Response",
              "type": "list<root.EvaluatorResponse>",
            },
          },
          "listversions": {
            "auth": true,
            "display-name": "List Versions",
            "docs": "Get a list of all the versions of an Evaluator.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "records": [],
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/evaluators/{id}/versions",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for the Evaluator.",
                "type": "string",
              },
            },
            "request": {
              "name": "EvaluatorsListVersionsRequest",
              "query-parameters": {
                "environment": {
                  "docs": "Filter versions by environment tag. If no environment is provided, all versions are returned.",
                  "type": "optional<string>",
                },
                "evaluation_aggregates": "optional<boolean>",
                "status": {
                  "docs": "Filter versions by status: 'uncommitted', 'committed'. If no status is provided, all versions are returned.",
                  "type": "optional<root.VersionStatus>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ListEvaluators",
            },
          },
          "update": {
            "auth": true,
            "display-name": "Update Evaluator",
            "docs": "Update the Evaluator with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "method": "PATCH",
            "pagination": undefined,
            "path": "/evaluators/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Evaluator.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "directory_id": {
                    "docs": "Unique identifier for the Directory of the Evaluator.",
                    "type": "optional<string>",
                  },
                  "name": {
                    "docs": "Name of the Evaluator, which is used as a unique identifier.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "UpdateEvaluatorRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.EvaluatorResponse",
            },
          },
        },
      },
      "types": {
        "Evaluator": {
          "base-properties": {},
          "discriminant": "evaluator_type",
          "docs": undefined,
          "union": {
            "human": "root.HumanEvaluatorRequest",
            "llm": "root.LLMEvaluatorRequest",
            "python": "root.CodeEvaluatorRequest",
          },
        },
        "Spec": {
          "base-properties": {},
          "discriminant": "evaluator_type",
          "docs": undefined,
          "union": {
            "human": "root.HumanEvaluatorRequest",
            "llm": "root.LLMEvaluatorRequest",
            "python": "root.CodeEvaluatorRequest",
          },
        },
      },
    },
    "logs.yml": {
      "docs": "Logs contain the inputs and outputs of each time a Prompt, Tool or Evaluator is called.

Humanloop automatically records the inputs and outputs when you Call a Prompt or Tool and saves a Log.
Evaluator Logs are also created when an Evaluator is run on a Log.

You can manually create Logs through the API.

...


",
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "display-name": "Logs",
        "endpoints": {
          "delete": {
            "auth": true,
            "display-name": "Delete",
            "docs": "Delete Logs with the given IDs.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "method": "DELETE",
            "pagination": undefined,
            "path": "/logs",
            "request": {
              "name": "LogsDeleteRequest",
              "query-parameters": {
                "id": {
                  "allow-multiple": true,
                  "docs": "Unique identifiers for the Logs to delete.",
                  "type": "optional<string>",
                },
              },
            },
          },
          "get": {
            "auth": true,
            "display-name": "Get Log",
            "docs": "Retrieve the Log with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "batches": [
                      "batches",
                    ],
                    "created_at": "2024-01-15T09:30:00Z",
                    "environment": "environment",
                    "error": "error",
                    "finish_reason": "finish_reason",
                    "id": "id",
                    "inputs": {
                      "key": "value",
                    },
                    "messages": [
                      {
                        "content": "content",
                        "name": "name",
                        "role": "user",
                        "tool_call_id": "tool_call_id",
                        "tool_calls": [
                          {
                            "function": {
                              "name": "name",
                            },
                            "id": "id",
                            "type": "function",
                          },
                        ],
                      },
                    ],
                    "metadata": {
                      "key": "value",
                    },
                    "output": "output",
                    "output_cost": 1.1,
                    "output_message": {
                      "content": "content",
                      "name": "name",
                      "role": "user",
                      "tool_call_id": "tool_call_id",
                      "tool_calls": [
                        {
                          "function": {
                            "name": "name",
                          },
                          "id": "id",
                          "type": "function",
                        },
                      ],
                    },
                    "output_tokens": 1,
                    "parent_id": "parent_id",
                    "prompt": {
                      "commit_message": "commit_message",
                      "created_at": "2024-01-15T09:30:00Z",
                      "created_by": {
                        "email_address": "email_address",
                        "full_name": "full_name",
                        "id": "id",
                      },
                      "directory_id": "directory_id",
                      "endpoint": "complete",
                      "environments": [
                        {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "name": "name",
                          "tag": "default",
                        },
                      ],
                      "frequency_penalty": 1.1,
                      "id": "id",
                      "inputs": [
                        {
                          "name": "name",
                        },
                      ],
                      "last_used_at": "2024-01-15T09:30:00Z",
                      "linked_tools": [
                        {
                          "description": "description",
                          "id": "id",
                          "name": "name",
                          "version_id": "version_id",
                        },
                      ],
                      "max_tokens": 1,
                      "model": "model",
                      "name": "name",
                      "other": {
                        "key": "value",
                      },
                      "presence_penalty": 1.1,
                      "provider": "openai",
                      "response_format": {
                        "type": "json_object",
                      },
                      "seed": 1,
                      "status": "uncommitted",
                      "stop": "stop",
                      "temperature": 1.1,
                      "template": "template",
                      "tools": [
                        {
                          "description": "description",
                          "name": "name",
                        },
                      ],
                      "top_p": 1.1,
                      "total_logs_count": 1,
                      "updated_at": "2024-01-15T09:30:00Z",
                      "version_id": "version_id",
                      "version_logs_count": 1,
                    },
                    "prompt_cost": 1.1,
                    "prompt_tokens": 1,
                    "provider_latency": 1.1,
                    "provider_request": {
                      "key": "value",
                    },
                    "provider_response": {
                      "key": "value",
                    },
                    "raw_output": "raw_output",
                    "save": true,
                    "session_id": "session_id",
                    "source": "source",
                    "source_datapoint_id": "source_datapoint_id",
                    "tool_choice": "none",
                    "user": "user",
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/logs/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Log.",
                "type": "string",
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PromptLogResponse",
            },
          },
          "listLogsForFile": {
            "auth": true,
            "display-name": "List",
            "docs": "List Logs.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "query-parameters": {
                  "file_id": "file_id",
                },
                "response": {
                  "body": {
                    "page": 1,
                    "records": [
                      {
                        "batches": [
                          "batches",
                        ],
                        "created_at": "2024-01-15T09:30:00Z",
                        "environment": "environment",
                        "error": "error",
                        "finish_reason": "finish_reason",
                        "id": "id",
                        "inputs": {
                          "key": "value",
                        },
                        "messages": [
                          {
                            "role": "user",
                          },
                        ],
                        "metadata": {
                          "key": "value",
                        },
                        "output": "output",
                        "output_cost": 1.1,
                        "output_message": {
                          "role": "user",
                        },
                        "output_tokens": 1,
                        "parent_id": "parent_id",
                        "prompt": {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "inputs": [
                            {
                              "name": "name",
                            },
                          ],
                          "last_used_at": "2024-01-15T09:30:00Z",
                          "model": "model",
                          "name": "name",
                          "status": "uncommitted",
                          "total_logs_count": 1,
                          "updated_at": "2024-01-15T09:30:00Z",
                          "version_id": "version_id",
                          "version_logs_count": 1,
                        },
                        "prompt_cost": 1.1,
                        "prompt_tokens": 1,
                        "provider_latency": 1.1,
                        "provider_request": {
                          "key": "value",
                        },
                        "provider_response": {
                          "key": "value",
                        },
                        "raw_output": "raw_output",
                        "save": true,
                        "session_id": "session_id",
                        "source": "source",
                        "source_datapoint_id": "source_datapoint_id",
                        "tool_choice": "none",
                        "user": "user",
                      },
                    ],
                    "size": 1,
                    "total": 1,
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/logs",
            "request": {
              "name": "ListLogsForFileLogsGetRequest",
              "query-parameters": {
                "end_date": {
                  "docs": "If provided, only Logs created before the specified date will be returned.",
                  "type": "optional<datetime>",
                },
                "file_id": {
                  "docs": "Unique identifier for the File to list Logs for.",
                  "type": "string",
                },
                "metadata_search": {
                  "docs": "If provided, only Logs that contain the provided string in its metadata will be returned.",
                  "type": "optional<string>",
                },
                "page": {
                  "docs": "Page number for pagination.",
                  "type": "optional<integer>",
                },
                "search": {
                  "docs": "If provided, only Logs that contain the provided string in its inputs and output will be returned.",
                  "type": "optional<string>",
                },
                "size": {
                  "docs": "Page size for pagination. Number of Logs to fetch.",
                  "type": "optional<integer>",
                },
                "start_date": {
                  "docs": "If provided, only Logs created after the specified date will be returned.",
                  "type": "optional<datetime>",
                },
                "version_id": {
                  "docs": "If provided, only Logs belonging to the specified Version will be returned.",
                  "type": "optional<string>",
                },
                "version_status": {
                  "docs": "If provided, only Logs belonging to Versions with the specified status will be returned.",
                  "type": "optional<root.VersionStatus>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PaginatedDataPromptLogResponse",
            },
          },
        },
      },
    },
    "prompts.yml": {
      "docs": "Prompts define how a large language model behaves.

#### What is a Prompt?

A Prompt on Humanloop encapsulates the instructions and other configuration for how a large language model should
perform a specific task.

Prompts have immutable versions that you can **Commit** and **Deploy**.
To use a Prompt, you can **Call** it to create a generation and you can **Log** generations manually.

#### Referencing a Prompt version

You can perform actions on a specific Prompt version by specifying either the \`version_id\`
or \`environment\` query parameter in the request. If you provide a \`version_id\`, Humanloop will
use the specified version of the Prompt. If you provide an \`environment\`, Humanloop will use the
version of the Prompt that is currently deployed to that Environment.
If you do not provide either a \`version_id\` or \`environment\`, Humanloop will use the Prompt version
that is deployed to the default Environment.

",
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "display-name": "Prompts",
        "endpoints": {
          "call": {
            "auth": true,
            "display-name": "Call",
            "docs": "Call a Prompt.

Calling a Prompt subsequently calls the model provider before logging
the data to Humanloop.

You can use query parameters version_id, or environment, to target
an existing version of the Prompt. Otherwise the default deployed version will be chosen.

Instead of targeting an existing version explicitly, you can instead pass in
Prompt details in the request body. In this case, we will check if the details correspond
to an existing version of the Prompt, if not we will create a new version. This is helpful
in the case where you are storing or deriving your Prompt details in code.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {},
                "response": {
                  "body": {
                    "batches": [
                      "batches",
                    ],
                    "environment": "environment",
                    "id": "id",
                    "inputs": {
                      "key": "value",
                    },
                    "logs": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "error": "error",
                        "finish_reason": "finish_reason",
                        "index": 1,
                        "output": "output",
                        "output_cost": 1.1,
                        "output_message": {
                          "role": "user",
                        },
                        "output_tokens": 1,
                        "prompt_cost": 1.1,
                        "prompt_tokens": 1,
                        "provider_latency": 1.1,
                        "raw_output": "raw_output",
                      },
                    ],
                    "messages": [
                      {
                        "content": "content",
                        "name": "name",
                        "role": "user",
                        "tool_call_id": "tool_call_id",
                        "tool_calls": [
                          {
                            "function": {
                              "name": "name",
                            },
                            "id": "id",
                            "type": "function",
                          },
                        ],
                      },
                    ],
                    "metadata": {
                      "key": "value",
                    },
                    "parent_id": "parent_id",
                    "prompt": {
                      "commit_message": "commit_message",
                      "created_at": "2024-01-15T09:30:00Z",
                      "created_by": {
                        "email_address": "email_address",
                        "full_name": "full_name",
                        "id": "id",
                      },
                      "directory_id": "directory_id",
                      "endpoint": "complete",
                      "environments": [
                        {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "name": "name",
                          "tag": "default",
                        },
                      ],
                      "frequency_penalty": 1.1,
                      "id": "id",
                      "inputs": [
                        {
                          "name": "name",
                        },
                      ],
                      "last_used_at": "2024-01-15T09:30:00Z",
                      "linked_tools": [
                        {
                          "description": "description",
                          "id": "id",
                          "name": "name",
                          "version_id": "version_id",
                        },
                      ],
                      "max_tokens": 1,
                      "model": "model",
                      "name": "name",
                      "other": {
                        "key": "value",
                      },
                      "presence_penalty": 1.1,
                      "provider": "openai",
                      "response_format": {
                        "type": "json_object",
                      },
                      "seed": 1,
                      "status": "uncommitted",
                      "stop": "stop",
                      "temperature": 1.1,
                      "template": "template",
                      "tools": [
                        {
                          "description": "description",
                          "name": "name",
                        },
                      ],
                      "top_p": 1.1,
                      "total_logs_count": 1,
                      "updated_at": "2024-01-15T09:30:00Z",
                      "version_id": "version_id",
                      "version_logs_count": 1,
                    },
                    "save": true,
                    "session_id": "session_id",
                    "source": "source",
                    "source_datapoint_id": "source_datapoint_id",
                    "tool_choice": "none",
                    "user": "user",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/prompts/{id}/call",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "batches": {
                    "docs": "Array of Batch Ids that this log is part of. Batches are used to group Logs together for offline Evaluations",
                    "type": "optional<list<string>>",
                  },
                  "environment": {
                    "docs": "The name of the Environment the Log is associated to.",
                    "name": "promptCallRequestEnvironment",
                    "type": "optional<string>",
                  },
                  "inputs": {
                    "docs": "The inputs passed to the prompt template.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "logprobs": {
                    "docs": "Include the log probabilities of the top n tokens in the provider_response",
                    "type": "optional<integer>",
                  },
                  "messages": {
                    "docs": "The messages passed to the to provider chat endpoint.",
                    "type": "optional<list<root.ChatMessage>>",
                  },
                  "metadata": {
                    "docs": "Any additional metadata to record.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "num_samples": {
                    "default": 1,
                    "docs": "The number of generations.",
                    "type": "optional<integer>",
                  },
                  "parent_id": {
                    "docs": "Unique identifier for the parent Log in a Session. Should only be provided if \`session_id\` is provided. If provided, the Log will be nested under the parent Log within the Session.",
                    "type": "optional<string>",
                  },
                  "prompt": {
                    "docs": "Details of your Prompt. A new Prompt version will be created if the provided details are new.",
                    "type": "optional<root.PromptKernelRequest>",
                  },
                  "provider_api_keys": {
                    "docs": "API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization.",
                    "type": "optional<root.ProviderApiKeys>",
                  },
                  "return_inputs": {
                    "default": true,
                    "docs": "Whether to return the inputs in the response. If false, the response will contain an empty dictionary under inputs. This is useful for reducing the size of the response. Defaults to true.",
                    "type": "optional<boolean>",
                  },
                  "save": {
                    "default": true,
                    "docs": "Whether the request/response payloads will be stored on Humanloop.",
                    "type": "optional<boolean>",
                  },
                  "session_id": {
                    "docs": "Unique identifier for the Session to associate the Log to. Allows you to record multiple Logs to a Session (using an ID kept by your internal systems) by passing the same \`session_id\` in subsequent log requests. ",
                    "type": "optional<string>",
                  },
                  "source": {
                    "docs": "Identifies where the model was called from.",
                    "type": "optional<string>",
                  },
                  "source_datapoint_id": {
                    "docs": "Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.",
                    "type": "optional<string>",
                  },
                  "stream": {
                    "default": false,
                    "docs": "If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.",
                    "type": "optional<boolean>",
                  },
                  "suffix": {
                    "docs": "The suffix that comes after a completion of inserted text. Useful for completions that act like inserts.",
                    "type": "optional<string>",
                  },
                  "tool_choice": {
                    "docs": "Controls how the model uses tools. The following options are supported: 
- \`'none'\` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt. 
- \`'auto'\` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt. 
- \`'required'\` means the model can decide to call one or more of the provided tools. 
- \`{'type': 'function', 'function': {name': <TOOL_NAME>}}\` forces the model to use the named function.",
                    "type": "optional<PromptCallRequestToolChoice>",
                  },
                  "user": {
                    "docs": "End-user ID related to the Log.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "PromptCallRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag of the deployed version to log to.",
                  "type": "optional<string>",
                },
                "version_id": {
                  "docs": "A specific version Id of the Prompt to log to.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "PromptsCallResponse",
            },
          },
          "commit": {
            "auth": true,
            "display-name": "Commit",
            "docs": "Commit the Prompt Version with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                  "version_id": "version_id",
                },
                "request": {
                  "commit_message": "commit_message",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "endpoint": "complete",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "frequency_penalty": 1.1,
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "linked_tools": [
                      {
                        "description": "description",
                        "id": "id",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                        "version_id": "version_id",
                      },
                    ],
                    "max_tokens": 1,
                    "model": "model",
                    "name": "name",
                    "other": {
                      "key": "value",
                    },
                    "presence_penalty": 1.1,
                    "provider": "openai",
                    "response_format": {
                      "type": "json_object",
                    },
                    "seed": 1,
                    "status": "uncommitted",
                    "stop": "stop",
                    "temperature": 1.1,
                    "template": "template",
                    "tools": [
                      {
                        "description": "description",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                      },
                    ],
                    "top_p": 1.1,
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/prompts/{id}/versions/{version_id}/commit",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
              "version_id": {
                "docs": "Unique identifier for the specific version of the Prompt.",
                "type": "string",
              },
            },
            "request": {
              "body": "root.CommitRequest",
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PromptResponse",
            },
          },
          "create": {
            "auth": true,
            "display-name": "Create Prompt",
            "docs": "Create a Prompt.

When you call this endpoint with the same Prompt name but different parameters,
a new version of the Prompt will be created.

If you provide a commit message, then the new version will be committed;
otherwise it will be uncommitted. If you try to commit an already committed version,
an exception will be raised.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "request": {
                  "model": "model",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "endpoint": "complete",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "frequency_penalty": 1.1,
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "linked_tools": [
                      {
                        "description": "description",
                        "id": "id",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                        "version_id": "version_id",
                      },
                    ],
                    "max_tokens": 1,
                    "model": "model",
                    "name": "name",
                    "other": {
                      "key": "value",
                    },
                    "presence_penalty": 1.1,
                    "provider": "openai",
                    "response_format": {
                      "type": "json_object",
                    },
                    "seed": 1,
                    "status": "uncommitted",
                    "stop": "stop",
                    "temperature": 1.1,
                    "template": "template",
                    "tools": [
                      {
                        "description": "description",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                      },
                    ],
                    "top_p": 1.1,
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/prompts",
            "request": {
              "body": {
                "properties": {
                  "commit_message": {
                    "docs": "Message describing the changes made.",
                    "type": "optional<string>",
                  },
                  "directory_id": {
                    "docs": "Unique identifier for the Directory of the Prompt. ",
                    "type": "optional<string>",
                  },
                  "endpoint": {
                    "docs": "The provider model endpoint used.",
                    "type": "optional<root.ModelEndpoints>",
                  },
                  "frequency_penalty": {
                    "default": 0,
                    "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
                    "type": "optional<double>",
                  },
                  "linked_tools": {
                    "docs": "The IDs of the Tools in your organization that the model can choose to call if Tool calling is supported. The default deployed version of that tool is called.",
                    "type": "optional<list<string>>",
                  },
                  "max_tokens": {
                    "default": -1,
                    "docs": "The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt",
                    "type": "optional<integer>",
                  },
                  "model": {
                    "docs": "The model instance used, e.g. \`gpt-4\`. See [supported models](https://humanloop.com/docs/supported-models)",
                    "type": "string",
                  },
                  "name": {
                    "docs": "Name of the Prompt, which is used as a unique identifier.",
                    "type": "optional<string>",
                  },
                  "other": {
                    "docs": "Other parameter values to be passed to the provider call.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "presence_penalty": {
                    "default": 0,
                    "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
                    "type": "optional<double>",
                  },
                  "provider": {
                    "docs": "The company providing the underlying model service.",
                    "type": "optional<root.ModelProviders>",
                  },
                  "response_format": {
                    "docs": "The format of the response. Only \`{"type": "json_object"}\` is currently supported for chat.",
                    "type": "optional<root.ResponseFormat>",
                  },
                  "seed": {
                    "docs": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed.",
                    "type": "optional<integer>",
                  },
                  "stop": {
                    "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
                    "type": "optional<PromptRequestStop>",
                  },
                  "temperature": {
                    "default": 1,
                    "docs": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
                    "type": "optional<double>",
                  },
                  "template": {
                    "docs": "For chat endpoint, provide a Chat template. For completion endpoint, provide a Prompt template. Input variables within the template should be specified with double curly bracket syntax: {{INPUT_NAME}}.",
                    "type": "optional<Template>",
                  },
                  "tools": {
                    "docs": "The tool specification that the model can choose to call if Tool calling is supported.",
                    "type": "optional<list<root.ToolFunction>>",
                  },
                  "top_p": {
                    "default": 1,
                    "docs": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
                    "type": "optional<double>",
                  },
                },
              },
              "headers": undefined,
              "name": "PromptRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PromptResponse",
            },
          },
          "delete": {
            "auth": true,
            "display-name": "Delete Prompt",
            "docs": "Delete the Prompt with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
              },
            ],
            "method": "DELETE",
            "pagination": undefined,
            "path": "/prompts/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
            },
          },
          "deploy": {
            "auth": true,
            "display-name": "Deploy",
            "docs": "Deploy Prompt to Environment.

Set the deployed Version for the specified Environment. This Prompt Version
will be used for calls made to the Prompt in this Environment.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                  "version_id": "version_id",
                },
                "query-parameters": {
                  "environment_id": "environment_id",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "endpoint": "complete",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "frequency_penalty": 1.1,
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "linked_tools": [
                      {
                        "description": "description",
                        "id": "id",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                        "version_id": "version_id",
                      },
                    ],
                    "max_tokens": 1,
                    "model": "model",
                    "name": "name",
                    "other": {
                      "key": "value",
                    },
                    "presence_penalty": 1.1,
                    "provider": "openai",
                    "response_format": {
                      "type": "json_object",
                    },
                    "seed": 1,
                    "status": "uncommitted",
                    "stop": "stop",
                    "temperature": 1.1,
                    "template": "template",
                    "tools": [
                      {
                        "description": "description",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                      },
                    ],
                    "top_p": 1.1,
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/prompts/{id}/versions/{version_id}/deploy",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
              "version_id": {
                "docs": "Unique identifier for the specific version of the Prompt.",
                "type": "string",
              },
            },
            "request": {
              "name": "DeployPromptsIdVersionsVersionIdDeployPostRequest",
              "query-parameters": {
                "environment_id": {
                  "docs": "Unique identifier for the Environment to deploy the Version to.",
                  "type": "string",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PromptResponse",
            },
          },
          "get": {
            "auth": true,
            "display-name": "Get Prompt",
            "docs": "Retrieve the Prompt with the given ID.

By default the deployed version of the Prompt is returned. Use the query parameters
\`version_id\` or \`environment\` to target a specific version of the Prompt.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "endpoint": "complete",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "frequency_penalty": 1.1,
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "linked_tools": [
                      {
                        "description": "description",
                        "id": "id",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                        "version_id": "version_id",
                      },
                    ],
                    "max_tokens": 1,
                    "model": "model",
                    "name": "name",
                    "other": {
                      "key": "value",
                    },
                    "presence_penalty": 1.1,
                    "provider": "openai",
                    "response_format": {
                      "type": "json_object",
                    },
                    "seed": 1,
                    "status": "uncommitted",
                    "stop": "stop",
                    "temperature": 1.1,
                    "template": "template",
                    "tools": [
                      {
                        "description": "description",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                      },
                    ],
                    "top_p": 1.1,
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/prompts/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
            },
            "request": {
              "name": "PromptsGetRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag to retrieve a deployed Version from.",
                  "type": "optional<string>",
                },
                "version_id": {
                  "docs": "A specific Version Id  of the Prompt to retrieve.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PromptResponse",
            },
          },
          "list": {
            "auth": true,
            "display-name": "List ",
            "docs": "Get a list of Prompts.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "response": {
                  "body": {
                    "records": [
                      {
                        "commit_message": "commit_message",
                        "created_at": "2024-01-15T09:30:00Z",
                        "created_by": {
                          "email_address": "email_address",
                          "id": "id",
                        },
                        "directory_id": "directory_id",
                        "endpoint": "complete",
                        "environments": [
                          {
                            "created_at": "2024-01-15T09:30:00Z",
                            "id": "id",
                            "name": "name",
                            "tag": "default",
                          },
                        ],
                        "frequency_penalty": 1.1,
                        "id": "id",
                        "inputs": [
                          {
                            "name": "name",
                          },
                        ],
                        "last_used_at": "2024-01-15T09:30:00Z",
                        "linked_tools": [
                          {
                            "description": "description",
                            "id": "id",
                            "name": "name",
                            "version_id": "version_id",
                          },
                        ],
                        "max_tokens": 1,
                        "model": "model",
                        "name": "name",
                        "other": {
                          "key": "value",
                        },
                        "presence_penalty": 1.1,
                        "provider": "openai",
                        "response_format": {
                          "type": "json_object",
                        },
                        "seed": 1,
                        "status": "uncommitted",
                        "stop": "stop",
                        "temperature": 1.1,
                        "template": "template",
                        "tools": [
                          {
                            "description": "description",
                            "name": "name",
                          },
                        ],
                        "top_p": 1.1,
                        "total_logs_count": 1,
                        "updated_at": "2024-01-15T09:30:00Z",
                        "version_id": "version_id",
                        "version_logs_count": 1,
                      },
                    ],
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/prompts",
            "request": {
              "name": "PromptsListRequest",
              "query-parameters": {
                "name": {
                  "docs": "Case-insensitive filter for Prompt name.",
                  "type": "optional<string>",
                },
                "order": {
                  "docs": "Direction to sort by.",
                  "type": "optional<root.SortOrder>",
                },
                "page": {
                  "docs": "Page number for pagination.",
                  "type": "optional<integer>",
                },
                "size": {
                  "docs": "Page size for pagination. Number of Prompts to fetch.",
                  "type": "optional<integer>",
                },
                "sort_by": {
                  "docs": "Field to sort Prompts by",
                  "type": "optional<root.ProjectSortBy>",
                },
                "user_filter": {
                  "docs": "Case-insensitive filter for users in the Prompt. This filter matches against both email address and name of users.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ListPrompts",
            },
          },
          "listversions": {
            "auth": true,
            "display-name": "List Versions",
            "docs": "Get a list of all the versions of a Prompt.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "records": [
                      {
                        "commit_message": "commit_message",
                        "created_at": "2024-01-15T09:30:00Z",
                        "created_by": {
                          "email_address": "email_address",
                          "id": "id",
                        },
                        "directory_id": "directory_id",
                        "endpoint": "complete",
                        "environments": [
                          {
                            "created_at": "2024-01-15T09:30:00Z",
                            "id": "id",
                            "name": "name",
                            "tag": "default",
                          },
                        ],
                        "frequency_penalty": 1.1,
                        "id": "id",
                        "inputs": [
                          {
                            "name": "name",
                          },
                        ],
                        "last_used_at": "2024-01-15T09:30:00Z",
                        "linked_tools": [
                          {
                            "description": "description",
                            "id": "id",
                            "name": "name",
                            "version_id": "version_id",
                          },
                        ],
                        "max_tokens": 1,
                        "model": "model",
                        "name": "name",
                        "other": {
                          "key": "value",
                        },
                        "presence_penalty": 1.1,
                        "provider": "openai",
                        "response_format": {
                          "type": "json_object",
                        },
                        "seed": 1,
                        "status": "uncommitted",
                        "stop": "stop",
                        "temperature": 1.1,
                        "template": "template",
                        "tools": [
                          {
                            "description": "description",
                            "name": "name",
                          },
                        ],
                        "top_p": 1.1,
                        "total_logs_count": 1,
                        "updated_at": "2024-01-15T09:30:00Z",
                        "version_id": "version_id",
                        "version_logs_count": 1,
                      },
                    ],
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/prompts/{id}/versions",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
            },
            "request": {
              "name": "PromptsListVersionsRequest",
              "query-parameters": {
                "environment": {
                  "docs": "Filter versions by environment tag. If no environment is provided, all versions are returned.",
                  "type": "optional<string>",
                },
                "evaluation_aggregates": "optional<boolean>",
                "status": {
                  "docs": "Filter versions by status: 'uncommitted', 'committed'. If no status is provided, all versions are returned.",
                  "type": "optional<root.VersionStatus>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ListPrompts",
            },
          },
          "log": {
            "auth": true,
            "display-name": "Log",
            "docs": "Log to a Prompt.

You can use query parameters version_id, or environment, to target
an existing version of the Prompt. Otherwise the default deployed version will be chosen.

Instead of targeting an existing version explicitly, you can instead pass in
Prompt details in the request body. In this case, we will check if the details correspond
to an existing version of the Prompt, if not we will create a new version. This is helpful
in the case where you are storing or deriving your Prompt details in code.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {},
                "response": {
                  "body": {
                    "id": "id",
                    "prompt_id": "prompt_id",
                    "session_id": "session_id",
                    "version_id": "version_id",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/prompts/{id}/log",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "batches": {
                    "docs": "Array of Batch Ids that this log is part of. Batches are used to group Logs together for offline Evaluations",
                    "type": "optional<list<string>>",
                  },
                  "created_at": {
                    "docs": "User defined timestamp for when the log was created. ",
                    "type": "optional<datetime>",
                  },
                  "environment": {
                    "docs": "The name of the Environment the Log is associated to.",
                    "name": "promptLogRequestEnvironment",
                    "type": "optional<string>",
                  },
                  "error": {
                    "docs": "Error message if the log is an error.",
                    "type": "optional<string>",
                  },
                  "finish_reason": {
                    "docs": "Reason the generation finished.",
                    "type": "optional<string>",
                  },
                  "inputs": {
                    "docs": "The inputs passed to the prompt template.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "messages": {
                    "docs": "The messages passed to the to provider chat endpoint.",
                    "type": "optional<list<root.ChatMessage>>",
                  },
                  "metadata": {
                    "docs": "Any additional metadata to record.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "output": {
                    "docs": "Generated output from your model for the provided inputs. Can be \`None\` if logging an error, or if creating a parent Log with the intention to populate it later.",
                    "type": "optional<string>",
                  },
                  "output_cost": {
                    "docs": "Cost in dollars associated to the tokens in the output.",
                    "type": "optional<double>",
                  },
                  "output_message": {
                    "docs": "The message returned by the provider.",
                    "type": "optional<root.ChatMessage>",
                  },
                  "output_tokens": {
                    "docs": "Number of tokens in the output generated by the model.",
                    "type": "optional<integer>",
                  },
                  "parent_id": {
                    "docs": "Unique identifier for the parent Log in a Session. Should only be provided if \`session_id\` is provided. If provided, the Log will be nested under the parent Log within the Session.",
                    "type": "optional<string>",
                  },
                  "prompt": {
                    "docs": "Details of your Prompt. A new Prompt version will be created if the provided details are new.",
                    "type": "optional<root.PromptKernelRequest>",
                  },
                  "prompt_cost": {
                    "docs": "Cost in dollars associated to the tokens in the prompt.",
                    "type": "optional<double>",
                  },
                  "prompt_tokens": {
                    "docs": "Number of tokens in the prompt used to generate the output.",
                    "type": "optional<integer>",
                  },
                  "provider_latency": {
                    "docs": "Duration of the logged event in seconds.",
                    "type": "optional<double>",
                  },
                  "provider_request": {
                    "docs": "Raw request sent to provider.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "provider_response": {
                    "docs": "Raw response received the provider.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "raw_output": {
                    "docs": "Raw output from the provider.",
                    "type": "optional<string>",
                  },
                  "save": {
                    "default": true,
                    "docs": "Whether the request/response payloads will be stored on Humanloop.",
                    "type": "optional<boolean>",
                  },
                  "session_id": {
                    "docs": "Unique identifier for the Session to associate the Log to. Allows you to record multiple Logs to a Session (using an ID kept by your internal systems) by passing the same \`session_id\` in subsequent log requests. ",
                    "type": "optional<string>",
                  },
                  "source": {
                    "docs": "Identifies where the model was called from.",
                    "type": "optional<string>",
                  },
                  "source_datapoint_id": {
                    "docs": "Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.",
                    "type": "optional<string>",
                  },
                  "tool_choice": {
                    "docs": "Controls how the model uses tools. The following options are supported: 
- \`'none'\` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt. 
- \`'auto'\` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt. 
- \`'required'\` means the model can decide to call one or more of the provided tools. 
- \`{'type': 'function', 'function': {name': <TOOL_NAME>}}\` forces the model to use the named function.",
                    "type": "optional<PromptLogRequestToolChoice>",
                  },
                  "user": {
                    "docs": "End-user ID related to the Log.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "PromptLogRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag of the deployed version to log to.",
                  "type": "optional<string>",
                },
                "version_id": {
                  "docs": "A specific version Id of the Prompt to log to.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.CreatePromptLogResponse",
            },
          },
          "update": {
            "auth": true,
            "display-name": "Update Prompt",
            "docs": "Update the Prompt with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {},
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "endpoint": "complete",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "frequency_penalty": 1.1,
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "linked_tools": [
                      {
                        "description": "description",
                        "id": "id",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                        "version_id": "version_id",
                      },
                    ],
                    "max_tokens": 1,
                    "model": "model",
                    "name": "name",
                    "other": {
                      "key": "value",
                    },
                    "presence_penalty": 1.1,
                    "provider": "openai",
                    "response_format": {
                      "type": "json_object",
                    },
                    "seed": 1,
                    "status": "uncommitted",
                    "stop": "stop",
                    "temperature": 1.1,
                    "template": "template",
                    "tools": [
                      {
                        "description": "description",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                      },
                    ],
                    "top_p": 1.1,
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "PATCH",
            "pagination": undefined,
            "path": "/prompts/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Prompt.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "directory_id": {
                    "docs": "Unique identifier for the Directory of the Prompt. ",
                    "type": "optional<string>",
                  },
                  "name": {
                    "docs": "Name of the Prompt, which is used as a unique identifier.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "UpdatePromptRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PromptResponse",
            },
          },
          "updateEvaluators": {
            "auth": true,
            "display-name": "Update Evaluators",
            "docs": "Activate and deactivate Evaluators for the Prompt.

An activated Evaluator will automatically be run on all new Logs
within the Prompt for monitoring purposes.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {},
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "endpoint": "complete",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "frequency_penalty": 1.1,
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "linked_tools": [
                      {
                        "description": "description",
                        "id": "id",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                        "version_id": "version_id",
                      },
                    ],
                    "max_tokens": 1,
                    "model": "model",
                    "name": "name",
                    "other": {
                      "key": "value",
                    },
                    "presence_penalty": 1.1,
                    "provider": "openai",
                    "response_format": {
                      "type": "json_object",
                    },
                    "seed": 1,
                    "status": "uncommitted",
                    "stop": "stop",
                    "temperature": 1.1,
                    "template": "template",
                    "tools": [
                      {
                        "description": "description",
                        "name": "name",
                        "parameters": {
                          "key": "value",
                        },
                      },
                    ],
                    "top_p": 1.1,
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/prompts/{id}/evaluators",
            "path-parameters": {
              "id": "string",
            },
            "request": {
              "body": "root.EvaluatorActivationDeactivationRequest",
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PromptResponse",
            },
          },
        },
      },
      "types": {
        "PromptCallRequestToolChoice": {
          "discriminated": false,
          "docs": "Controls how the model uses tools. The following options are supported: 
- \`'none'\` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt. 
- \`'auto'\` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt. 
- \`'required'\` means the model can decide to call one or more of the provided tools. 
- \`{'type': 'function', 'function': {name': <TOOL_NAME>}}\` forces the model to use the named function.",
          "union": [
            "literal<"none">",
            "literal<"auto">",
            "literal<"required">",
            "root.ToolChoice",
          ],
        },
        "PromptLogRequestToolChoice": {
          "discriminated": false,
          "docs": "Controls how the model uses tools. The following options are supported: 
- \`'none'\` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt. 
- \`'auto'\` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt. 
- \`'required'\` means the model can decide to call one or more of the provided tools. 
- \`{'type': 'function', 'function': {name': <TOOL_NAME>}}\` forces the model to use the named function.",
          "union": [
            "literal<"none">",
            "literal<"auto">",
            "literal<"required">",
            "root.ToolChoice",
          ],
        },
        "PromptRequestStop": {
          "discriminated": false,
          "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
          "union": [
            "string",
            "list<string>",
          ],
        },
        "PromptsCallResponse": {
          "discriminated": false,
          "docs": undefined,
          "union": [
            "root.PromptCallResponse",
            "root.PromptCallStreamResponse",
          ],
        },
        "Template": {
          "discriminated": false,
          "docs": "For chat endpoint, provide a Chat template. For completion endpoint, provide a Prompt template. Input variables within the template should be specified with double curly bracket syntax: {{INPUT_NAME}}.",
          "union": [
            "string",
            "list<root.ChatMessage>",
          ],
        },
      },
    },
    "sessions.yml": {
      "docs": "Sessions are groups of Logs that track sequences of LLM actions.

Sessions enable you to trace through related Logs across different Files. For
example, a Session can contain a Prompt Log recording an LLM generation, a Tool
Log recording a retrieval step, and Evaluator Logs measuring the quality of the
generated text.

Logs within a Session may be nested within each other. When Evaluators are run
for monitoring, the Evaluator Logs are added to the Session that the evaluated
Log is in, nested within the evaluated Log.

",
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "display-name": "Sessions",
        "endpoints": {
          "delete": {
            "auth": true,
            "display-name": "Delete",
            "docs": "Delete the Session with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
              },
            ],
            "method": "DELETE",
            "pagination": undefined,
            "path": "/sessions/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Session.",
                "type": "string",
              },
            },
          },
          "get": {
            "auth": true,
            "display-name": "Get",
            "docs": "Retrieve the Session with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "created_at": "2024-01-15T09:30:00Z",
                    "id": "id",
                    "logs": [
                      {
                        "batches": [
                          "batches",
                        ],
                        "created_at": "2024-01-15T09:30:00Z",
                        "environment": "environment",
                        "error": "error",
                        "finish_reason": "finish_reason",
                        "id": "id",
                        "inputs": {
                          "key": "value",
                        },
                        "messages": [
                          {
                            "role": "user",
                          },
                        ],
                        "metadata": {
                          "key": "value",
                        },
                        "output": "output",
                        "output_cost": 1.1,
                        "output_message": {
                          "role": "user",
                        },
                        "output_tokens": 1,
                        "parent_id": "parent_id",
                        "prompt": {
                          "created_at": "2024-01-15T09:30:00Z",
                          "id": "id",
                          "inputs": [
                            {
                              "name": "name",
                            },
                          ],
                          "last_used_at": "2024-01-15T09:30:00Z",
                          "model": "model",
                          "name": "name",
                          "status": "uncommitted",
                          "total_logs_count": 1,
                          "updated_at": "2024-01-15T09:30:00Z",
                          "version_id": "version_id",
                          "version_logs_count": 1,
                        },
                        "prompt_cost": 1.1,
                        "prompt_tokens": 1,
                        "provider_latency": 1.1,
                        "provider_request": {
                          "key": "value",
                        },
                        "provider_response": {
                          "key": "value",
                        },
                        "raw_output": "raw_output",
                        "save": true,
                        "session_id": "session_id",
                        "source": "source",
                        "source_datapoint_id": "source_datapoint_id",
                        "tool_choice": "none",
                        "user": "user",
                      },
                    ],
                    "updated_at": "2024-01-15T09:30:00Z",
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/sessions/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Session.",
                "type": "string",
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.SessionResponse",
            },
          },
          "list": {
            "auth": true,
            "display-name": "List ",
            "docs": "Get a list of Sessions.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "response": {
                  "body": {
                    "page": 1,
                    "records": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "logs": [
                          {
                            "id": "id",
                            "prompt": {
                              "created_at": "2024-01-15T09:30:00Z",
                              "id": "id",
                              "inputs": [
                                {
                                  "name": "name",
                                },
                              ],
                              "last_used_at": "2024-01-15T09:30:00Z",
                              "model": "model",
                              "name": "name",
                              "status": "uncommitted",
                              "total_logs_count": 1,
                              "updated_at": "2024-01-15T09:30:00Z",
                              "version_id": "version_id",
                              "version_logs_count": 1,
                            },
                          },
                        ],
                        "updated_at": "2024-01-15T09:30:00Z",
                      },
                    ],
                    "size": 1,
                    "total": 1,
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/sessions",
            "request": {
              "name": "SessionsListRequest",
              "query-parameters": {
                "file_id": {
                  "docs": "Unique identifier for File to return Sessions for. Sessions that contain any Logs associated to this File will be returned.",
                  "type": "optional<string>",
                },
                "page": {
                  "docs": "Page number for pagination.",
                  "type": "optional<integer>",
                },
                "size": {
                  "docs": "Page size for pagination. Number of Sessions to fetch.",
                  "type": "optional<integer>",
                },
                "version_id": {
                  "docs": "Unique identifier for Version to return Sessions for. Sessions that contain any Logs associated to this Version will be returned.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.PaginatedDataSessionResponse",
            },
          },
        },
      },
    },
    "tools.yml": {
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "endpoints": {
          "commit": {
            "auth": true,
            "display-name": "Commit",
            "docs": "Commit the Tool Version with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                  "version_id": "version_id",
                },
                "request": {
                  "commit_message": "commit_message",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "function": {
                      "description": "description",
                      "name": "name",
                      "parameters": {
                        "key": "value",
                      },
                    },
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "setup_values": {
                      "key": "value",
                    },
                    "signature": "signature",
                    "source_code": "source_code",
                    "status": "uncommitted",
                    "tool_type": "pinecone_search",
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/tools/{id}/versions/{version_id}/commit",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Tool.",
                "type": "string",
              },
              "version_id": {
                "docs": "Unique identifier for the specific version of the Tool.",
                "type": "string",
              },
            },
            "request": {
              "body": "root.CommitRequest",
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ToolResponse",
            },
          },
          "create": {
            "auth": true,
            "display-name": "Create Tool",
            "docs": "Create a Tool.

Tools have immutable versions. When you call this endpoint
with the same Tool name but different parameters, a new version of
the Tool will be created.

If you provide a commit message, then the new version will be committed;
otherwise it will be uncommitted. If you try to commit an already committed version,
an exception will be raised.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "request": {},
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "function": {
                      "description": "description",
                      "name": "name",
                      "parameters": {
                        "key": "value",
                      },
                    },
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "setup_values": {
                      "key": "value",
                    },
                    "signature": "signature",
                    "source_code": "source_code",
                    "status": "uncommitted",
                    "tool_type": "pinecone_search",
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/tools",
            "request": {
              "body": {
                "properties": {
                  "commit_message": {
                    "docs": "Message describing the changes made.",
                    "type": "optional<string>",
                  },
                  "directory_id": {
                    "docs": "Unique identifier for the Directory of the Prompt. ",
                    "type": "optional<string>",
                  },
                  "function": {
                    "docs": "Callable function specification of the Tool shown to the model for tool calling.",
                    "type": "optional<root.ToolFunction>",
                  },
                  "name": {
                    "docs": "Name of the Tool, which is used as a unique identifier.",
                    "type": "optional<string>",
                  },
                  "setup_values": {
                    "docs": "Values needed to setup the Tool, defined in JSON Schema format: https://json-schema.org/",
                    "type": "optional<map<string, unknown>>",
                  },
                  "source_code": {
                    "docs": "Code source of the Tool.",
                    "type": "optional<string>",
                  },
                  "tool_type": {
                    "docs": "Type of Tool.",
                    "type": "optional<root.ToolType>",
                  },
                },
              },
              "headers": undefined,
              "name": "ToolRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ToolResponse",
            },
          },
          "delete": {
            "auth": true,
            "display-name": "Delete Tool",
            "docs": "Delete the Tool with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
              },
            ],
            "method": "DELETE",
            "pagination": undefined,
            "path": "/tools/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Tool.",
                "type": "string",
              },
            },
          },
          "deploy": {
            "auth": true,
            "display-name": "Deploy",
            "docs": "Deploy Tool to Environment.

Set the deployed Version for the specified Environment. This Tool Version
will be used for calls made to the Tool in this Environment.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                  "version_id": "version_id",
                },
                "query-parameters": {
                  "environment_id": "environment_id",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "function": {
                      "description": "description",
                      "name": "name",
                      "parameters": {
                        "key": "value",
                      },
                    },
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "setup_values": {
                      "key": "value",
                    },
                    "signature": "signature",
                    "source_code": "source_code",
                    "status": "uncommitted",
                    "tool_type": "pinecone_search",
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/tools/{id}/versions/{version_id}/deploy",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Tool.",
                "type": "string",
              },
              "version_id": {
                "docs": "Unique identifier for the specific version of the Tool.",
                "type": "string",
              },
            },
            "request": {
              "name": "DeployToolsIdVersionsVersionIdDeployPostRequest",
              "query-parameters": {
                "environment_id": {
                  "docs": "Unique identifier for the Environment to deploy the Version to.",
                  "type": "string",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ToolResponse",
            },
          },
          "get": {
            "auth": true,
            "display-name": "Get Tool",
            "docs": "Retrieve the Tool with the given ID.

By default the deployed version of the Tool is returned. Use the query parameters
\`version_id\` or \`environment\` to target a specific version of the Tool.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "function": {
                      "description": "description",
                      "name": "name",
                      "parameters": {
                        "key": "value",
                      },
                    },
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "setup_values": {
                      "key": "value",
                    },
                    "signature": "signature",
                    "source_code": "source_code",
                    "status": "uncommitted",
                    "tool_type": "pinecone_search",
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/tools/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Tool.",
                "type": "string",
              },
            },
            "request": {
              "name": "ToolsGetRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag to retrieve a deployed Version from.",
                  "type": "optional<string>",
                },
                "version_id": {
                  "docs": "A specific Version Id  of the Tool to retrieve.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ToolResponse",
            },
          },
          "list": {
            "auth": true,
            "display-name": "List ",
            "docs": "Get a list of Tools.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "response": {
                  "body": {
                    "records": [
                      {
                        "commit_message": "commit_message",
                        "created_at": "2024-01-15T09:30:00Z",
                        "created_by": {
                          "email_address": "email_address",
                          "id": "id",
                        },
                        "directory_id": "directory_id",
                        "environments": [
                          {
                            "created_at": "2024-01-15T09:30:00Z",
                            "id": "id",
                            "name": "name",
                            "tag": "default",
                          },
                        ],
                        "function": {
                          "description": "description",
                          "name": "name",
                        },
                        "id": "id",
                        "inputs": [
                          {
                            "name": "name",
                          },
                        ],
                        "last_used_at": "2024-01-15T09:30:00Z",
                        "name": "name",
                        "setup_values": {
                          "key": "value",
                        },
                        "signature": "signature",
                        "source_code": "source_code",
                        "status": "uncommitted",
                        "tool_type": "pinecone_search",
                        "total_logs_count": 1,
                        "updated_at": "2024-01-15T09:30:00Z",
                        "version_id": "version_id",
                        "version_logs_count": 1,
                      },
                    ],
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/tools",
            "request": {
              "name": "ToolsListRequest",
              "query-parameters": {
                "name": {
                  "docs": "Case-insensitive filter for Tool name.",
                  "type": "optional<string>",
                },
                "order": {
                  "docs": "Direction to sort by.",
                  "type": "optional<root.SortOrder>",
                },
                "page": {
                  "docs": "Page offset for pagination.",
                  "type": "optional<integer>",
                },
                "size": {
                  "docs": "Page size for pagination. Number of Tools to fetch.",
                  "type": "optional<integer>",
                },
                "sort_by": {
                  "docs": "Field to sort Tools by",
                  "type": "optional<root.ProjectSortBy>",
                },
                "user_filter": {
                  "docs": "Case-insensitive filter for users in the Tool. This filter matches against both email address and name of users.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ListTools",
            },
          },
          "listTemplates": {
            "auth": true,
            "display-name": "List Templates",
            "docs": undefined,
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "response": {
                  "body": [
                    {
                      "description": "description",
                      "name": "name",
                      "parameters": {
                        "key": "value",
                      },
                      "setup_schema": {
                        "key": "value",
                      },
                      "signature": "signature",
                    },
                  ],
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/tools/templates",
            "request": {
              "name": "ListTemplatesToolsTemplatesGetRequest",
              "query-parameters": {
                "tool_type": {
                  "docs": "Type of tool to return the template",
                  "type": "optional<root.ToolType>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "list<root.ToolTemplateResponse>",
            },
          },
          "listversions": {
            "auth": true,
            "display-name": "List Versions",
            "docs": "Get a list of all the versions of a Tool.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "response": {
                  "body": {
                    "records": [
                      {
                        "commit_message": "commit_message",
                        "created_at": "2024-01-15T09:30:00Z",
                        "created_by": {
                          "email_address": "email_address",
                          "id": "id",
                        },
                        "directory_id": "directory_id",
                        "environments": [
                          {
                            "created_at": "2024-01-15T09:30:00Z",
                            "id": "id",
                            "name": "name",
                            "tag": "default",
                          },
                        ],
                        "function": {
                          "description": "description",
                          "name": "name",
                        },
                        "id": "id",
                        "inputs": [
                          {
                            "name": "name",
                          },
                        ],
                        "last_used_at": "2024-01-15T09:30:00Z",
                        "name": "name",
                        "setup_values": {
                          "key": "value",
                        },
                        "signature": "signature",
                        "source_code": "source_code",
                        "status": "uncommitted",
                        "tool_type": "pinecone_search",
                        "total_logs_count": 1,
                        "updated_at": "2024-01-15T09:30:00Z",
                        "version_id": "version_id",
                        "version_logs_count": 1,
                      },
                    ],
                  },
                },
              },
            ],
            "method": "GET",
            "pagination": undefined,
            "path": "/tools/{id}/versions",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for the Tool.",
                "type": "string",
              },
            },
            "request": {
              "name": "ToolsListVersionsRequest",
              "query-parameters": {
                "environment": {
                  "docs": "Filter versions by environment tag. If no environment is provided, all versions are returned.",
                  "type": "optional<string>",
                },
                "evaluation_aggregates": "optional<boolean>",
                "status": {
                  "docs": "Filter versions by status: 'uncommitted', 'committed'. If no status is provided, all versions are returned.",
                  "type": "optional<root.VersionStatus>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ListTools",
            },
          },
          "log": {
            "auth": true,
            "display-name": "Log",
            "docs": "Log to a Tool.

You can use query parameters version_id, or environment, to target
an existing version of the Tool. Otherwise the default deployed version will be chosen.

Instead of targeting an existing version explicitly, you can instead pass in
Tool details in the request body. In this case, we will check if the details correspond
to an existing version of the Tool, if not we will create a new version. This is helpful
in the case where you are storing or deriving your Tool details in code.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {},
                "response": {
                  "body": {
                    "id": "id",
                    "session_id": "session_id",
                    "tool_id": "tool_id",
                    "version_id": "version_id",
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/tools/{id}/log",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Tool.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "batches": {
                    "docs": "Array of Batch Ids that this log is part of. Batches are used to group Logs together for offline Evaluations",
                    "type": "optional<list<string>>",
                  },
                  "created_at": {
                    "docs": "User defined timestamp for when the log was created. ",
                    "type": "optional<datetime>",
                  },
                  "environment": {
                    "docs": "The name of the Environment the Log is associated to.",
                    "name": "toolLogRequestEnvironment",
                    "type": "optional<string>",
                  },
                  "error": {
                    "docs": "Error message if the log is an error.",
                    "type": "optional<string>",
                  },
                  "inputs": {
                    "docs": "The inputs passed to the prompt template.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "metadata": {
                    "docs": "Any additional metadata to record.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "output": {
                    "docs": "Generated output from your model for the provided inputs. Can be \`None\` if logging an error, or if creating a parent Log with the intention to populate it later.",
                    "type": "optional<string>",
                  },
                  "parent_id": {
                    "docs": "Unique identifier for the parent Log in a Session. Should only be provided if \`session_id\` is provided. If provided, the Log will be nested under the parent Log within the Session.",
                    "type": "optional<string>",
                  },
                  "provider_latency": {
                    "docs": "Duration of the logged event in seconds.",
                    "type": "optional<double>",
                  },
                  "provider_request": {
                    "docs": "Raw request sent to provider.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "provider_response": {
                    "docs": "Raw response received the provider.",
                    "type": "optional<map<string, unknown>>",
                  },
                  "raw_output": {
                    "docs": "Raw output from the provider.",
                    "type": "optional<string>",
                  },
                  "save": {
                    "default": true,
                    "docs": "Whether the request/response payloads will be stored on Humanloop.",
                    "type": "optional<boolean>",
                  },
                  "session_id": {
                    "docs": "Unique identifier for the Session to associate the Log to. Allows you to record multiple Logs to a Session (using an ID kept by your internal systems) by passing the same \`session_id\` in subsequent log requests. ",
                    "type": "optional<string>",
                  },
                  "source": {
                    "docs": "Identifies where the model was called from.",
                    "type": "optional<string>",
                  },
                  "source_datapoint_id": {
                    "docs": "Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.",
                    "type": "optional<string>",
                  },
                  "tool": {
                    "docs": "Details of your Tool. A new Tool version will be created if the provided details are new.",
                    "type": "optional<root.ToolKernelRequest>",
                  },
                  "user": {
                    "docs": "End-user ID related to the Log.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "ToolLogRequest",
              "query-parameters": {
                "environment": {
                  "docs": "An environment tag of the deployed version to log to.",
                  "type": "optional<string>",
                },
                "version_id": {
                  "docs": "A specific version Id of the Tool to log to.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.CreateToolLogResponse",
            },
          },
          "update": {
            "auth": true,
            "display-name": "Update Tool",
            "docs": "Update the Tool with the given ID.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {},
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "function": {
                      "description": "description",
                      "name": "name",
                      "parameters": {
                        "key": "value",
                      },
                    },
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "setup_values": {
                      "key": "value",
                    },
                    "signature": "signature",
                    "source_code": "source_code",
                    "status": "uncommitted",
                    "tool_type": "pinecone_search",
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "PATCH",
            "pagination": undefined,
            "path": "/tools/{id}",
            "path-parameters": {
              "id": {
                "docs": "Unique identifier for Tool.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "directory_id": {
                    "docs": "Unique identifier for the Directory of the Prompt. ",
                    "type": "optional<string>",
                  },
                  "name": {
                    "docs": "Name of the Tool, which is used as a unique identifier.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "UpdateToolRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ToolResponse",
            },
          },
          "updateEvaluators": {
            "auth": true,
            "display-name": "Update Evaluators",
            "docs": "Activate and deactivate Evaluators for the Tool.

An activated Evaluator will automatically be run on all new Logs
within the Tool for monitoring purposes.",
            "errors": [
              "root.UnprocessableEntityError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "id",
                },
                "request": {},
                "response": {
                  "body": {
                    "commit_message": "commit_message",
                    "created_at": "2024-01-15T09:30:00Z",
                    "created_by": {
                      "email_address": "email_address",
                      "full_name": "full_name",
                      "id": "id",
                    },
                    "directory_id": "directory_id",
                    "environments": [
                      {
                        "created_at": "2024-01-15T09:30:00Z",
                        "id": "id",
                        "name": "name",
                        "tag": "default",
                      },
                    ],
                    "function": {
                      "description": "description",
                      "name": "name",
                      "parameters": {
                        "key": "value",
                      },
                    },
                    "id": "id",
                    "inputs": [
                      {
                        "name": "name",
                      },
                    ],
                    "last_used_at": "2024-01-15T09:30:00Z",
                    "name": "name",
                    "setup_values": {
                      "key": "value",
                    },
                    "signature": "signature",
                    "source_code": "source_code",
                    "status": "uncommitted",
                    "tool_type": "pinecone_search",
                    "total_logs_count": 1,
                    "updated_at": "2024-01-15T09:30:00Z",
                    "version_id": "version_id",
                    "version_logs_count": 1,
                  },
                },
              },
            ],
            "method": "POST",
            "pagination": undefined,
            "path": "/tools/{id}/evaluators",
            "path-parameters": {
              "id": "string",
            },
            "request": {
              "body": "root.EvaluatorActivationDeactivationRequest",
            },
            "response": {
              "docs": "Successful Response",
              "type": "root.ToolResponse",
            },
          },
        },
      },
    },
  },
  "packageMarkerFile": {
    "errors": {
      "UnprocessableEntityError": {
        "docs": "Validation Error",
        "status-code": 422,
        "type": "HTTPValidationError",
      },
    },
    "types": {
      "AgentConfigResponse": {
        "docs": undefined,
        "properties": {
          "agent_class": {
            "docs": "Class of the agent.",
            "type": "string",
          },
          "created_by": {
            "docs": "The user who created the config.",
            "type": "optional<UserResponse>",
          },
          "description": {
            "docs": "Description of config.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "String ID of config. Starts with \`config_\`.",
            "type": "string",
          },
          "model_config": {
            "docs": "Model config associated with the agent.",
            "type": "ModelConfigRequest",
          },
          "name": {
            "docs": "Name of config.",
            "type": "string",
          },
          "other": {
            "docs": "Other parameters that define the config.",
            "type": "optional<map<string, unknown>>",
          },
          "status": {
            "docs": "Whether the config is committed or not.",
            "type": "string",
          },
          "tools": {
            "docs": "Tools associated with the agent.",
            "type": "optional<list<ToolConfigRequest>>",
          },
        },
      },
      "BooleanEvaluatorVersionStats": {
        "docs": "Base attributes for stats for an Evaluator Version-Evaluated Version pair
in the Evaluation Report.",
        "properties": {
          "evaluator_version_id": {
            "docs": "Unique identifier for the Evaluator Version.",
            "type": "string",
          },
          "num_errors": {
            "docs": "The total number of errored Evaluators for this Evaluator Version.",
            "type": "integer",
          },
          "num_false": {
            "docs": "The total number of \`False\` judgments for this Evaluator Version.",
            "type": "integer",
          },
          "num_judgments": {
            "docs": "The total number of Evaluator judgments for this Evaluator Version. This excludes Nulls and Errors.",
            "type": "integer",
          },
          "num_nulls": {
            "docs": "The total number of null judgments (i.e. abstentions) for this Evaluator Version.",
            "type": "integer",
          },
          "num_true": {
            "docs": "The total number of \`True\` judgments for this Evaluator Version.",
            "type": "integer",
          },
          "total_logs": {
            "docs": "The total number of Logs generated by this Evaluator Version on the Evaluated Version's Logs. This includes Nulls and Errors.",
            "type": "integer",
          },
        },
      },
      "CategoricalFeedbackLabel": {
        "docs": undefined,
        "properties": {
          "sentiment": {
            "docs": "Whether the feedback sentiment is positive or negative.",
            "type": "LabelSentiment",
          },
          "status": {
            "docs": "Whether the feedback label is active or inactive.",
            "type": "FeedbackLabelStatus",
          },
          "value": "string",
        },
      },
      "ChatMessage": {
        "docs": undefined,
        "properties": {
          "content": {
            "docs": "The content of the message.",
            "type": "optional<Content>",
          },
          "name": {
            "docs": "Optional name of the message author.",
            "type": "optional<string>",
          },
          "role": {
            "docs": "Role of the message author.",
            "type": "ChatRole",
          },
          "tool_call_id": {
            "docs": "Tool call that this message is responding to.",
            "type": "optional<string>",
          },
          "tool_calls": {
            "docs": "A list of tool calls requested by the assistant.",
            "type": "optional<list<ToolCall>>",
          },
        },
      },
      "ChatMessageContentItem": {
        "base-properties": {},
        "discriminant": "type",
        "docs": undefined,
        "union": {
          "image_url": "ImageChatContent",
          "text": "TextChatContent",
        },
      },
      "ChatMessageWithToolCall": {
        "docs": undefined,
        "properties": {
          "content": {
            "docs": "The content of the message.",
            "type": "optional<Content>",
          },
          "name": {
            "docs": "Optional name of the message author.",
            "type": "optional<string>",
          },
          "role": {
            "docs": "Role of the message author.",
            "type": "ChatRole",
          },
          "tool_call": {
            "availability": "deprecated",
            "docs": "NB: Deprecated in favour of tool_calls. A tool call requested by the assistant.",
            "type": "optional<FunctionTool>",
          },
          "tool_call_id": {
            "docs": "Tool call that this message is responding to.",
            "type": "optional<string>",
          },
          "tool_calls": {
            "docs": "A list of tool calls requested by the assistant.",
            "type": "optional<list<ToolCall>>",
          },
        },
      },
      "ChatMessageWithToolCallContentItem": {
        "base-properties": {},
        "discriminant": "type",
        "docs": undefined,
        "union": {
          "image_url": "ImageChatContent",
          "text": "TextChatContent",
        },
      },
      "ChatRole": {
        "docs": "An enumeration.",
        "enum": [
          "user",
          "assistant",
          "system",
          "tool",
        ],
      },
      "CodeEvaluatorRequest": {
        "docs": undefined,
        "properties": {
          "arguments_type": {
            "docs": "Whether this evaluator is target-free or target-required.",
            "type": "EvaluatorArgumentsType",
          },
          "code": {
            "docs": "The code for the evaluator. This code will be executed in a sandboxed environment.",
            "type": "optional<string>",
          },
          "return_type": {
            "docs": "The type of the return value of the evaluator.",
            "type": "EvaluatorReturnTypeEnum",
          },
        },
      },
      "CommitRequest": {
        "docs": undefined,
        "properties": {
          "commit_message": {
            "docs": "Message describing the changes made.",
            "type": "string",
          },
        },
      },
      "ConfigResponse": {
        "base-properties": {},
        "discriminant": "type",
        "docs": undefined,
        "union": {
          "agent": "AgentConfigResponse",
          "evaluator": "EvaluatorConfigResponse",
          "generic": "GenericConfigResponse",
          "model": "ModelConfigResponse",
          "tool": "ToolConfigResponse",
        },
      },
      "Content": {
        "discriminated": false,
        "docs": "The content of the message.",
        "union": [
          "string",
          "list<ChatMessageWithToolCallContentItem>",
        ],
      },
      "CreateDatapointRequest": {
        "docs": undefined,
        "properties": {
          "inputs": {
            "docs": "The inputs to the prompt template.",
            "type": "optional<map<string, string>>",
          },
          "messages": {
            "docs": "List of chat messages to provide to the model.",
            "type": "optional<list<ChatMessage>>",
          },
          "target": {
            "docs": "Object with criteria necessary to evaluate generations with this Datapoint. This is passed in as an argument to Evaluators when used in an Evaluation.",
            "type": "optional<map<string, CreateDatapointRequestTargetValue>>",
          },
        },
      },
      "CreateDatapointRequestTargetValue": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "string",
          "integer",
          "double",
          "boolean",
          "map<string, unknown>",
          "list<unknown>",
        ],
      },
      "CreateEvaluationRequest": {
        "docs": "Request model for creating an Evaluation.

Evaluation benchmark your Prompt/Tool Versions. With the Datapoints in a Dataset Version,
Logs corresponding to the Datapoint and each Evaluated Version are evaluated by the specified Evaluator Versions.
Aggregated statistics are then calculated and presented in the Evaluation.",
        "properties": {
          "dataset": {
            "docs": "The Dataset Version to use in this Evaluation.",
            "type": "DatasetRequest",
          },
          "evaluatees": {
            "docs": "Unique identifiers for the Prompt/Tool Versions to include in the Evaluation Report.",
            "type": "list<EvaluateeRequest>",
          },
          "evaluators": {
            "docs": "The Evaluators used to evaluate.",
            "type": "list<EvaluatorRequest>",
          },
        },
      },
      "CreatePromptLogResponse": {
        "docs": undefined,
        "properties": {
          "id": {
            "docs": "String ID of log.",
            "type": "string",
          },
          "prompt_id": {
            "docs": "ID of the Prompt the log belongs to.",
            "type": "string",
          },
          "session_id": {
            "docs": "String ID of session the log belongs to.",
            "type": "optional<string>",
          },
          "version_id": {
            "docs": "ID of the specific version of the Prompt.",
            "type": "string",
          },
        },
      },
      "CreateToolLogResponse": {
        "docs": undefined,
        "properties": {
          "id": {
            "docs": "String ID of log.",
            "type": "string",
          },
          "session_id": {
            "docs": "String ID of session the log belongs to.",
            "type": "optional<string>",
          },
          "tool_id": {
            "docs": "ID of the Prompt the log belongs to.",
            "type": "string",
          },
          "version_id": {
            "docs": "ID of the specific version of the Tool.",
            "type": "string",
          },
        },
      },
      "DashboardConfiguration": {
        "docs": undefined,
        "properties": {
          "model_config_ids": "list<string>",
          "time_range_days": "integer",
          "time_unit": "TimeUnit",
        },
      },
      "DatapointResponse": {
        "docs": undefined,
        "properties": {
          "id": {
            "docs": "Unique identifier for the Datapoint. Starts with \`dp_\`.",
            "type": "string",
          },
          "inputs": {
            "docs": "The inputs to the prompt template.",
            "type": "optional<map<string, string>>",
          },
          "messages": {
            "docs": "List of chat messages to provide to the model.",
            "type": "optional<list<ChatMessage>>",
          },
          "target": {
            "docs": "Object with criteria necessary to evaluate generations with this Datapoint. This is passed in as an argument to Evaluators when used in an Evaluation.",
            "type": "optional<map<string, DatapointResponseTargetValue>>",
          },
        },
      },
      "DatapointResponseTargetValue": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "string",
          "integer",
          "double",
          "boolean",
          "map<string, unknown>",
          "list<unknown>",
        ],
      },
      "DatasetRequest": {
        "docs": undefined,
        "properties": {
          "version_id": {
            "docs": "Unique identifier for the Dataset Version to use in this evaluation. Starts with \`dsv_\`.",
            "type": "string",
          },
        },
      },
      "DatasetResponse": {
        "docs": "Base type that all File Responses should inherit from.

Attributes defined here are common to all File Responses and should be overridden
in the inheriting classes with documentation and appropriate Field definitions.",
        "properties": {
          "commit_message": {
            "docs": "Message describing the changes made. If provided, a committed version of the Dataset is created. Otherwise, an uncommitted version is created.",
            "type": "optional<string>",
          },
          "created_at": "datetime",
          "created_by": {
            "docs": "The user who created the Dataset.",
            "type": "optional<UserResponse>",
          },
          "datapoints": {
            "docs": "The list of Datapoints in this Dataset version. Only provided if explicitly requested.",
            "type": "optional<list<DatapointResponse>>",
          },
          "datapoints_count": {
            "docs": "The number of Datapoints in this Dataset version.",
            "type": "integer",
          },
          "environments": {
            "docs": "The list of environments the Dataset Version is deployed to.",
            "type": "optional<list<EnvironmentResponse>>",
          },
          "id": {
            "docs": "Unique identifier for the Dataset. Starts with \`ds_\`.",
            "type": "string",
          },
          "last_used_at": "datetime",
          "name": {
            "docs": "Name of the Dataset, which is used as a unique identifier.",
            "type": "string",
          },
          "status": {
            "docs": "The status of the Dataset Version.",
            "type": "VersionStatus",
          },
          "updated_at": "datetime",
          "version_id": {
            "docs": "Unique identifier for the specific Dataset Version. If no query params provided, the default deployed Dataset Version is returned. Starts with \`dsv_\`.",
            "type": "string",
          },
        },
      },
      "EnvironmentResponse": {
        "docs": undefined,
        "properties": {
          "created_at": "datetime",
          "id": "string",
          "name": "string",
          "tag": "EnvironmentTag",
        },
      },
      "EnvironmentTag": {
        "docs": "An enumeration.",
        "enum": [
          "default",
          "other",
        ],
      },
      "EvaluatedVersionResponse": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "PromptResponse",
          "ToolResponse",
        ],
      },
      "EvaluateeRequest": {
        "docs": undefined,
        "properties": {
          "batch_id": {
            "docs": "Unique identifier for the batch of Logs to include in the Evaluation Report.",
            "type": "optional<string>",
          },
          "orchestrated": {
            "default": true,
            "docs": "Whether the Prompt/Tool is orchestrated by Humanloop. Default is \`True\`. If \`False\`, a log for the Prompt/Tool should be submitted by the user via the API.",
            "type": "optional<boolean>",
          },
          "version_id": {
            "docs": "Unique identifier for the Prompt/Tool Version to include in the Evaluation Report. Starts with \`pv_\` for Prompts and \`tv_\` for Tools.",
            "type": "string",
          },
        },
      },
      "EvaluateeResponse": {
        "docs": undefined,
        "properties": {
          "batch_id": {
            "docs": "Unique identifier for the batch of Logs to include in the Evaluation Report. ",
            "type": "optional<string>",
          },
          "orchestrated": {
            "docs": "Whether the Prompt/Tool is orchestrated by Humanloop. Default is \`True\`. If \`False\`, a log for the Prompt/Tool should be submitted by the user via the API.",
            "type": "boolean",
          },
          "version": "EvaluatedVersionResponse",
        },
      },
      "EvaluationDebugResultResponse": {
        "docs": "This is similar to an \`EvaluationResult\` but is ephemeral as it is only for synchronous
debug runs. It does not have an ID, or a reference to an evaluation run or even an evaluation
function.",
        "properties": {
          "datapoint_id": "optional<string>",
          "error": "optional<string>",
          "llm_evaluation_log": "optional<LogResponse>",
          "log": "LogResponse",
          "log_id": "string",
          "value": "optional<Value>",
        },
      },
      "EvaluationEvaluatorResponse": {
        "docs": undefined,
        "properties": {
          "orchestrated": {
            "docs": "Whether the Evaluator is orchestrated by Humanloop. Default is \`True\`. If \`False\`, a log for the Evaluator should be submitted by the user via the API.",
            "type": "boolean",
          },
          "version": "EvaluatorResponse",
        },
      },
      "EvaluationResponse": {
        "docs": undefined,
        "properties": {
          "created_at": "datetime",
          "created_by": "optional<UserResponse>",
          "dataset": {
            "docs": "The Dataset Version used in the Evaluation.",
            "type": "DatasetResponse",
          },
          "evaluatees": {
            "docs": "The Prompt/Tool Versions included in the Evaluation.",
            "type": "list<EvaluateeResponse>",
          },
          "evaluators": {
            "docs": "The Evaluator Versions used to evaluate.",
            "type": "list<EvaluationEvaluatorResponse>",
          },
          "id": {
            "docs": "Unique identifier for the Evaluation. Starts with \`evr\`.",
            "type": "string",
          },
          "status": {
            "docs": "The current status of the Evaluation.

- \`"pending"\`: The Evaluation has been created but is not actively being worked on by Humanloop.
- \`"running"\`: Humanloop is checking for any missing Logs and Evaluator Logs, and will generate them where appropriate.
- \`"completed"\`: All Logs an Evaluator Logs have been generated.
- \`"cancelled"\`: The Evaluation has been cancelled by the user. Humanloop will stop generating Logs and Evaluator Logs.
",
            "type": "EvaluationStatus",
          },
          "updated_at": "datetime",
        },
      },
      "EvaluationResultResponse": {
        "docs": undefined,
        "properties": {
          "created_at": "datetime",
          "error": "optional<string>",
          "evaluation_id": "optional<string>",
          "evaluator_id": "string",
          "evaluator_version_id": "string",
          "id": "string",
          "llm_evaluator_log": "optional<LogResponse>",
          "log": "optional<LogResponse>",
          "log_id": "string",
          "updated_at": "datetime",
          "value": "optional<Value>",
          "version": "optional<unknown>",
          "version_id": "optional<string>",
        },
      },
      "EvaluationStats": {
        "docs": undefined,
        "properties": {
          "overall_stats": {
            "docs": "Stats for the Evaluation Report as a whole.",
            "type": "OverallStats",
          },
          "version_stats": {
            "docs": "Stats for each Evaluated Version in the Evaluation Report.",
            "type": "list<VersionStats>",
          },
        },
      },
      "EvaluationStatus": {
        "docs": "Status of an evaluation.",
        "enum": [
          "pending",
          "running",
          "completed",
          "cancelled",
          "failed",
        ],
      },
      "EvaluatorActivationDeactivationRequest": {
        "docs": undefined,
        "properties": {
          "evaluators_to_activate": {
            "docs": "Monitoring Evaluators to activate. These will be automatically run on new Logs.",
            "type": "optional<list<EvaluatorActivationDeactivationRequestEvaluatorsToActivateItem>>",
          },
          "evaluators_to_deactivate": {
            "docs": "Evaluators to deactivate. These will not be run on new Logs.",
            "type": "optional<list<EvaluatorActivationDeactivationRequestEvaluatorsToDeactivateItem>>",
          },
        },
      },
      "EvaluatorActivationDeactivationRequestEvaluatorsToActivateItem": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "MonitoringEvaluatorVersionRequest",
          "MonitoringEvaluatorEnvironmentRequest",
        ],
      },
      "EvaluatorActivationDeactivationRequestEvaluatorsToDeactivateItem": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "MonitoringEvaluatorVersionRequest",
          "MonitoringEvaluatorEnvironmentRequest",
        ],
      },
      "EvaluatorArgumentsType": {
        "docs": "Enum representing the possible argument types of an evaluator.",
        "enum": [
          "target_free",
          "target_required",
        ],
      },
      "EvaluatorConfigResponse": {
        "docs": undefined,
        "properties": {
          "arguments_type": {
            "docs": "Whether this evaluator is target-free or target-required.",
            "type": "optional<EvaluatorArgumentsType>",
          },
          "code": {
            "docs": "The code for the evaluator. This code will be executed in a sandboxed environment.",
            "type": "optional<string>",
          },
          "created_by": {
            "docs": "The user who created the config.",
            "type": "optional<UserResponse>",
          },
          "description": {
            "docs": "Description of config.",
            "type": "optional<string>",
          },
          "evaluator_type": {
            "docs": "Type of evaluator.",
            "type": "string",
          },
          "id": {
            "docs": "String ID of config. Starts with \`config_\`.",
            "type": "string",
          },
          "model_config": {
            "docs": "The model config defining the LLM evaluator.",
            "type": "optional<ModelConfigResponse>",
          },
          "name": {
            "docs": "Name of config.",
            "type": "string",
          },
          "other": {
            "docs": "Other parameters that define the config.",
            "type": "optional<map<string, unknown>>",
          },
          "return_type": {
            "docs": "The type of the return value of the evaluator.",
            "type": "optional<EvaluatorReturnTypeEnum>",
          },
          "status": {
            "docs": "Whether the config is committed or not.",
            "type": "string",
          },
        },
      },
      "EvaluatorRequest": {
        "docs": undefined,
        "properties": {
          "orchestrated": {
            "default": true,
            "docs": "Whether the Evaluator is orchestrated by Humanloop. Default is \`True\`. If \`False\`, a log for the Evaluator should be submitted by the user via the API.",
            "type": "optional<boolean>",
          },
          "version_id": {
            "docs": "Unique identifier for the Evaluator Version to use in this evaluation. Starts with \`evv_\`.",
            "type": "string",
          },
        },
      },
      "EvaluatorResponse": {
        "docs": "Request model for creating a new Evaluator",
        "properties": {
          "commit_message": {
            "docs": "Message describing the changes made.",
            "type": "optional<string>",
          },
          "created_at": "datetime",
          "created_by": {
            "docs": "The user who created the Prompt.",
            "type": "optional<UserResponse>",
          },
          "directory_id": {
            "docs": "Unique identifier for the Directory of the Evaluator.",
            "type": "optional<string>",
          },
          "environments": {
            "docs": "The list of environments the Prompt Version is deployed to.",
            "type": "optional<list<EnvironmentResponse>>",
          },
          "id": {
            "docs": "Unique identifier for the Evaluator.",
            "type": "string",
          },
          "inputs": {
            "docs": "Inputs associated to the Prompt. Inputs correspond to any of the variables used within the Prompt template.",
            "type": "list<InputResponse>",
          },
          "last_used_at": "datetime",
          "name": {
            "docs": "Name of the Evaluator, which is used as a unique identifier.",
            "type": "string",
          },
          "spec": "Spec",
          "status": "VersionStatus",
          "total_logs_count": {
            "docs": "The number of logs that have been generated across all Prompt Versions",
            "type": "integer",
          },
          "updated_at": "datetime",
          "version_id": {
            "docs": "Unique identifier for the specific Evaluator Version. If no query params provided, the default deployed Evaluator Version is returned.",
            "type": "string",
          },
          "version_logs_count": {
            "docs": "The number of logs that have been generated for this Prompt Version",
            "type": "integer",
          },
        },
      },
      "EvaluatorReturnTypeEnum": {
        "docs": "Enum representing the possible return types of an evaluator.",
        "enum": [
          "boolean",
          "number",
        ],
      },
      "FeedbackClass": {
        "docs": "An enumeration.",
        "enum": [
          "select",
          "multi_select",
          "text",
          "number",
        ],
      },
      "FeedbackLabelStatus": {
        "docs": "Controls whether the label is displayed in the UI.",
        "enum": [
          "unset",
          "active",
          "inactive",
        ],
      },
      "FeedbackResponse": {
        "docs": undefined,
        "properties": {
          "created_at": {
            "docs": "User defined timestamp for when the feedback was created. ",
            "type": "optional<datetime>",
          },
          "data_id": {
            "docs": "ID to associate the feedback to a previously logged datapoint.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "String ID of user feedback. Starts with \`ann_\`, short for annotation.",
            "type": "string",
          },
          "type": {
            "docs": "The type of feedback. The default feedback types available are 'rating', 'action', 'issue', 'correction', and 'comment'.",
            "type": "FeedbackResponseType",
          },
          "user": {
            "docs": "A unique identifier to who provided the feedback.",
            "type": "optional<string>",
          },
          "value": {
            "docs": "The feedback value to set. This would be the appropriate text for 'correction' or 'comment', or a label to apply for 'rating', 'action', or 'issue'.",
            "type": "FeedbackResponseValue",
          },
        },
      },
      "FeedbackResponseType": {
        "discriminated": false,
        "docs": "The type of feedback. The default feedback types available are 'rating', 'action', 'issue', 'correction', and 'comment'.",
        "union": [
          "FeedbackType",
          "string",
        ],
      },
      "FeedbackResponseValue": {
        "discriminated": false,
        "docs": "The feedback value to set. This would be the appropriate text for 'correction' or 'comment', or a label to apply for 'rating', 'action', or 'issue'.",
        "union": [
          "double",
          "string",
        ],
      },
      "FeedbackType": {
        "docs": "An enumeration.",
        "enum": [
          "rating",
          "action",
          "issue",
          "correction",
          "comment",
        ],
      },
      "FeedbackTypeModel": {
        "docs": undefined,
        "properties": {
          "type": {
            "docs": "The type of feedback. The default feedback types available are 'rating', 'action', 'issue', 'correction', and 'comment'.",
            "type": "FeedbackTypeModelType",
          },
          "values": {
            "docs": "The allowed values for categorical feedback types. Not populated for \`correction\` and \`comment\`.",
            "type": "optional<list<CategoricalFeedbackLabel>>",
          },
        },
      },
      "FeedbackTypeModelType": {
        "discriminated": false,
        "docs": "The type of feedback. The default feedback types available are 'rating', 'action', 'issue', 'correction', and 'comment'.",
        "union": [
          "FeedbackType",
          "string",
        ],
      },
      "FeedbackTypes": "list<FeedbackTypeModel>",
      "File": {
        "discriminated": false,
        "docs": "The File that the deployed Version belongs to.",
        "union": [
          "PromptResponse",
          "ToolResponse",
          "DatasetResponse",
          "EvaluatorResponse",
        ],
      },
      "FunctionTool": {
        "docs": "A function tool to be called by the model where user owns runtime.",
        "properties": {
          "arguments": "optional<string>",
          "name": "string",
        },
      },
      "FunctionToolChoice": {
        "docs": "A function tool to be called by the model where user owns runtime.",
        "properties": {
          "name": "string",
        },
      },
      "GenericConfigResponse": {
        "docs": undefined,
        "properties": {
          "created_by": {
            "docs": "The user who created the config.",
            "type": "optional<UserResponse>",
          },
          "description": {
            "docs": "Description of config.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "String ID of config. Starts with \`config_\`.",
            "type": "string",
          },
          "name": {
            "docs": "Name of config.",
            "type": "string",
          },
          "other": {
            "docs": "Other parameters that define the config.",
            "type": "optional<map<string, unknown>>",
          },
          "status": {
            "docs": "Whether the config is committed or not.",
            "type": "string",
          },
        },
      },
      "HTTPValidationError": {
        "docs": undefined,
        "properties": {
          "detail": "optional<list<ValidationError>>",
        },
      },
      "HumanEvaluatorRequest": {
        "docs": undefined,
        "properties": {
          "arguments_type": {
            "docs": "Whether this evaluator is target-free or target-required.",
            "type": "EvaluatorArgumentsType",
          },
          "return_type": {
            "docs": "The type of the return value of the evaluator.",
            "type": "EvaluatorReturnTypeEnum",
          },
        },
      },
      "ImageChatContent": {
        "docs": undefined,
        "properties": {
          "image_url": {
            "docs": "The message's image content.",
            "type": "ImageUrl",
          },
        },
      },
      "ImageUrl": {
        "docs": undefined,
        "properties": {
          "detail": {
            "docs": "Specify the detail level of the image provided to the model. For more details see: https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding",
            "type": "optional<ImageUrlDetail>",
          },
          "url": {
            "docs": "Either a URL of the image or the base64 encoded image data.",
            "type": "string",
          },
        },
      },
      "ImageUrlDetail": {
        "docs": "Specify the detail level of the image provided to the model. For more details see: https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding",
        "enum": [
          "high",
          "low",
          "auto",
        ],
      },
      "InputResponse": {
        "docs": undefined,
        "properties": {
          "name": {
            "docs": "Type of input.",
            "type": "string",
          },
        },
      },
      "Judgment": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "boolean",
          "double",
        ],
      },
      "LLMEvaluatorRequest": {
        "docs": undefined,
        "properties": {
          "arguments_type": {
            "docs": "Whether this evaluator is target-free or target-required.",
            "type": "EvaluatorArgumentsType",
          },
          "prompt": {
            "docs": "The prompt parameters used to generate.",
            "type": "optional<PromptKernelRequest>",
          },
          "return_type": {
            "docs": "The type of the return value of the evaluator.",
            "type": "EvaluatorReturnTypeEnum",
          },
        },
      },
      "LabelSentiment": {
        "docs": "How a label should be treated in calculating Version performance.

Used by a File's PAPV (Positive Action Per View) metric.",
        "enum": [
          "positive",
          "negative",
          "neutral",
          "unset",
        ],
      },
      "LinkedToolRequest": {
        "docs": undefined,
        "properties": {
          "description": {
            "docs": "The description of the linked tool.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "The ID of the linked tool. Starts with "oc_"",
            "type": "string",
          },
          "name": {
            "docs": "The name of the linked tool.",
            "type": "optional<string>",
          },
          "parameters": {
            "docs": "The parameters of the linked tool.",
            "type": "optional<map<string, unknown>>",
          },
          "source": {
            "docs": "The source of the linked tool. For a linked tool it should be \`organization\`",
            "type": "literal<"organization">",
          },
        },
      },
      "LinkedToolResponse": {
        "docs": undefined,
        "properties": {
          "description": {
            "docs": "Description of the tool referenced by the model",
            "type": "string",
          },
          "id": {
            "docs": "Unique identifier for the Tool linked.",
            "type": "string",
          },
          "name": {
            "docs": "Name for the tool referenced by the model.",
            "type": "string",
          },
          "parameters": {
            "docs": "Parameters needed to run the Tool, defined in JSON Schema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
          "version_id": {
            "docs": "Unique identifier for the Tool Version linked.",
            "type": "string",
          },
        },
      },
      "ListDatasets": {
        "docs": undefined,
        "properties": {
          "records": {
            "docs": "The list of Datasets.",
            "type": "list<DatasetResponse>",
          },
        },
      },
      "ListEvaluators": {
        "docs": undefined,
        "properties": {
          "records": {
            "docs": "The list of Evaluators.",
            "type": "list<EvaluatorResponse>",
          },
        },
      },
      "ListPrompts": {
        "docs": undefined,
        "properties": {
          "records": {
            "docs": "The list of Prompts.",
            "type": "list<PromptResponse>",
          },
        },
      },
      "ListTools": {
        "docs": undefined,
        "properties": {
          "records": {
            "docs": "The list of Tools.",
            "type": "list<ToolResponse>",
          },
        },
      },
      "LogResponse": {
        "docs": "Request model for logging a datapoint.",
        "properties": {
          "batch_ids": {
            "docs": "List of batch IDs the log belongs to.",
            "type": "optional<list<string>>",
          },
          "config": "ConfigResponse",
          "config_id": {
            "docs": "Unique ID of a config to associate to the log.",
            "type": "optional<string>",
          },
          "created_at": {
            "docs": "User defined timestamp for when the log was created. ",
            "type": "optional<datetime>",
          },
          "duration": {
            "docs": "Duration of the logged event in seconds.",
            "type": "optional<double>",
          },
          "environment": {
            "docs": "The environment name used to create the log.",
            "type": "optional<string>",
          },
          "error": {
            "docs": "Error message if the log is an error.",
            "type": "optional<string>",
          },
          "evaluation_results": "list<EvaluationResultResponse>",
          "feedback": "optional<list<FeedbackResponse>>",
          "finish_reason": {
            "docs": "Reason the generation finished.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "String ID of logged datapoint. Starts with \`data_\`.",
            "type": "string",
          },
          "inputs": {
            "docs": "The inputs passed to the prompt template.",
            "type": "optional<map<string, unknown>>",
          },
          "judgment": "optional<Judgment>",
          "messages": {
            "docs": "The messages passed to the to provider chat endpoint.",
            "type": "optional<list<ChatMessageWithToolCall>>",
          },
          "metadata": {
            "docs": "Any additional metadata to record.",
            "type": "optional<map<string, unknown>>",
          },
          "metric_values": "optional<list<MetricValueResponse>>",
          "observability_status": "ObservabilityStatus",
          "output": {
            "docs": "Generated output from your model for the provided inputs. Can be \`None\` if logging an error, or if logging a parent datapoint with the intention to populate it later",
            "type": "optional<string>",
          },
          "output_cost": {
            "docs": "Cost in dollars associated to the tokens in the output.",
            "type": "optional<double>",
          },
          "output_message": {
            "docs": "The message returned by the provider.",
            "type": "optional<ChatMessageWithToolCall>",
          },
          "output_tokens": {
            "docs": "Number of tokens in the output generated by the model.",
            "type": "optional<integer>",
          },
          "parent_id": {
            "docs": "ID associated to the parent datapoint in a session.",
            "type": "optional<string>",
          },
          "parent_reference_id": {
            "docs": "A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as \`parent_id\` in a prior log request. Specify at most one of this or \`parent_id\`. Note that this cannot refer to a datapoint being logged in the same request.",
            "type": "optional<string>",
          },
          "project": {
            "docs": "The name of the project associated with this log",
            "type": "optional<string>",
          },
          "project_id": {
            "docs": "The unique ID of the project associated with this log.",
            "type": "optional<string>",
          },
          "prompt_cost": {
            "docs": "Cost in dollars associated to the tokens in the prompt.",
            "type": "optional<double>",
          },
          "prompt_tokens": {
            "docs": "Number of tokens in the prompt used to generate the output.",
            "type": "optional<integer>",
          },
          "provider_latency": {
            "docs": "Latency of provider response.",
            "type": "optional<double>",
          },
          "provider_request": {
            "docs": "Raw request sent to provider.",
            "type": "optional<map<string, unknown>>",
          },
          "provider_response": {
            "docs": "Raw response received the provider.",
            "type": "optional<map<string, unknown>>",
          },
          "raw_output": {
            "docs": "Raw output from the provider.",
            "type": "optional<string>",
          },
          "reference_id": {
            "docs": "Unique user-provided string identifying the datapoint.",
            "type": "optional<string>",
          },
          "save": {
            "default": true,
            "docs": "Whether the request/response payloads will be stored on Humanloop.",
            "type": "optional<boolean>",
          },
          "session_id": {
            "docs": "ID of the session to associate the datapoint.",
            "type": "optional<string>",
          },
          "session_reference_id": {
            "docs": "A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same \`session_reference_id\` in subsequent log requests. Specify at most one of this or \`session_id\`.",
            "type": "optional<string>",
          },
          "source": {
            "docs": "Identifies where the model was called from.",
            "type": "optional<string>",
          },
          "source_datapoint_id": {
            "docs": "ID of the source datapoint if this is a log derived from a datapoint in a dataset.",
            "type": "optional<string>",
          },
          "tokens": {
            "docs": "Total number of tokens in the prompt and output.",
            "type": "optional<integer>",
          },
          "tool_choice": {
            "docs": "Controls how the model uses tools. The following options are supported: 'none' forces the model to not call a tool; the default when no tools are provided as part of the model config. 'auto' the model can decide to call one of the provided tools; the default when tools are provided as part of the model config. Providing {'type': 'function', 'function': {name': <TOOL_NAME>}} forces the model to use the named function.",
            "type": "optional<LogResponseToolChoice>",
          },
          "tools": "optional<list<ToolResultResponse>>",
          "trial_id": {
            "docs": "Unique ID of an experiment trial to associate to the log.",
            "type": "optional<string>",
          },
          "updated_at": "datetime",
          "user": {
            "docs": "User email address provided when creating the datapoint.",
            "type": "optional<string>",
          },
        },
      },
      "LogResponseToolChoice": {
        "discriminated": false,
        "docs": "Controls how the model uses tools. The following options are supported: 'none' forces the model to not call a tool; the default when no tools are provided as part of the model config. 'auto' the model can decide to call one of the provided tools; the default when tools are provided as part of the model config. Providing {'type': 'function', 'function': {name': <TOOL_NAME>}} forces the model to use the named function.",
        "union": [
          "literal<"none">",
          "literal<"auto">",
          "literal<"required">",
          "ToolChoice",
        ],
      },
      "MetricValueResponse": {
        "docs": undefined,
        "properties": {
          "metric_id": "string",
          "metric_name": "string",
          "metric_value": "double",
        },
      },
      "ModelConfigRequest": {
        "docs": "Model config used for logging both chat and completion.",
        "properties": {
          "chat_template": {
            "docs": "Messages prepended to the list of messages sent to the provider. These messages that will take your specified inputs to form your final request to the provider model. Input variables within the template should be specified with syntax: {{INPUT_NAME}}.",
            "type": "optional<list<ChatMessageWithToolCall>>",
          },
          "description": {
            "docs": "A description of the model config.",
            "type": "optional<string>",
          },
          "endpoint": {
            "docs": "The provider model endpoint used.",
            "type": "optional<ModelEndpoints>",
          },
          "frequency_penalty": {
            "default": 0,
            "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "type": "optional<double>",
          },
          "max_tokens": {
            "default": -1,
            "docs": "The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt",
            "type": "optional<integer>",
          },
          "model": {
            "docs": "The model instance used. E.g. text-davinci-002.",
            "type": "string",
          },
          "name": {
            "docs": "A friendly display name for the model config. If not provided, a name will be generated.",
            "type": "optional<string>",
          },
          "other": {
            "docs": "Other parameter values to be passed to the provider call.",
            "type": "optional<map<string, unknown>>",
          },
          "presence_penalty": {
            "default": 0,
            "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "type": "optional<double>",
          },
          "prompt_template": {
            "docs": "Prompt template that will take your specified inputs to form your final request to the model. Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.",
            "type": "optional<string>",
          },
          "provider": {
            "docs": "The company providing the underlying model service.",
            "type": "optional<ModelProviders>",
          },
          "response_format": {
            "docs": "The format of the response. Only type json_object is currently supported for chat.",
            "type": "optional<ResponseFormat>",
          },
          "seed": {
            "docs": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed.",
            "type": "optional<integer>",
          },
          "stop": {
            "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
            "type": "optional<ModelConfigRequestStop>",
          },
          "temperature": {
            "default": 1,
            "docs": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "type": "optional<double>",
          },
          "tools": {
            "docs": "Make tools available to OpenAIs chat model as functions.",
            "type": "optional<list<ModelConfigRequestToolsItem>>",
          },
          "top_p": {
            "default": 1,
            "docs": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "type": "optional<double>",
          },
          "type": "optional<literal<"model">>",
        },
      },
      "ModelConfigRequestStop": {
        "discriminated": false,
        "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
        "union": [
          "string",
          "list<string>",
        ],
      },
      "ModelConfigRequestToolsItem": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "LinkedToolRequest",
          "ModelConfigToolRequest",
        ],
      },
      "ModelConfigResponse": {
        "docs": "Model config request.

Contains fields that are common to all (i.e. both chat and complete) endpoints.",
        "properties": {
          "chat_template": {
            "docs": "Messages prepended to the list of messages sent to the provider. These messages that will take your specified inputs to form your final request to the provider model. NB: Input variables within the template should be specified with syntax: {{INPUT_NAME}}.",
            "type": "optional<list<ChatMessageWithToolCall>>",
          },
          "description": {
            "docs": "A description of the model config.",
            "type": "optional<string>",
          },
          "endpoint": {
            "docs": "The provider model endpoint used.",
            "type": "optional<ModelEndpoints>",
          },
          "frequency_penalty": {
            "default": 0,
            "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "type": "optional<double>",
          },
          "id": {
            "docs": "String ID of config. Starts with \`config_\`.",
            "type": "string",
          },
          "max_tokens": {
            "default": -1,
            "docs": "The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt",
            "type": "optional<integer>",
          },
          "model": {
            "docs": "The model instance used. E.g. text-davinci-002.",
            "type": "string",
          },
          "name": {
            "docs": "A friendly display name for the model config. If not provided, a name will be generated.",
            "type": "optional<string>",
          },
          "other": {
            "docs": "Other parameter values to be passed to the provider call.",
            "type": "optional<map<string, unknown>>",
          },
          "presence_penalty": {
            "default": 0,
            "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "type": "optional<double>",
          },
          "prompt_template": {
            "docs": "Prompt template that will take your specified inputs to form your final request to the model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.",
            "type": "optional<string>",
          },
          "provider": {
            "docs": "The company providing the underlying model service.",
            "type": "optional<ModelProviders>",
          },
          "response_format": {
            "docs": "The format of the response. Only type json_object is currently supported for chat.",
            "type": "optional<ResponseFormat>",
          },
          "seed": {
            "docs": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed.",
            "type": "optional<integer>",
          },
          "stop": {
            "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
            "type": "optional<ModelConfigResponseStop>",
          },
          "temperature": {
            "default": 1,
            "docs": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "type": "optional<double>",
          },
          "tool_configs": {
            "availability": "deprecated",
            "docs": "NB: Deprecated with tools field. Definition of tools shown to the model.",
            "type": "optional<list<ToolConfigResponse>>",
          },
          "tools": {
            "docs": "Tools shown to the model.",
            "type": "optional<list<ToolResponse>>",
          },
          "top_p": {
            "default": 1,
            "docs": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "type": "optional<double>",
          },
        },
      },
      "ModelConfigResponseStop": {
        "discriminated": false,
        "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
        "union": [
          "string",
          "list<string>",
        ],
      },
      "ModelConfigToolRequest": {
        "docs": "Definition of tool within a model config.

The subset of ToolConfig parameters received by the chat endpoint.
Does not have things like the signature or setup schema.",
        "properties": {
          "description": {
            "docs": "The description of the tool shown to the model.",
            "type": "optional<string>",
          },
          "name": {
            "docs": "The name of the tool shown to the model.",
            "type": "string",
          },
          "other": {
            "docs": "Other parameters that define the config.",
            "type": "optional<map<string, unknown>>",
          },
          "parameters": {
            "docs": "Definition of parameters needed to run the tool. Provided in jsonschema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
          "preset_name": {
            "docs": "If is_preset = true, this is the name of the preset tool on Humanloop. This is used as the key to look up the Humanloop runtime of the tool",
            "type": "optional<string>",
          },
          "source": {
            "docs": "Source of the tool. If defined at an organization level will be 'organization' else 'inline'.",
            "type": "optional<ToolSource>",
          },
          "source_code": {
            "docs": "Code source of the tool.",
            "type": "optional<string>",
          },
        },
      },
      "ModelEndpoints": {
        "docs": "Supported model provider endpoints.",
        "enum": [
          "complete",
          "chat",
          "edit",
        ],
      },
      "ModelProviders": {
        "docs": "Supported model providers.",
        "enum": [
          "openai",
          "openai_azure",
          "ai21",
          "mock",
          "anthropic",
          "langchain",
          "cohere",
          "replicate",
          "google",
          "groq",
        ],
      },
      "MonitoringEvaluatorEnvironmentRequest": {
        "docs": undefined,
        "properties": {
          "environment_id": {
            "docs": "Unique identifier for the Environment. The Evaluator Version deployed to this Environment will be used for monitoring.",
            "type": "string",
          },
          "evaluator_id": {
            "docs": "Unique identifier for the Evaluator to be used for monitoring.",
            "type": "string",
          },
        },
      },
      "MonitoringEvaluatorResponse": {
        "docs": undefined,
        "properties": {
          "created_at": "datetime",
          "state": {
            "docs": "The state of the Monitoring Evaluator. Either \`active\` or \`inactive\`",
            "type": "MonitoringEvaluatorState",
          },
          "updated_at": "datetime",
          "version": {
            "docs": "The deployed Version.",
            "type": "optional<EvaluatorResponse>",
          },
          "version_reference": {
            "docs": "The Evaluator Version used for monitoring. This can be a specific Version by ID, or a Version deployed to an Environment.",
            "type": "VersionReferenceResponse",
          },
        },
      },
      "MonitoringEvaluatorState": {
        "docs": "State of an evaluator connected to a file",
        "enum": [
          "active",
          "inactive",
        ],
      },
      "MonitoringEvaluatorVersionRequest": {
        "docs": undefined,
        "properties": {
          "evaluator_version_id": {
            "docs": "Unique identifier for the Evaluator Version to be used for monitoring.",
            "type": "string",
          },
        },
      },
      "NumericEvaluatorVersionStats": {
        "docs": "Base attributes for stats for an Evaluator Version-Evaluated Version pair
in the Evaluation Report.",
        "properties": {
          "evaluator_version_id": {
            "docs": "Unique identifier for the Evaluator Version.",
            "type": "string",
          },
          "mean": "optional<double>",
          "num_errors": {
            "docs": "The total number of errored Evaluators for this Evaluator Version.",
            "type": "integer",
          },
          "num_judgments": {
            "docs": "The total number of Evaluator judgments for this Evaluator Version. This excludes Nulls and Errors.",
            "type": "integer",
          },
          "num_nulls": {
            "docs": "The total number of null judgments (i.e. abstentions) for this Evaluator Version.",
            "type": "integer",
          },
          "percentiles": "map<string, double>",
          "std": "optional<double>",
          "total_logs": {
            "docs": "The total number of Logs generated by this Evaluator Version on the Evaluated Version's Logs. This includes Nulls and Errors.",
            "type": "integer",
          },
        },
      },
      "ObservabilityStatus": {
        "docs": "Status of a Log for observability.

Observability is implemented by running monitoring Evaluators on Logs.",
        "enum": [
          "pending",
          "running",
          "completed",
          "failed",
        ],
      },
      "OverallStats": {
        "docs": undefined,
        "properties": {
          "num_datapoints": {
            "docs": "The total number of Datapoints in the Evaluation Report's Dataset Version.",
            "type": "integer",
          },
          "total_evaluator_logs": {
            "docs": "The total number of Evaluator Logs in the Evaluation Report.",
            "type": "integer",
          },
          "total_logs": {
            "docs": "The total number of Logs in the Evaluation Report.",
            "type": "integer",
          },
        },
      },
      "PaginatedDataDatapointResponse": {
        "docs": undefined,
        "properties": {
          "page": "integer",
          "records": "list<DatapointResponse>",
          "size": "integer",
          "total": "integer",
        },
      },
      "PaginatedDataDatasetResponse": {
        "docs": undefined,
        "properties": {
          "page": "integer",
          "records": "list<DatasetResponse>",
          "size": "integer",
          "total": "integer",
        },
      },
      "PaginatedDataEvaluationResponse": {
        "docs": undefined,
        "properties": {
          "page": "integer",
          "records": "list<EvaluationResponse>",
          "size": "integer",
          "total": "integer",
        },
      },
      "PaginatedDataPromptLogResponse": {
        "docs": undefined,
        "properties": {
          "page": "integer",
          "records": "list<PromptLogResponse>",
          "size": "integer",
          "total": "integer",
        },
      },
      "PaginatedDataSessionResponse": {
        "docs": undefined,
        "properties": {
          "page": "integer",
          "records": "list<SessionResponse>",
          "size": "integer",
          "total": "integer",
        },
      },
      "PlatformAccessEnum": {
        "docs": "An enumeration.",
        "enum": [
          "superadmin",
          "supportadmin",
          "user",
        ],
      },
      "ProjectSortBy": {
        "docs": "An enumeration.",
        "enum": [
          "created_at",
          "updated_at",
          "name",
        ],
      },
      "PromptCallLogResponse": {
        "docs": "Sample specific response details for a Prompt call",
        "properties": {
          "created_at": {
            "docs": "User defined timestamp for when the log was created. ",
            "type": "optional<datetime>",
          },
          "error": {
            "docs": "Error message if the log is an error.",
            "type": "optional<string>",
          },
          "finish_reason": {
            "docs": "Reason the generation finished.",
            "type": "optional<string>",
          },
          "index": {
            "docs": "The index of the sample in the batch.",
            "type": "integer",
          },
          "output": {
            "docs": "Generated output from your model for the provided inputs. Can be \`None\` if logging an error, or if creating a parent Log with the intention to populate it later.",
            "type": "optional<string>",
          },
          "output_cost": {
            "docs": "Cost in dollars associated to the tokens in the output.",
            "type": "optional<double>",
          },
          "output_message": {
            "docs": "The message returned by the provider.",
            "type": "optional<ChatMessage>",
          },
          "output_tokens": {
            "docs": "Number of tokens in the output generated by the model.",
            "type": "optional<integer>",
          },
          "prompt_cost": {
            "docs": "Cost in dollars associated to the tokens in the prompt.",
            "type": "optional<double>",
          },
          "prompt_tokens": {
            "docs": "Number of tokens in the prompt used to generate the output.",
            "type": "optional<integer>",
          },
          "provider_latency": {
            "docs": "Duration of the logged event in seconds.",
            "type": "optional<double>",
          },
          "raw_output": {
            "docs": "Raw output from the provider.",
            "type": "optional<string>",
          },
        },
      },
      "PromptCallResponse": {
        "docs": "Response model for a Prompt call with potentially multiple log samples.",
        "properties": {
          "batches": {
            "docs": "Array of Batch Ids that this log is part of. Batches are used to group Logs together for offline Evaluations",
            "type": "optional<list<string>>",
          },
          "environment": {
            "docs": "The name of the Environment the Log is associated to.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "ID of the log.",
            "type": "string",
          },
          "inputs": {
            "docs": "The inputs passed to the prompt template.",
            "type": "optional<map<string, unknown>>",
          },
          "logs": {
            "docs": "The logs generated by the Prompt call.",
            "type": "list<PromptCallLogResponse>",
          },
          "messages": {
            "docs": "The messages passed to the to provider chat endpoint.",
            "type": "optional<list<ChatMessage>>",
          },
          "metadata": {
            "docs": "Any additional metadata to record.",
            "type": "optional<map<string, unknown>>",
          },
          "parent_id": {
            "docs": "Unique identifier for the parent Log in a Session. Should only be provided if \`session_id\` is provided. If provided, the Log will be nested under the parent Log within the Session.",
            "type": "optional<string>",
          },
          "prompt": {
            "docs": "Prompt details used to generate the log.",
            "type": "PromptResponse",
          },
          "save": {
            "default": true,
            "docs": "Whether the request/response payloads will be stored on Humanloop.",
            "type": "optional<boolean>",
          },
          "session_id": {
            "docs": "Unique identifier for the Session to associate the Log to. Allows you to record multiple Logs to a Session (using an ID kept by your internal systems) by passing the same \`session_id\` in subsequent log requests. ",
            "type": "optional<string>",
          },
          "source": {
            "docs": "Identifies where the model was called from.",
            "type": "optional<string>",
          },
          "source_datapoint_id": {
            "docs": "Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.",
            "type": "optional<string>",
          },
          "tool_choice": {
            "docs": "Controls how the model uses tools. The following options are supported: 
- \`'none'\` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt. 
- \`'auto'\` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt. 
- \`'required'\` means the model can decide to call one or more of the provided tools. 
- \`{'type': 'function', 'function': {name': <TOOL_NAME>}}\` forces the model to use the named function.",
            "type": "optional<PromptCallResponseToolChoice>",
          },
          "user": {
            "docs": "End-user ID related to the Log.",
            "type": "optional<string>",
          },
        },
      },
      "PromptCallResponseToolChoice": {
        "discriminated": false,
        "docs": "Controls how the model uses tools. The following options are supported: 
- \`'none'\` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt. 
- \`'auto'\` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt. 
- \`'required'\` means the model can decide to call one or more of the provided tools. 
- \`{'type': 'function', 'function': {name': <TOOL_NAME>}}\` forces the model to use the named function.",
        "union": [
          "literal<"none">",
          "literal<"auto">",
          "literal<"required">",
          "ToolChoice",
        ],
      },
      "PromptCallStreamResponse": {
        "docs": "Response model for calling Prompt in streaming mode.",
        "properties": {
          "created_at": {
            "docs": "User defined timestamp for when the log was created. ",
            "type": "optional<datetime>",
          },
          "error": {
            "docs": "Error message if the log is an error.",
            "type": "optional<string>",
          },
          "finish_reason": {
            "docs": "Reason the generation finished.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "ID of the log.",
            "type": "string",
          },
          "index": {
            "docs": "The index of the sample in the batch.",
            "type": "integer",
          },
          "output": {
            "docs": "Generated output from your model for the provided inputs. Can be \`None\` if logging an error, or if creating a parent Log with the intention to populate it later.",
            "type": "optional<string>",
          },
          "output_cost": {
            "docs": "Cost in dollars associated to the tokens in the output.",
            "type": "optional<double>",
          },
          "output_message": {
            "docs": "The message returned by the provider.",
            "type": "optional<ChatMessage>",
          },
          "output_tokens": {
            "docs": "Number of tokens in the output generated by the model.",
            "type": "optional<integer>",
          },
          "prompt_cost": {
            "docs": "Cost in dollars associated to the tokens in the prompt.",
            "type": "optional<double>",
          },
          "prompt_id": {
            "docs": "ID of the Prompt the log belongs to.",
            "type": "string",
          },
          "prompt_tokens": {
            "docs": "Number of tokens in the prompt used to generate the output.",
            "type": "optional<integer>",
          },
          "provider_latency": {
            "docs": "Duration of the logged event in seconds.",
            "type": "optional<double>",
          },
          "raw_output": {
            "docs": "Raw output from the provider.",
            "type": "optional<string>",
          },
          "version_id": {
            "docs": "ID of the specific version of the Prompt.",
            "type": "string",
          },
        },
      },
      "PromptKernelRequest": {
        "docs": undefined,
        "properties": {
          "endpoint": {
            "docs": "The provider model endpoint used.",
            "type": "optional<ModelEndpoints>",
          },
          "frequency_penalty": {
            "default": 0,
            "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "type": "optional<double>",
          },
          "linked_tools": {
            "docs": "The IDs of the Tools in your organization that the model can choose to call if Tool calling is supported. The default deployed version of that tool is called.",
            "type": "optional<list<string>>",
          },
          "max_tokens": {
            "default": -1,
            "docs": "The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt",
            "type": "optional<integer>",
          },
          "model": {
            "docs": "The model instance used, e.g. \`gpt-4\`. See [supported models](https://humanloop.com/docs/supported-models)",
            "type": "string",
          },
          "other": {
            "docs": "Other parameter values to be passed to the provider call.",
            "type": "optional<map<string, unknown>>",
          },
          "presence_penalty": {
            "default": 0,
            "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "type": "optional<double>",
          },
          "provider": {
            "docs": "The company providing the underlying model service.",
            "type": "optional<ModelProviders>",
          },
          "response_format": {
            "docs": "The format of the response. Only \`{"type": "json_object"}\` is currently supported for chat.",
            "type": "optional<ResponseFormat>",
          },
          "seed": {
            "docs": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed.",
            "type": "optional<integer>",
          },
          "stop": {
            "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
            "type": "optional<PromptKernelRequestStop>",
          },
          "temperature": {
            "default": 1,
            "docs": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "type": "optional<double>",
          },
          "template": {
            "docs": "For chat endpoint, provide a Chat template. For completion endpoint, provide a Prompt template. Input variables within the template should be specified with double curly bracket syntax: {{INPUT_NAME}}.",
            "type": "optional<Template>",
          },
          "tools": {
            "docs": "The tool specification that the model can choose to call if Tool calling is supported.",
            "type": "optional<list<ToolFunction>>",
          },
          "top_p": {
            "default": 1,
            "docs": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "type": "optional<double>",
          },
        },
      },
      "PromptKernelRequestStop": {
        "discriminated": false,
        "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
        "union": [
          "string",
          "list<string>",
        ],
      },
      "PromptLogResponse": {
        "docs": "Request for creating a Prompt log.",
        "properties": {
          "batches": {
            "docs": "Array of Batch Ids that this log is part of. Batches are used to group Logs together for offline Evaluations",
            "type": "optional<list<string>>",
          },
          "created_at": {
            "docs": "User defined timestamp for when the log was created. ",
            "type": "optional<datetime>",
          },
          "environment": {
            "docs": "The name of the Environment the Log is associated to.",
            "type": "optional<string>",
          },
          "error": {
            "docs": "Error message if the log is an error.",
            "type": "optional<string>",
          },
          "finish_reason": {
            "docs": "Reason the generation finished.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "Unique identifier for the Log.",
            "type": "string",
          },
          "inputs": {
            "docs": "The inputs passed to the prompt template.",
            "type": "optional<map<string, unknown>>",
          },
          "messages": {
            "docs": "The messages passed to the to provider chat endpoint.",
            "type": "optional<list<ChatMessage>>",
          },
          "metadata": {
            "docs": "Any additional metadata to record.",
            "type": "optional<map<string, unknown>>",
          },
          "output": {
            "docs": "Generated output from your model for the provided inputs. Can be \`None\` if logging an error, or if creating a parent Log with the intention to populate it later.",
            "type": "optional<string>",
          },
          "output_cost": {
            "docs": "Cost in dollars associated to the tokens in the output.",
            "type": "optional<double>",
          },
          "output_message": {
            "docs": "The message returned by the provider.",
            "type": "optional<ChatMessage>",
          },
          "output_tokens": {
            "docs": "Number of tokens in the output generated by the model.",
            "type": "optional<integer>",
          },
          "parent_id": {
            "docs": "Unique identifier for the parent Log in a Session. Should only be provided if \`session_id\` is provided. If provided, the Log will be nested under the parent Log within the Session.",
            "type": "optional<string>",
          },
          "prompt": {
            "docs": "Prompt details used to generate the log.",
            "type": "PromptResponse",
          },
          "prompt_cost": {
            "docs": "Cost in dollars associated to the tokens in the prompt.",
            "type": "optional<double>",
          },
          "prompt_tokens": {
            "docs": "Number of tokens in the prompt used to generate the output.",
            "type": "optional<integer>",
          },
          "provider_latency": {
            "docs": "Duration of the logged event in seconds.",
            "type": "optional<double>",
          },
          "provider_request": {
            "docs": "Raw request sent to provider.",
            "type": "optional<map<string, unknown>>",
          },
          "provider_response": {
            "docs": "Raw response received the provider.",
            "type": "optional<map<string, unknown>>",
          },
          "raw_output": {
            "docs": "Raw output from the provider.",
            "type": "optional<string>",
          },
          "save": {
            "default": true,
            "docs": "Whether the request/response payloads will be stored on Humanloop.",
            "type": "optional<boolean>",
          },
          "session_id": {
            "docs": "Unique identifier for the Session to associate the Log to. Allows you to record multiple Logs to a Session (using an ID kept by your internal systems) by passing the same \`session_id\` in subsequent log requests. ",
            "type": "optional<string>",
          },
          "source": {
            "docs": "Identifies where the model was called from.",
            "type": "optional<string>",
          },
          "source_datapoint_id": {
            "docs": "Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.",
            "type": "optional<string>",
          },
          "tool_choice": {
            "docs": "Controls how the model uses tools. The following options are supported: 
- \`'none'\` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt. 
- \`'auto'\` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt. 
- \`'required'\` means the model can decide to call one or more of the provided tools. 
- \`{'type': 'function', 'function': {name': <TOOL_NAME>}}\` forces the model to use the named function.",
            "type": "optional<PromptLogResponseToolChoice>",
          },
          "user": {
            "docs": "End-user ID related to the Log.",
            "type": "optional<string>",
          },
        },
      },
      "PromptLogResponseToolChoice": {
        "discriminated": false,
        "docs": "Controls how the model uses tools. The following options are supported: 
- \`'none'\` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt. 
- \`'auto'\` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt. 
- \`'required'\` means the model can decide to call one or more of the provided tools. 
- \`{'type': 'function', 'function': {name': <TOOL_NAME>}}\` forces the model to use the named function.",
        "union": [
          "literal<"none">",
          "literal<"auto">",
          "literal<"required">",
          "ToolChoice",
        ],
      },
      "PromptResponse": {
        "docs": "Request model for creating a new Prompt",
        "properties": {
          "commit_message": {
            "docs": "Message describing the changes made.",
            "type": "optional<string>",
          },
          "created_at": "datetime",
          "created_by": {
            "docs": "The user who created the Prompt.",
            "type": "optional<UserResponse>",
          },
          "directory_id": {
            "docs": "Unique identifier for the Directory of the Prompt. ",
            "type": "optional<string>",
          },
          "endpoint": {
            "docs": "The provider model endpoint used.",
            "type": "optional<ModelEndpoints>",
          },
          "environments": {
            "docs": "The list of environments the Prompt Version is deployed to.",
            "type": "optional<list<EnvironmentResponse>>",
          },
          "frequency_penalty": {
            "default": 0,
            "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "type": "optional<double>",
          },
          "id": {
            "docs": "Unique identifier for the Prompt.",
            "type": "string",
          },
          "inputs": {
            "docs": "Inputs associated to the Prompt. Inputs correspond to any of the variables used within the Prompt template.",
            "type": "list<InputResponse>",
          },
          "last_used_at": "datetime",
          "linked_tools": {
            "docs": "The IDs of the Tools in your organization that the model can choose to call if Tool calling is supported. The default deployed version of that tool is called.",
            "type": "optional<list<LinkedToolResponse>>",
          },
          "max_tokens": {
            "default": -1,
            "docs": "The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt",
            "type": "optional<integer>",
          },
          "model": {
            "docs": "The model instance used, e.g. \`gpt-4\`. See [supported models](https://humanloop.com/docs/supported-models)",
            "type": "string",
          },
          "name": {
            "docs": "Name of the Prompt, which is used as a unique identifier.",
            "type": "string",
          },
          "other": {
            "docs": "Other parameter values to be passed to the provider call.",
            "type": "optional<map<string, unknown>>",
          },
          "presence_penalty": {
            "default": 0,
            "docs": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "type": "optional<double>",
          },
          "provider": {
            "docs": "The company providing the underlying model service.",
            "type": "optional<ModelProviders>",
          },
          "response_format": {
            "docs": "The format of the response. Only \`{"type": "json_object"}\` is currently supported for chat.",
            "type": "optional<ResponseFormat>",
          },
          "seed": {
            "docs": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed.",
            "type": "optional<integer>",
          },
          "status": {
            "docs": "The status of the Prompt Version.",
            "type": "VersionStatus",
          },
          "stop": {
            "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
            "type": "optional<PromptResponseStop>",
          },
          "temperature": {
            "default": 1,
            "docs": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "type": "optional<double>",
          },
          "template": {
            "docs": "For chat endpoint, provide a Chat template. For completion endpoint, provide a Prompt template. Input variables within the template should be specified with double curly bracket syntax: {{INPUT_NAME}}.",
            "type": "optional<Template>",
          },
          "tools": {
            "docs": "The tool specification that the model can choose to call if Tool calling is supported.",
            "type": "optional<list<ToolFunction>>",
          },
          "top_p": {
            "default": 1,
            "docs": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "type": "optional<double>",
          },
          "total_logs_count": {
            "docs": "The number of logs that have been generated across all Prompt Versions",
            "type": "integer",
          },
          "updated_at": "datetime",
          "version_id": {
            "docs": "Unique identifier for the specific Prompt Version. If no query params provided, the default deployed Prompt Version is returned.",
            "type": "string",
          },
          "version_logs_count": {
            "docs": "The number of logs that have been generated for this Prompt Version",
            "type": "integer",
          },
        },
      },
      "PromptResponseStop": {
        "discriminated": false,
        "docs": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
        "union": [
          "string",
          "list<string>",
        ],
      },
      "ProviderApiKeys": {
        "docs": undefined,
        "properties": {
          "ai21": "optional<string>",
          "anthropic": "optional<string>",
          "cohere": "optional<string>",
          "mock": "optional<string>",
          "openai": "optional<string>",
          "openai_azure": "optional<string>",
          "openai_azure_endpoint": "optional<string>",
        },
      },
      "ResponseFormat": {
        "docs": "Response format of the model.",
        "properties": {
          "type": "literal<"json_object">",
        },
      },
      "SessionResponse": {
        "docs": undefined,
        "properties": {
          "created_at": "datetime",
          "id": {
            "docs": "Unique identifier for the Session.",
            "type": "string",
          },
          "logs": {
            "docs": "List of Logs associated with this Session.",
            "type": "list<PromptLogResponse>",
          },
          "updated_at": "datetime",
        },
      },
      "SortOrder": {
        "docs": "An enumeration.",
        "enum": [
          "asc",
          "desc",
        ],
      },
      "Spec": {
        "base-properties": {},
        "discriminant": "evaluator_type",
        "docs": undefined,
        "union": {
          "human": "HumanEvaluatorRequest",
          "llm": "LLMEvaluatorRequest",
          "python": "CodeEvaluatorRequest",
        },
      },
      "Template": {
        "discriminated": false,
        "docs": "For chat endpoint, provide a Chat template. For completion endpoint, provide a Prompt template. Input variables within the template should be specified with double curly bracket syntax: {{INPUT_NAME}}.",
        "union": [
          "string",
          "list<ChatMessage>",
        ],
      },
      "TextChatContent": {
        "docs": undefined,
        "properties": {
          "text": {
            "docs": "The message's text content.",
            "type": "string",
          },
        },
      },
      "TimeUnit": {
        "docs": "An enumeration.",
        "enum": [
          "day",
          "week",
          "month",
        ],
      },
      "ToolCall": {
        "docs": "A tool call to be made.",
        "properties": {
          "function": "FunctionTool",
          "id": "string",
          "type": "ToolType",
        },
      },
      "ToolChoice": {
        "docs": "Tool choice to force the model to use a tool.",
        "properties": {
          "function": "FunctionToolChoice",
          "type": "ToolType",
        },
      },
      "ToolConfigRequest": {
        "docs": "Definition of tool within a model config.

The subset of ToolConfig parameters received by the chat endpoint.
Does not have things like the signature or setup schema.",
        "properties": {
          "description": {
            "docs": "The description of the tool shown to the model.",
            "type": "optional<string>",
          },
          "name": {
            "docs": "The name of the tool shown to the model.",
            "type": "string",
          },
          "other": {
            "docs": "Other parameters that define the config.",
            "type": "optional<map<string, unknown>>",
          },
          "parameters": {
            "docs": "Definition of parameters needed to run the tool. Provided in jsonschema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
          "preset_name": {
            "docs": "If is_preset = true, this is the name of the preset tool on Humanloop. This is used as the key to look up the Humanloop runtime of the tool",
            "type": "optional<string>",
          },
          "source": {
            "docs": "Source of the tool. If defined at an organization level will be 'organization' else 'inline'.",
            "type": "optional<ToolSource>",
          },
          "source_code": {
            "docs": "Code source of the tool.",
            "type": "optional<string>",
          },
          "type": "literal<"tool">",
        },
      },
      "ToolConfigResponse": {
        "docs": undefined,
        "properties": {
          "created_by": {
            "docs": "The user who created the config.",
            "type": "optional<UserResponse>",
          },
          "description": {
            "docs": "Description of the tool referenced by the model",
            "type": "optional<string>",
          },
          "id": {
            "docs": "String ID of config. Starts with \`config_\`.",
            "type": "string",
          },
          "is_preset": {
            "docs": "Whether the tool is one where Humanloop defines runtime or not.",
            "type": "optional<boolean>",
          },
          "name": {
            "docs": "Name for the tool referenced by the model.",
            "type": "string",
          },
          "other": {
            "docs": "Other parameters that define the config.",
            "type": "optional<map<string, unknown>>",
          },
          "parameters": {
            "docs": "Definition of parameters needed to run the tool. Provided in jsonschema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
          "preset_name": {
            "docs": "If is_preset = true, this is the name of the preset tool on Humanloop. This is used as the key to lookup the Humanloop runtime of the tool",
            "type": "optional<string>",
          },
          "setup_schema": {
            "docs": "Definition of parameters needed to run the tool. Provided in jsonschema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
          "signature": {
            "docs": "The function signature of the tool when being called.",
            "type": "optional<string>",
          },
          "source": {
            "docs": "Source of the tool. If defined at an organization level will be 'organization' else 'inline'.",
            "type": "optional<ToolSource>",
          },
          "source_code": {
            "docs": "Code source of the tool.",
            "type": "optional<string>",
          },
          "status": {
            "docs": "Whether the config is committed or not.",
            "type": "string",
          },
        },
      },
      "ToolFunction": {
        "docs": undefined,
        "properties": {
          "description": {
            "docs": "Description of the tool referenced by the model",
            "type": "string",
          },
          "name": {
            "docs": "Name for the tool referenced by the model.",
            "type": "string",
          },
          "parameters": {
            "docs": "Parameters needed to run the Tool, defined in JSON Schema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
        },
      },
      "ToolKernelRequest": {
        "docs": undefined,
        "properties": {
          "function": {
            "docs": "Callable function specification of the Tool shown to the model for tool calling.",
            "type": "optional<ToolFunction>",
          },
          "setup_values": {
            "docs": "Values needed to setup the Tool, defined in JSON Schema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
          "source_code": {
            "docs": "Code source of the Tool.",
            "type": "optional<string>",
          },
        },
      },
      "ToolResponse": {
        "docs": "Request to create a new Tool.",
        "properties": {
          "commit_message": {
            "docs": "Message describing the changes made.",
            "type": "optional<string>",
          },
          "created_at": "datetime",
          "created_by": {
            "docs": "The user who created the Prompt.",
            "type": "optional<UserResponse>",
          },
          "directory_id": {
            "docs": "Unique identifier for the Directory of the Prompt. ",
            "type": "optional<string>",
          },
          "environments": {
            "docs": "The list of environments the Prompt Version is deployed to.",
            "type": "optional<list<EnvironmentResponse>>",
          },
          "function": {
            "docs": "Callable function specification of the Tool shown to the model for tool calling.",
            "type": "optional<ToolFunction>",
          },
          "id": {
            "docs": "Unique identifier for Tool.",
            "type": "string",
          },
          "inputs": {
            "docs": "Inputs associated to the Prompt. Inputs correspond to any of the variables used within the Prompt template.",
            "type": "list<InputResponse>",
          },
          "last_used_at": "datetime",
          "name": {
            "docs": "Name of the Tool, which is used as a unique identifier.",
            "type": "string",
          },
          "setup_values": {
            "docs": "Values needed to setup the Tool, defined in JSON Schema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
          "signature": {
            "docs": "Signature of the Tool.",
            "type": "optional<string>",
          },
          "source_code": {
            "docs": "Code source of the Tool.",
            "type": "optional<string>",
          },
          "status": {
            "docs": "The status of the Prompt Version.",
            "type": "VersionStatus",
          },
          "tool_type": {
            "docs": "Type of Tool.",
            "type": "optional<ToolType>",
          },
          "total_logs_count": {
            "docs": "The number of logs that have been generated across all Prompt Versions",
            "type": "integer",
          },
          "updated_at": "datetime",
          "version_id": {
            "docs": "Unique identifier for the specific Tool Version. If no query params provided, the default deployed Tool Version is returned.",
            "type": "string",
          },
          "version_logs_count": {
            "docs": "The number of logs that have been generated for this Prompt Version",
            "type": "integer",
          },
        },
      },
      "ToolResultResponse": {
        "docs": "A result from a tool used to populate the prompt template",
        "properties": {
          "id": "string",
          "name": "string",
          "result": "string",
          "signature": "string",
        },
      },
      "ToolSource": {
        "docs": "Source of tool. Used to differentiate between tools and tool versions when they are combined in a list.

V4 uses organization and inline. Those are deprecated and will be removed in favour of tool and tool_version.",
        "enum": [
          "organization",
          "inline",
        ],
      },
      "ToolTemplateResponse": {
        "docs": "Template for a Humanloop runnable tool.",
        "properties": {
          "description": {
            "docs": "Description of the tool referenced by the model",
            "type": "string",
          },
          "name": {
            "docs": "Name for the tool referenced by the model.",
            "type": "string",
          },
          "parameters": {
            "docs": "Parameters needed to run the Tool, defined in JSON Schema format: https://json-schema.org/",
            "type": "optional<map<string, unknown>>",
          },
          "setup_schema": {
            "docs": "Schema required to setup the Tool runtime, e.g. API keys.",
            "type": "optional<map<string, unknown>>",
          },
          "signature": {
            "docs": "Signature of the Tool.",
            "type": "optional<string>",
          },
        },
      },
      "ToolType": {
        "docs": "Type of tool.",
        "enum": [
          "pinecone_search",
          "google",
          "mock",
          "snippet",
          "json_schema",
          "get_api_call",
        ],
      },
      "UpdateDatesetAction": {
        "docs": "An enumeration.",
        "enum": [
          "set",
          "add",
          "remove",
        ],
      },
      "UserResponse": {
        "docs": undefined,
        "properties": {
          "email_address": {
            "docs": "The User's email address.",
            "type": "string",
          },
          "full_name": {
            "docs": "The User's full name.",
            "type": "optional<string>",
          },
          "id": {
            "docs": "Unique identifier for User. Starts with \`usr\`.",
            "type": "string",
          },
        },
      },
      "ValidationError": {
        "docs": undefined,
        "properties": {
          "loc": "list<ValidationErrorLocItem>",
          "msg": "string",
          "type": "string",
        },
      },
      "ValidationErrorLocItem": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "string",
          "integer",
        ],
      },
      "Value": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "boolean",
          "double",
        ],
      },
      "Version": {
        "discriminated": false,
        "docs": "The specific Version being referenced.",
        "union": [
          "PromptResponse",
          "ToolResponse",
          "DatasetResponse",
          "EvaluatorResponse",
        ],
      },
      "VersionDeploymentResponse": {
        "docs": "A variable reference to the Version deployed to an Environment",
        "properties": {
          "environment": {
            "docs": "The Environment that the Version is deployed to.",
            "type": "EnvironmentResponse",
          },
          "file": {
            "docs": "The File that the deployed Version belongs to.",
            "type": "File",
          },
        },
      },
      "VersionIdResponse": {
        "docs": "A reference to a specific Version by its ID",
        "properties": {
          "version": {
            "docs": "The specific Version being referenced.",
            "type": "Version",
          },
        },
      },
      "VersionReferenceResponse": {
        "base-properties": {},
        "discriminant": "type",
        "docs": undefined,
        "union": {
          "environment": "VersionDeploymentResponse",
          "version": "VersionIdResponse",
        },
      },
      "VersionStats": {
        "docs": "Stats for an Evaluated Version in the Evaluation Report.",
        "properties": {
          "evaluator_version_stats": {
            "docs": "Stats for each Evaluator Version used to evaluate this Evaluated Version.",
            "type": "list<VersionStatsEvaluatorVersionStatsItem>",
          },
          "num_logs": {
            "docs": "The total number of existing Logs for this Evaluated Version within the Evaluation Report. These are Logs that have been generated by this Evaluated Version on a Datapoint belonging to the Evaluation Report's Dataset Version.",
            "type": "integer",
          },
          "version_id": {
            "docs": "Unique identifier for the Evaluated Version.",
            "type": "string",
          },
        },
      },
      "VersionStatsEvaluatorVersionStatsItem": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "NumericEvaluatorVersionStats",
          "BooleanEvaluatorVersionStats",
        ],
      },
      "VersionStatus": {
        "docs": "An enumeration.",
        "enum": [
          "uncommitted",
          "committed",
          "deleted",
        ],
      },
    },
  },
  "rootApiFile": {
    "auth": "APIKeyHeader",
    "auth-schemes": {
      "APIKeyHeader": {
        "header": "X-API-KEY",
        "name": "apiKey",
        "type": "string",
      },
    },
    "default-environment": "Default",
    "display-name": "Humanloop API",
    "environments": {
      "Default": "https://api.humanloop.com/v5",
    },
    "error-discrimination": {
      "strategy": "status-code",
    },
    "name": "api",
  },
}
`;
