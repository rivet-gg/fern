// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`SdkGenerator should generate for examples 1`] = `
"/// File: /jest.config.js
/** @type {import('jest').Config} */
module.exports = { preset: "ts-jest", testEnvironment: "node" };


/// File: /src/api/index.ts
export * from "./types";
export * from "./resources";


/// File: /src/api/resources/commons/index.ts
export * from "./resources";


/// File: /src/api/resources/commons/resources/index.ts
export * as types from "./types";
export * from "./types/types";


/// File: /src/api/resources/commons/resources/types/index.ts
export * from "./types";


/// File: /src/api/resources/commons/resources/types/types/Data.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../../../../../index";

/**
 * @example
 *     {
 *         type: "string",
 *         value: "data"
 *     }
 */
export type Data = 
    | TestSdk.commons.Data.String
    | TestSdk.commons.Data.Base64;

export declare namespace Data {
    interface String {
        type: "string";
        value: string;
    }

    interface Base64 {
        type: "base64";
        value: string;
    }
}


/// File: /src/api/resources/commons/resources/types/types/EventInfo.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../../../../../index";

/**
 * @example
 *     {
 *         type: "metadata",
 *         id: "metadata-alskjfg8",
 *         data: {
 *             "one": "two"
 *         },
 *         jsonString: "{\\"one\\": \\"two\\"}"
 *     }
 */
export type EventInfo = 
    | TestSdk.commons.EventInfo.Metadata
    | TestSdk.commons.EventInfo.Tag;

export declare namespace EventInfo {
    interface Metadata extends TestSdk.commons.Metadata {
        type: "metadata";
    }

    interface Tag {
        type: "tag";
        value: TestSdk.commons.Tag;
    }
}


/// File: /src/api/resources/commons/resources/types/types/index.ts
export * from "./Tag";
export * from "./Metadata";
export * from "./EventInfo";
export * from "./Data";


/// File: /src/api/resources/commons/resources/types/types/Metadata.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         id: "metadata-js8dg24b",
 *         data: {
 *             "foo": "bar",
 *             "baz": "qux"
 *         },
 *         jsonString: "{\\"foo\\": \\"bar\\", \\"baz\\": \\"qux\\"}"
 *     }
 */
export interface Metadata {
    "id": string;
    "data"?: Record<string, string>;
    "jsonString"?: string;
}


/// File: /src/api/resources/commons/resources/types/types/Tag.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     "tag-wf9as23d"
 */
export type Tag = string;


/// File: /src/api/resources/file/client/Client.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import { Notification } from "../resources/notification/client/Client";
import { Service } from "../resources/service/client/Client";

export declare namespace File_ {
    interface Options {
        environment: core.Supplier<environments.TestSdkEnvironment | string>;
        token?: core.Supplier<core.BearerToken | undefined>;
    }

    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}

export class File_ {
    constructor(protected readonly _options: File_.Options) {
    }

    protected _notification: Notification | undefined;

    public get notification(): Notification {
        return (this._notification ??= new Notification(this._options));
    }

    protected _service: Service | undefined;

    public get service(): Service {
        return (this._service ??= new Service(this._options));
    }
}


/// File: /src/api/resources/file/client/index.ts
export { };


/// File: /src/api/resources/file/index.ts
export * from "./resources";
export * from "./client";


/// File: /src/api/resources/file/resources/index.ts
export * as service from "./service";
export * from "./service/types";
export * as notification from "./notification";
export * from "./service/client/requests";


/// File: /src/api/resources/file/resources/notification/client/Client.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../../../environments";
import * as core from "../../../../../../core";
import { Service } from "../resources/service/client/Client";

export declare namespace Notification {
    interface Options {
        environment: core.Supplier<environments.TestSdkEnvironment | string>;
        token?: core.Supplier<core.BearerToken | undefined>;
    }

    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}

export class Notification {
    constructor(protected readonly _options: Notification.Options) {
    }

    protected _service: Service | undefined;

    public get service(): Service {
        return (this._service ??= new Service(this._options));
    }
}


/// File: /src/api/resources/file/resources/notification/client/index.ts
export { };


/// File: /src/api/resources/file/resources/notification/index.ts
export * from "./client";
export * from "./resources";


/// File: /src/api/resources/file/resources/notification/resources/index.ts
export * as service from "./service";


/// File: /src/api/resources/file/resources/notification/resources/service/client/Client.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../../../../../environments";
import * as core from "../../../../../../../../core";
import * as TestSdk from "../../../../../../../index";
import urlJoin from "url-join";
import * as serializers from "../../../../../../../../serialization/index";
import * as errors from "../../../../../../../../errors/index";

export declare namespace Service {
    interface Options {
        environment: core.Supplier<environments.TestSdkEnvironment | string>;
        token?: core.Supplier<core.BearerToken | undefined>;
    }

    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}

export class Service {
    constructor(protected readonly _options: Service.Options) {
    }

    /**
     * @param {string} notificationId
     * @param {Service.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await testSdk.file.notification.service.getException("notification-hsy129x")
     */
    public async getException(notificationId: string, requestOptions?: Service.RequestOptions): Promise<TestSdk.Exception> {
        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), \`/file/notification/\${encodeURIComponent(notificationId)}\`),
            method: "GET",
            headers: {
                "Authorization": await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "@test/sdk",
                "X-Fern-SDK-Version": "1.0.0",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version
            },
            contentType: "application/json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? (requestOptions.timeoutInSeconds * 1000) : 60000,
            maxRetries: requestOptions?.maxRetries
        });
        if (_response.ok) {
            return await serializers.Exception.parseOrThrow(_response.body, { unrecognizedObjectKeys: "passthrough", allowUnrecognizedUnionMembers: true, allowUnrecognizedEnumValues: true, breadcrumbsPrefix: ["response"] });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.body
            });
        }

        switch (_response.error.reason) {
            case "non-json": throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
            });
            case "timeout": throw new errors.TestSdkTimeoutError;
            case "unknown": throw new errors.TestSdkError({
                message: _response.error.errorMessage
            });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = await core.Supplier.get(this._options.token);
        if (bearer != null) {
            return \`Bearer \${bearer}\`;
        }

        return undefined;
    }
}


/// File: /src/api/resources/file/resources/notification/resources/service/client/index.ts
export { };


/// File: /src/api/resources/file/resources/notification/resources/service/index.ts
export * from "./client";


/// File: /src/api/resources/file/resources/service/client/Client.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../../../environments";
import * as core from "../../../../../../core";
import * as TestSdk from "../../../../../index";
import urlJoin from "url-join";
import * as serializers from "../../../../../../serialization/index";
import * as errors from "../../../../../../errors/index";

export declare namespace Service {
    interface Options {
        environment: core.Supplier<environments.TestSdkEnvironment | string>;
        token?: core.Supplier<core.BearerToken | undefined>;
    }

    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}

export class Service {
    constructor(protected readonly _options: Service.Options) {
    }

    /**
     * This endpoint returns a file by its name.
     *
     * @param {string} filename - This is a filename
     * @param {TestSdk.file.GetFileRequest} request
     * @param {Service.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link TestSdk.NotFoundError}
     *
     * @example
     *     await testSdk.file.service.getFile("file.txt", {
     *         xFileApiVersion: "0.0.2"
     *     })
     */
    public async getFile(filename: string, request: TestSdk.file.GetFileRequest, requestOptions?: Service.RequestOptions): Promise<TestSdk.File_> {
        const { xFileApiVersion } = request;
        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), \`/file/\${encodeURIComponent(filename)}\`),
            method: "GET",
            headers: {
                "Authorization": await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "@test/sdk",
                "X-Fern-SDK-Version": "1.0.0",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                "X-File-API-Version": xFileApiVersion
            },
            contentType: "application/json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? (requestOptions.timeoutInSeconds * 1000) : 60000,
            maxRetries: requestOptions?.maxRetries
        });
        if (_response.ok) {
            return await serializers.File_.parseOrThrow(_response.body, { unrecognizedObjectKeys: "passthrough", allowUnrecognizedUnionMembers: true, allowUnrecognizedEnumValues: true, breadcrumbsPrefix: ["response"] });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404: throw new TestSdk.NotFoundError(await serializers.NotFoundError.parseOrThrow(_response.error.body, { unrecognizedObjectKeys: "passthrough", allowUnrecognizedUnionMembers: true, allowUnrecognizedEnumValues: true, breadcrumbsPrefix: ["response"] }));
                default: throw new errors.TestSdkError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body
                });
            }
        }

        switch (_response.error.reason) {
            case "non-json": throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
            });
            case "timeout": throw new errors.TestSdkTimeoutError;
            case "unknown": throw new errors.TestSdkError({
                message: _response.error.errorMessage
            });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = await core.Supplier.get(this._options.token);
        if (bearer != null) {
            return \`Bearer \${bearer}\`;
        }

        return undefined;
    }
}


/// File: /src/api/resources/file/resources/service/client/index.ts
export * from "./requests";


/// File: /src/api/resources/file/resources/service/client/requests/GetFileRequest.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         xFileApiVersion: "0.0.2"
 *     }
 */
export interface GetFileRequest {
    "xFileApiVersion": string;
}


/// File: /src/api/resources/file/resources/service/client/requests/index.ts
export { type GetFileRequest } from "./GetFileRequest";


/// File: /src/api/resources/file/resources/service/index.ts
export * from "./types";
export * from "./client";


/// File: /src/api/resources/file/resources/service/types/Filename.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     "file.txt"
 */
export type Filename = string;


/// File: /src/api/resources/file/resources/service/types/index.ts
export * from "./Filename";


/// File: /src/api/resources/health/client/Client.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import { Service } from "../resources/service/client/Client";

export declare namespace Health {
    interface Options {
        environment: core.Supplier<environments.TestSdkEnvironment | string>;
        token?: core.Supplier<core.BearerToken | undefined>;
    }

    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}

export class Health {
    constructor(protected readonly _options: Health.Options) {
    }

    protected _service: Service | undefined;

    public get service(): Service {
        return (this._service ??= new Service(this._options));
    }
}


/// File: /src/api/resources/health/client/index.ts
export { };


/// File: /src/api/resources/health/index.ts
export * from "./client";
export * from "./resources";


/// File: /src/api/resources/health/resources/index.ts
export * as service from "./service";


/// File: /src/api/resources/health/resources/service/client/Client.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../../../environments";
import * as core from "../../../../../../core";
import urlJoin from "url-join";
import * as errors from "../../../../../../errors/index";
import * as serializers from "../../../../../../serialization/index";

export declare namespace Service {
    interface Options {
        environment: core.Supplier<environments.TestSdkEnvironment | string>;
        token?: core.Supplier<core.BearerToken | undefined>;
    }

    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}

export class Service {
    constructor(protected readonly _options: Service.Options) {
    }

    /**
     * This endpoint checks the health of a resource.
     *
     * @param {string} id - The id to check
     * @param {Service.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await testSdk.health.service.check("id-2sdx82h")
     */
    public async check(id: string, requestOptions?: Service.RequestOptions): Promise<void> {
        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), \`/check/\${encodeURIComponent(id)}\`),
            method: "GET",
            headers: {
                "Authorization": await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "@test/sdk",
                "X-Fern-SDK-Version": "1.0.0",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version
            },
            contentType: "application/json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? (requestOptions.timeoutInSeconds * 1000) : 60000,
            maxRetries: requestOptions?.maxRetries
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.body
            });
        }

        switch (_response.error.reason) {
            case "non-json": throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
            });
            case "timeout": throw new errors.TestSdkTimeoutError;
            case "unknown": throw new errors.TestSdkError({
                message: _response.error.errorMessage
            });
        }
    }

    /**
     * This endpoint checks the health of the service.
     *
     * @param {Service.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await testSdk.health.service.ping()
     */
    public async ping(requestOptions?: Service.RequestOptions): Promise<boolean> {
        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "/ping"),
            method: "GET",
            headers: {
                "Authorization": await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "@test/sdk",
                "X-Fern-SDK-Version": "1.0.0",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version
            },
            contentType: "application/json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? (requestOptions.timeoutInSeconds * 1000) : 60000,
            maxRetries: requestOptions?.maxRetries
        });
        if (_response.ok) {
            return await serializers.health.service.ping.Response.parseOrThrow(_response.body, { unrecognizedObjectKeys: "passthrough", allowUnrecognizedUnionMembers: true, allowUnrecognizedEnumValues: true, breadcrumbsPrefix: ["response"] });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.body
            });
        }

        switch (_response.error.reason) {
            case "non-json": throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
            });
            case "timeout": throw new errors.TestSdkTimeoutError;
            case "unknown": throw new errors.TestSdkError({
                message: _response.error.errorMessage
            });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = await core.Supplier.get(this._options.token);
        if (bearer != null) {
            return \`Bearer \${bearer}\`;
        }

        return undefined;
    }
}


/// File: /src/api/resources/health/resources/service/client/index.ts
export { };


/// File: /src/api/resources/health/resources/service/index.ts
export * from "./client";


/// File: /src/api/resources/index.ts
export * as commons from "./commons";
export * as file from "./file";
export * as types from "./types";
export * from "./types/types";
export * from "./types/errors";
export * as health from "./health";
export * as service from "./service";
export * from "./service/client/requests";


/// File: /src/api/resources/service/client/Client.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import * as TestSdk from "../../../index";
import * as serializers from "../../../../serialization/index";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index";

export declare namespace Service {
    interface Options {
        environment: core.Supplier<environments.TestSdkEnvironment | string>;
        token?: core.Supplier<core.BearerToken | undefined>;
    }

    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}

export class Service {
    constructor(protected readonly _options: Service.Options) {
    }

    /**
     * @param {TestSdk.MovieId} movieId
     * @param {Service.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await testSdk.service.getMovie("movie-c06a4ad7")
     */
    public async getMovie(movieId: TestSdk.MovieId, requestOptions?: Service.RequestOptions): Promise<TestSdk.Movie> {
        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), \`/movie/\${encodeURIComponent(await serializers.MovieId.jsonOrThrow(movieId))}\`),
            method: "GET",
            headers: {
                "Authorization": await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "@test/sdk",
                "X-Fern-SDK-Version": "1.0.0",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version
            },
            contentType: "application/json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? (requestOptions.timeoutInSeconds * 1000) : 60000,
            maxRetries: requestOptions?.maxRetries
        });
        if (_response.ok) {
            return await serializers.Movie.parseOrThrow(_response.body, { unrecognizedObjectKeys: "passthrough", allowUnrecognizedUnionMembers: true, allowUnrecognizedEnumValues: true, breadcrumbsPrefix: ["response"] });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.body
            });
        }

        switch (_response.error.reason) {
            case "non-json": throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
            });
            case "timeout": throw new errors.TestSdkTimeoutError;
            case "unknown": throw new errors.TestSdkError({
                message: _response.error.errorMessage
            });
        }
    }

    /**
     * @param {TestSdk.Movie} request
     * @param {Service.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await testSdk.service.createMovie({
     *         id: "movie-c06a4ad7",
     *         prequel: "movie-cv9b914f",
     *         title: "The Boy and the Heron",
     *         from: "Hayao Miyazaki",
     *         rating: 8,
     *         type: "movie",
     *         tag: "tag-wf9as23d",
     *         metadata: {
     *             "actors": [
     *                 "Christian Bale",
     *                 "Florence Pugh",
     *                 "Willem Dafoe"
     *             ],
     *             "releaseDate": "2023-12-08",
     *             "ratings": {
     *                 "rottenTomatoes": 97,
     *                 "imdb": 7.6
     *             }
     *         }
     *     })
     */
    public async createMovie(request: TestSdk.Movie, requestOptions?: Service.RequestOptions): Promise<TestSdk.MovieId> {
        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "/movie"),
            method: "POST",
            headers: {
                "Authorization": await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "@test/sdk",
                "X-Fern-SDK-Version": "1.0.0",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version
            },
            contentType: "application/json",
            body: await serializers.Movie.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? (requestOptions.timeoutInSeconds * 1000) : 60000,
            maxRetries: requestOptions?.maxRetries
        });
        if (_response.ok) {
            return await serializers.MovieId.parseOrThrow(_response.body, { unrecognizedObjectKeys: "passthrough", allowUnrecognizedUnionMembers: true, allowUnrecognizedEnumValues: true, breadcrumbsPrefix: ["response"] });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.body
            });
        }

        switch (_response.error.reason) {
            case "non-json": throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
            });
            case "timeout": throw new errors.TestSdkTimeoutError;
            case "unknown": throw new errors.TestSdkError({
                message: _response.error.errorMessage
            });
        }
    }

    /**
     * @param {TestSdk.GetMetadataRequest} request
     * @param {Service.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await testSdk.service.getMetadata({
     *         xApiVersion: "0.0.1",
     *         shallow: false,
     *         tag: "development"
     *     })
     */
    public async getMetadata(request: TestSdk.GetMetadataRequest, requestOptions?: Service.RequestOptions): Promise<TestSdk.Metadata> {
        const { shallow, tag, xApiVersion } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (shallow != null) {
            _queryParams["shallow"] = shallow.toString();
        }

        if (tag != null) {
            if (Array.isArray(tag)) {
                _queryParams["tag"] = tag.map(item => item);
            }
            else {
                _queryParams["tag"] = tag;
            }
        }

        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "/metadata"),
            method: "GET",
            headers: {
                "Authorization": await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "@test/sdk",
                "X-Fern-SDK-Version": "1.0.0",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                "X-API-Version": xApiVersion
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? (requestOptions.timeoutInSeconds * 1000) : 60000,
            maxRetries: requestOptions?.maxRetries
        });
        if (_response.ok) {
            return await serializers.Metadata.parseOrThrow(_response.body, { unrecognizedObjectKeys: "passthrough", allowUnrecognizedUnionMembers: true, allowUnrecognizedEnumValues: true, breadcrumbsPrefix: ["response"] });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.body
            });
        }

        switch (_response.error.reason) {
            case "non-json": throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
            });
            case "timeout": throw new errors.TestSdkTimeoutError;
            case "unknown": throw new errors.TestSdkError({
                message: _response.error.errorMessage
            });
        }
    }

    /**
     * @param {Service.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await testSdk.service.getResponse()
     */
    public async getResponse(requestOptions?: Service.RequestOptions): Promise<TestSdk.Response> {
        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "/response"),
            method: "POST",
            headers: {
                "Authorization": await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "@test/sdk",
                "X-Fern-SDK-Version": "1.0.0",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version
            },
            contentType: "application/json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? (requestOptions.timeoutInSeconds * 1000) : 60000,
            maxRetries: requestOptions?.maxRetries
        });
        if (_response.ok) {
            return await serializers.Response.parseOrThrow(_response.body, { unrecognizedObjectKeys: "passthrough", allowUnrecognizedUnionMembers: true, allowUnrecognizedEnumValues: true, breadcrumbsPrefix: ["response"] });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.body
            });
        }

        switch (_response.error.reason) {
            case "non-json": throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
            });
            case "timeout": throw new errors.TestSdkTimeoutError;
            case "unknown": throw new errors.TestSdkError({
                message: _response.error.errorMessage
            });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = await core.Supplier.get(this._options.token);
        if (bearer != null) {
            return \`Bearer \${bearer}\`;
        }

        return undefined;
    }
}


/// File: /src/api/resources/service/client/index.ts
export * from "./requests";


/// File: /src/api/resources/service/client/requests/GetMetadataRequest.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         xApiVersion: "0.0.1",
 *         shallow: false,
 *         tag: "development"
 *     }
 */
export interface GetMetadataRequest {
    "shallow"?: boolean;
    "tag"?: string | string[];
    "xApiVersion": string;
}


/// File: /src/api/resources/service/client/requests/index.ts
export { type GetMetadataRequest } from "./GetMetadataRequest";


/// File: /src/api/resources/service/index.ts
export * from "./client";


/// File: /src/api/resources/types/errors/index.ts
export * from "./NotFoundError";


/// File: /src/api/resources/types/errors/NotFoundError.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as errors from "../../../../errors/index";

export class NotFoundError extends errors.TestSdkError {
    constructor(body: string) {
        super({
            message: "NotFoundError",
            statusCode: 404,
            body: body
        });
        Object.setPrototypeOf(this, NotFoundError.prototype);
    }
}


/// File: /src/api/resources/types/index.ts
export * from "./types";
export * from "./errors";


/// File: /src/api/resources/types/types/Actor.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface Actor {
    "name": string;
    "id": string;
}


/// File: /src/api/resources/types/types/Actress.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         name: "Jennifer Lawrence",
 *         id: "actor_456"
 *     }
 */
export interface Actress {
    "name": string;
    "id": string;
}


/// File: /src/api/resources/types/types/CastMember.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../../../index";

/**
 * @example
 *     {
 *         id: "actor_123",
 *         name: "Brad Pitt"
 *     }
 *
 * @example
 *     {
 *         name: "Jennifer Lawrence",
 *         id: "actor_456"
 *     }
 */
export type CastMember = 
    | TestSdk.Actor
    | TestSdk.Actress
    | TestSdk.StuntDouble;


/// File: /src/api/resources/types/types/Directory.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../../../index";

/**
 * @example
 *     {
 *         name: "root",
 *         files: [{
 *                 name: "file.txt",
 *                 contents: "..."
 *             }],
 *         directories: [{
 *                 name: "tmp",
 *                 files: [{
 *                         name: "another_file.txt",
 *                         contents: "..."
 *                     }]
 *             }]
 *     }
 */
export interface Directory {
    "name": string;
    "files"?: TestSdk.File_[];
    "directories"?: TestSdk.Directory[];
}


/// File: /src/api/resources/types/types/Entity.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../../../index";

/**
 * @example
 *     {
 *         type: TestSdk.ComplexType.Unknown,
 *         name: "unknown"
 *     }
 */
export interface Entity {
    "type": TestSdk.Type;
    "name": string;
}


/// File: /src/api/resources/types/types/Exception.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../../../index";

/**
 * @example
 *     {
 *         type: "generic",
 *         exceptionType: "Unavailable",
 *         exceptionMessage: "This component is unavailable!",
 *         exceptionStacktrace: "<logs>"
 *     }
 */
export type Exception = 
    | TestSdk.Exception.Generic
    | TestSdk.Exception.Timeout;

export declare namespace Exception {
    interface Generic extends TestSdk.ExceptionInfo {
        type: "generic";
    }

    interface Timeout {
        type: "timeout";
    }
}


/// File: /src/api/resources/types/types/ExceptionInfo.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         exceptionType: "Unavailable",
 *         exceptionMessage: "This component is unavailable!",
 *         exceptionStacktrace: "<logs>"
 *     }
 */
export interface ExceptionInfo {
    "exceptionType": string;
    "exceptionMessage": string;
    "exceptionStacktrace": string;
}


/// File: /src/api/resources/types/types/ExtendedMovie.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../../../index";

/**
 * @example
 *     {
 *         id: "movie-sda231x",
 *         title: "Pulp Fiction",
 *         from: "Quentin Tarantino",
 *         rating: 8.5,
 *         type: "movie",
 *         tag: "tag-12efs9dv",
 *         cast: ["John Travolta", "Samuel L. Jackson", "Uma Thurman", "Bruce Willis"],
 *         metadata: {
 *             "academyAward": true,
 *             "releaseDate": "2023-12-08",
 *             "ratings": {
 *                 "rottenTomatoes": 97,
 *                 "imdb": 7.6
 *             }
 *         }
 *     }
 */
export interface ExtendedMovie extends TestSdk.Movie {
    "cast": string[];
}


/// File: /src/api/resources/types/types/File_.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         name: "file.txt",
 *         contents: "..."
 *     }
 *
 * @example
 *     {
 *         name: "another_file.txt",
 *         contents: "..."
 *     }
 */
export interface File_ {
    "name": string;
    "contents": string;
}


/// File: /src/api/resources/types/types/index.ts
export * from "./MovieId";
export * from "./Movie";
export * from "./CastMember";
export * from "./Actor";
export * from "./Actress";
export * from "./StuntDouble";
export * from "./ExtendedMovie";
export * from "./Moment";
export * from "./File_";
export * from "./Directory";
export * from "./Node";
export * from "./Tree";
export * from "./Metadata";
export * from "./Exception";
export * from "./ExceptionInfo";
export * from "./MigrationStatus";
export * from "./Migration";
export * from "./Request";
export * from "./Response";
export * from "./ResponseType";
export * from "./Test";
export * from "./Entity";


/// File: /src/api/resources/types/types/Metadata.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../../../index";

/**
 * @example
 *     {
 *         type: "html",
 *         value: "<head>...</head>"
 *     }
 */
export type Metadata = 
    | TestSdk.Metadata.Html
    | TestSdk.Metadata.Markdown;

export declare namespace Metadata {
    interface Html extends _Base {
        type: "html";
        value: string;
    }

    interface Markdown extends _Base {
        type: "markdown";
        value: string;
    }

    interface _Base {
        extra: Record<string, string>;
        tags: Set<string>;
    }
}


/// File: /src/api/resources/types/types/Migration.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../../../index";

/**
 * @example
 *     {
 *         name: "001_init",
 *         status: TestSdk.MigrationStatus.Running
 *     }
 */
export interface Migration {
    "name": string;
    "status": TestSdk.MigrationStatus;
}


/// File: /src/api/resources/types/types/MigrationStatus.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     TestSdk.MigrationStatus.Running
 *
 * @example
 *     TestSdk.MigrationStatus.Failed
 */
export type MigrationStatus = 
    /**
     * The migration is running. */
    | "RUNNING"
    /**
     * The migration failed. */
    | "FAILED"
    | "FINISHED";

export const MigrationStatus = {
        Running: "RUNNING",
        Failed: "FAILED",
        Finished: "FINISHED"
    } as const;


/// File: /src/api/resources/types/types/Moment.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         id: "656f12d6-f592-444c-a1d3-a3cfd46d5b39",
 *         date: "1994-01-01",
 *         datetime: new Date("1994-01-01T01:01:01.000Z")
 *     }
 */
export interface Moment {
    "id": string;
    "date": string;
    "datetime": Date;
}


/// File: /src/api/resources/types/types/Movie.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../../../index";

/**
 * @example
 *     {
 *         id: "movie-c06a4ad7",
 *         prequel: "movie-cv9b914f",
 *         title: "The Boy and the Heron",
 *         from: "Hayao Miyazaki",
 *         rating: 8,
 *         type: "movie",
 *         tag: "tag-wf9as23d",
 *         metadata: {
 *             "actors": [
 *                 "Christian Bale",
 *                 "Florence Pugh",
 *                 "Willem Dafoe"
 *             ],
 *             "releaseDate": "2023-12-08",
 *             "ratings": {
 *                 "rottenTomatoes": 97,
 *                 "imdb": 7.6
 *             }
 *         }
 *     }
 */
export interface Movie {
    "id": TestSdk.MovieId;
    "prequel"?: TestSdk.MovieId;
    "title": string;
    "from": string;
    /** The rating scale is one to five stars */
    "rating": number;
    "type": "movie";
    "tag": TestSdk.commons.Tag;
    "book"?: string;
    "metadata": Record<string, unknown>;
}


/// File: /src/api/resources/types/types/MovieId.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     "movie-c06a4ad7"
 */
export type MovieId = string;


/// File: /src/api/resources/types/types/Node.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../../../index";

/**
 * @example
 *     {
 *         name: "root",
 *         nodes: [{
 *                 name: "left"
 *             }, {
 *                 name: "right"
 *             }],
 *         trees: [{
 *                 nodes: [{
 *                         name: "left"
 *                     }, {
 *                         name: "right"
 *                     }]
 *             }]
 *     }
 *
 * @example
 *     {
 *         name: "left"
 *     }
 *
 * @example
 *     {
 *         name: "right"
 *     }
 */
export interface Node {
    "name": string;
    "nodes"?: TestSdk.Node[];
    "trees"?: TestSdk.Tree[];
}


/// File: /src/api/resources/types/types/Request.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         request: {}
 *     }
 */
export interface Request {
    "request"?: unknown;
}


/// File: /src/api/resources/types/types/Response.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../../../index";

/**
 * @example
 *     {
 *         response: "Initializing...",
 *         identifiers: [{
 *                 type: TestSdk.BasicType.Primitive,
 *                 value: "example",
 *                 label: "Primitive"
 *             }, {
 *                 type: TestSdk.ComplexType.Unknown,
 *                 value: "{}",
 *                 label: "Unknown"
 *             }]
 *     }
 */
export interface Response {
    "response"?: unknown;
    "identifiers": TestSdk.Identifier[];
}


/// File: /src/api/resources/types/types/ResponseType.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../../../index";

export interface ResponseType {
    "type": TestSdk.Type;
}


/// File: /src/api/resources/types/types/StuntDouble.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface StuntDouble {
    "name": string;
    "actorOrActressId": string;
}


/// File: /src/api/resources/types/types/Test.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../../../index";

/**
 * @example
 *     {
 *         type: "and",
 *         value: true
 *     }
 *
 * @example
 *     {
 *         type: "or",
 *         value: true
 *     }
 */
export type Test = 
    | TestSdk.Test.And
    | TestSdk.Test.Or;

export declare namespace Test {
    interface And {
        type: "and";
        value: boolean;
    }

    interface Or {
        type: "or";
        value: boolean;
    }
}


/// File: /src/api/resources/types/types/Tree.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../../../index";

/**
 * @example
 *     {
 *         nodes: [{
 *                 name: "left"
 *             }, {
 *                 name: "right"
 *             }]
 *     }
 */
export interface Tree {
    "nodes"?: TestSdk.Node[];
}


/// File: /src/api/types/BasicType.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type BasicType = 
    | "primitive"
    | "literal";

export const BasicType = {
        Primitive: "primitive",
        Literal: "literal"
    } as const;


/// File: /src/api/types/ComplexType.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type ComplexType = 
    | "object"
    | "union"
    | "unknown";

export const ComplexType = {
        Object: "object",
        Union: "union",
        Unknown: "unknown"
    } as const;


/// File: /src/api/types/Identifier.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../index";

export interface Identifier {
    "type": TestSdk.Type;
    "value": string;
    "label": string;
}


/// File: /src/api/types/index.ts
export * from "./Type";
export * from "./Identifier";
export * from "./BasicType";
export * from "./ComplexType";


/// File: /src/api/types/Type.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as TestSdk from "../index";

export type Type = 
    | TestSdk.BasicType
    | TestSdk.ComplexType;


/// File: /src/Client.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "./environments";
import * as core from "./core";
import * as serializers from "./serialization/index";
import * as errors from "./errors/index";
import { File_ } from "./api/resources/file/client/Client";
import { Health } from "./api/resources/health/client/Client";
import { Service } from "./api/resources/service/client/Client";

export declare namespace TestSdkClient {
    interface Options {
        environment: core.Supplier<environments.TestSdkEnvironment | string>;
        token?: core.Supplier<core.BearerToken | undefined>;
    }

    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}

export class TestSdkClient {
    constructor(protected readonly _options: TestSdkClient.Options) {
    }

    /**
     * @param {string} request
     * @param {TestSdkClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await testSdk.echo("Hello world!\\\\n\\\\nwith\\\\n\\\\tnewlines")
     */
    public async echo(request: string, requestOptions?: TestSdkClient.RequestOptions): Promise<string> {
        const _response = await core.fetcher({
            url: await core.Supplier.get(this._options.environment),
            method: "POST",
            headers: {
                "Authorization": await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "@test/sdk",
                "X-Fern-SDK-Version": "1.0.0",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version
            },
            contentType: "application/json",
            body: await serializers.echo.Request.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? (requestOptions.timeoutInSeconds * 1000) : 60000,
            maxRetries: requestOptions?.maxRetries
        });
        if (_response.ok) {
            return await serializers.echo.Response.parseOrThrow(_response.body, { unrecognizedObjectKeys: "passthrough", allowUnrecognizedUnionMembers: true, allowUnrecognizedEnumValues: true, breadcrumbsPrefix: ["response"] });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.body
            });
        }

        switch (_response.error.reason) {
            case "non-json": throw new errors.TestSdkError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
            });
            case "timeout": throw new errors.TestSdkTimeoutError;
            case "unknown": throw new errors.TestSdkError({
                message: _response.error.errorMessage
            });
        }
    }

    protected _file: File_ | undefined;

    public get file(): File_ {
        return (this._file ??= new File_(this._options));
    }

    protected _health: Health | undefined;

    public get health(): Health {
        return (this._health ??= new Health(this._options));
    }

    protected _service: Service | undefined;

    public get service(): Service {
        return (this._service ??= new Service(this._options));
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = await core.Supplier.get(this._options.token);
        if (bearer != null) {
            return \`Bearer \${bearer}\`;
        }

        return undefined;
    }
}


/// File: /src/core/index.ts
export * from "./fetcher";
export * from "./auth";
export * from "./runtime";
export * as serialization from "./schemas";


/// File: /src/environments.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export const TestSdkEnvironment = {
        Production: "https://production.com/api",
        Staging: "https://staging.com/api",
    } as const;

export type TestSdkEnvironment = typeof TestSdkEnvironment.Production | typeof TestSdkEnvironment.Staging;


/// File: /src/errors/index.ts
export { TestSdkError } from "./TestSdkError";
export { TestSdkTimeoutError } from "./TestSdkTimeoutError";


/// File: /src/errors/TestSdkError.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export class TestSdkError extends Error {
    readonly statusCode?: number;
    readonly body?: unknown;

    constructor({ message, statusCode, body }: {
            message?: string;
            statusCode?: number;
            body?: unknown;
        }) {
        super(buildMessage({ message, statusCode, body }));
        Object.setPrototypeOf(this, TestSdkError.prototype);
        if (statusCode != null) {
            this.statusCode = statusCode;
        }

        if (body !== undefined) {
            this.body = body;
        }
    }
}

function buildMessage({ message, statusCode, body }: {
        message: string | undefined;
        statusCode: number | undefined;
        body: unknown | undefined;
    }): string {
    let lines: string[] = [];
    if (message != null) {
        lines.push(message);
    }

    if (statusCode != null) {
        lines.push(\`Status code: \${statusCode.toString()}\`);
    }

    if (body != null) {
        lines.push(\`Body: \${JSON.stringify(body, undefined, 2)}\`);
    }

    return lines.join("\\n");
}


/// File: /src/errors/TestSdkTimeoutError.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

export class TestSdkTimeoutError extends Error {
    constructor() {
        super("Timeout");
        Object.setPrototypeOf(this, TestSdkTimeoutError.prototype);
    }
}


/// File: /src/index.ts
export * as TestSdk from "./api";
export { TestSdkClient } from "./Client";
export { TestSdkEnvironment } from "./environments";
export { TestSdkError, TestSdkTimeoutError } from "./errors";


/// File: /src/serialization/client/echo.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../index";
import * as core from "../../core";

export const Request: core.serialization.Schema<serializers.echo.Request.Raw, string> = core.serialization.string();

export declare namespace Request {
    type Raw = string;
}

export const Response: core.serialization.Schema<serializers.echo.Response.Raw, string> = core.serialization.string();

export declare namespace Response {
    type Raw = string;
}




/// File: /src/serialization/client/index.ts
export * as echo from "./echo";


/// File: /src/serialization/index.ts
export * from "./resources";
export * from "./types";
export * from "./client";


/// File: /src/serialization/resources/commons/index.ts
export * from "./resources";


/// File: /src/serialization/resources/commons/resources/index.ts
export * as types from "./types";
export * from "./types/types";


/// File: /src/serialization/resources/commons/resources/types/index.ts
export * from "./types";


/// File: /src/serialization/resources/commons/resources/types/types/Data.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../../../index";
import * as TestSdk from "../../../../../../api/index";
import * as core from "../../../../../../core";

export const Data: core.serialization.Schema<serializers.commons.Data.Raw, TestSdk.commons.Data> = core.serialization.union("type", {
        "string": core.serialization.object({
            "value": core.serialization.string()
        }),
        "base64": core.serialization.object({
            "value": core.serialization.string()
        })
    }).transform<TestSdk.commons.Data>({
        transform: value => value,
        untransform: value => value
    });

export declare namespace Data {
    type Raw = Data.String | Data.Base64;

    interface String {
        "type": "string";
        "value": string;
    }

    interface Base64 {
        "type": "base64";
        "value": string;
    }
}


/// File: /src/serialization/resources/commons/resources/types/types/EventInfo.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../../../index";
import * as TestSdk from "../../../../../../api/index";
import * as core from "../../../../../../core";
import { Metadata } from "./Metadata";
import { Tag } from "./Tag";

export const EventInfo: core.serialization.Schema<serializers.commons.EventInfo.Raw, TestSdk.commons.EventInfo> = core.serialization.union("type", {
        "metadata": Metadata,
        "tag": core.serialization.object({
            "value": Tag
        })
    }).transform<TestSdk.commons.EventInfo>({
        transform: value => value,
        untransform: value => value
    });

export declare namespace EventInfo {
    type Raw = EventInfo.Metadata | EventInfo.Tag;

    interface Metadata extends Metadata.Raw {
        "type": "metadata";
    }

    interface Tag {
        "type": "tag";
        "value": Tag.Raw;
    }
}


/// File: /src/serialization/resources/commons/resources/types/types/index.ts
export * from "./Tag";
export * from "./Metadata";
export * from "./EventInfo";
export * from "./Data";


/// File: /src/serialization/resources/commons/resources/types/types/Metadata.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../../../index";
import * as TestSdk from "../../../../../../api/index";
import * as core from "../../../../../../core";

export const Metadata: core.serialization.ObjectSchema<serializers.commons.Metadata.Raw, TestSdk.commons.Metadata> = core.serialization.object({
        "id": core.serialization.string(),
        "data": core.serialization.record(core.serialization.string(), core.serialization.string()).optional(),
        "jsonString": core.serialization.string().optional()
    });

export declare namespace Metadata {
    interface Raw {
        "id": string;
        "data"?: Record<string, string> | null;
        "jsonString"?: string | null;
    }
}


/// File: /src/serialization/resources/commons/resources/types/types/Tag.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../../../index";
import * as TestSdk from "../../../../../../api/index";
import * as core from "../../../../../../core";

export const Tag: core.serialization.Schema<serializers.commons.Tag.Raw, TestSdk.commons.Tag> = core.serialization.string();

export declare namespace Tag {
    type Raw = string;
}


/// File: /src/serialization/resources/file/index.ts
export * from "./resources";


/// File: /src/serialization/resources/file/resources/index.ts
export * as service from "./service";
export * from "./service/types";


/// File: /src/serialization/resources/file/resources/service/index.ts
export * from "./types";


/// File: /src/serialization/resources/file/resources/service/types/Filename.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../../../index";
import * as TestSdk from "../../../../../../api/index";
import * as core from "../../../../../../core";

export const Filename: core.serialization.Schema<serializers.file.Filename.Raw, TestSdk.file.Filename> = core.serialization.string();

export declare namespace Filename {
    type Raw = string;
}


/// File: /src/serialization/resources/file/resources/service/types/index.ts
export * from "./Filename";


/// File: /src/serialization/resources/health/index.ts
export * from "./resources";


/// File: /src/serialization/resources/health/resources/index.ts
export * as service from "./service";


/// File: /src/serialization/resources/health/resources/service/client/index.ts
export * as ping from "./ping";


/// File: /src/serialization/resources/health/resources/service/client/ping.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../../../index";
import * as core from "../../../../../../core";

export const Response: core.serialization.Schema<serializers.health.service.ping.Response.Raw, boolean> = core.serialization.boolean();

export declare namespace Response {
    type Raw = boolean;
}




/// File: /src/serialization/resources/health/resources/service/index.ts
export * from "./client";


/// File: /src/serialization/resources/index.ts
export * as types from "./types";
export * from "./types/errors";
export * as commons from "./commons";
export * as file from "./file";
export * from "./types/types";
export * as health from "./health";


/// File: /src/serialization/resources/types/errors/index.ts
export * from "./NotFoundError";


/// File: /src/serialization/resources/types/errors/NotFoundError.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as core from "../../../../core";

export const NotFoundError: core.serialization.Schema<serializers.NotFoundError.Raw, string> = core.serialization.string();

export declare namespace NotFoundError {
    type Raw = string;
}


/// File: /src/serialization/resources/types/index.ts
export * from "./errors";
export * from "./types";


/// File: /src/serialization/resources/types/types/Actor.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";

export const Actor: core.serialization.ObjectSchema<serializers.Actor.Raw, TestSdk.Actor> = core.serialization.object({
        "name": core.serialization.string(),
        "id": core.serialization.string()
    });

export declare namespace Actor {
    interface Raw {
        "name": string;
        "id": string;
    }
}


/// File: /src/serialization/resources/types/types/Actress.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";

export const Actress: core.serialization.ObjectSchema<serializers.Actress.Raw, TestSdk.Actress> = core.serialization.object({
        "name": core.serialization.string(),
        "id": core.serialization.string()
    });

export declare namespace Actress {
    interface Raw {
        "name": string;
        "id": string;
    }
}


/// File: /src/serialization/resources/types/types/CastMember.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";
import { Actor } from "./Actor";
import { Actress } from "./Actress";
import { StuntDouble } from "./StuntDouble";

export const CastMember: core.serialization.Schema<serializers.CastMember.Raw, TestSdk.CastMember> = core.serialization.undiscriminatedUnion([Actor, Actress, StuntDouble]);

export declare namespace CastMember {
    type Raw = Actor.Raw | Actress.Raw | StuntDouble.Raw;
}


/// File: /src/serialization/resources/types/types/Directory.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";
import { File_ } from "./File_";

export const Directory: core.serialization.ObjectSchema<serializers.Directory.Raw, TestSdk.Directory> = core.serialization.object({
        "name": core.serialization.string(),
        "files": core.serialization.list(File_).optional(),
        "directories": core.serialization.list(core.serialization.lazyObject(async () => (await import("../../..")).Directory)).optional()
    });

export declare namespace Directory {
    interface Raw {
        "name": string;
        "files"?: File_.Raw[] | null;
        "directories"?: serializers.Directory.Raw[] | null;
    }
}


/// File: /src/serialization/resources/types/types/Entity.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";
import { Type } from "../../../types/Type";

export const Entity: core.serialization.ObjectSchema<serializers.Entity.Raw, TestSdk.Entity> = core.serialization.object({
        "type": Type,
        "name": core.serialization.string()
    });

export declare namespace Entity {
    interface Raw {
        "type": Type.Raw;
        "name": string;
    }
}


/// File: /src/serialization/resources/types/types/Exception.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";
import { ExceptionInfo } from "./ExceptionInfo";

export const Exception: core.serialization.Schema<serializers.Exception.Raw, TestSdk.Exception> = core.serialization.union("type", {
        "generic": ExceptionInfo,
        "timeout": core.serialization.object({})
    }).transform<TestSdk.Exception>({
        transform: value => value,
        untransform: value => value
    });

export declare namespace Exception {
    type Raw = Exception.Generic | Exception.Timeout;

    interface Generic extends ExceptionInfo.Raw {
        "type": "generic";
    }

    interface Timeout {
        "type": "timeout";
    }
}


/// File: /src/serialization/resources/types/types/ExceptionInfo.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";

export const ExceptionInfo: core.serialization.ObjectSchema<serializers.ExceptionInfo.Raw, TestSdk.ExceptionInfo> = core.serialization.object({
        "exceptionType": core.serialization.string(),
        "exceptionMessage": core.serialization.string(),
        "exceptionStacktrace": core.serialization.string()
    });

export declare namespace ExceptionInfo {
    interface Raw {
        "exceptionType": string;
        "exceptionMessage": string;
        "exceptionStacktrace": string;
    }
}


/// File: /src/serialization/resources/types/types/ExtendedMovie.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";
import { Movie } from "./Movie";

export const ExtendedMovie: core.serialization.ObjectSchema<serializers.ExtendedMovie.Raw, TestSdk.ExtendedMovie> = core.serialization.object({
        "cast": core.serialization.list(core.serialization.string())
    }).extend(Movie);

export declare namespace ExtendedMovie {
    interface Raw extends Movie.Raw {
        "cast": string[];
    }
}


/// File: /src/serialization/resources/types/types/File_.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";

export const File_: core.serialization.ObjectSchema<serializers.File_.Raw, TestSdk.File_> = core.serialization.object({
        "name": core.serialization.string(),
        "contents": core.serialization.string()
    });

export declare namespace File_ {
    interface Raw {
        "name": string;
        "contents": string;
    }
}


/// File: /src/serialization/resources/types/types/index.ts
export * from "./MovieId";
export * from "./Movie";
export * from "./CastMember";
export * from "./Actor";
export * from "./Actress";
export * from "./StuntDouble";
export * from "./ExtendedMovie";
export * from "./Moment";
export * from "./File_";
export * from "./Directory";
export * from "./Node";
export * from "./Tree";
export * from "./Metadata";
export * from "./Exception";
export * from "./ExceptionInfo";
export * from "./MigrationStatus";
export * from "./Migration";
export * from "./Request";
export * from "./Response";
export * from "./ResponseType";
export * from "./Test";
export * from "./Entity";


/// File: /src/serialization/resources/types/types/Metadata.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as core from "../../../../core";
import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";

const _Base = core.serialization.object({
        "extra": core.serialization.record(core.serialization.string(), core.serialization.string()),
        "tags": core.serialization.set(core.serialization.string())
    });
export const Metadata: core.serialization.Schema<serializers.Metadata.Raw, TestSdk.Metadata> = core.serialization.union("type", {
        "html": core.serialization.object({
            "value": core.serialization.string()
        }).extend(_Base),
        "markdown": core.serialization.object({
            "value": core.serialization.string()
        }).extend(_Base)
    }).transform<TestSdk.Metadata>({
        transform: value => value,
        untransform: value => value
    });

export declare namespace Metadata {
    type Raw = Metadata.Html | Metadata.Markdown;

    interface Html extends _Base {
        "type": "html";
        "value": string;
    }

    interface Markdown extends _Base {
        "type": "markdown";
        "value": string;
    }

    interface _Base {
        "extra": Record<string, string>;
        "tags": string[];
    }
}


/// File: /src/serialization/resources/types/types/Migration.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";
import { MigrationStatus } from "./MigrationStatus";

export const Migration: core.serialization.ObjectSchema<serializers.Migration.Raw, TestSdk.Migration> = core.serialization.object({
        "name": core.serialization.string(),
        "status": MigrationStatus
    });

export declare namespace Migration {
    interface Raw {
        "name": string;
        "status": MigrationStatus.Raw;
    }
}


/// File: /src/serialization/resources/types/types/MigrationStatus.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";

export const MigrationStatus: core.serialization.Schema<serializers.MigrationStatus.Raw, TestSdk.MigrationStatus> = core.serialization.enum_(["RUNNING", "FAILED", "FINISHED"]);

export declare namespace MigrationStatus {
    type Raw = "RUNNING" | "FAILED" | "FINISHED";
}


/// File: /src/serialization/resources/types/types/Moment.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";

export const Moment: core.serialization.ObjectSchema<serializers.Moment.Raw, TestSdk.Moment> = core.serialization.object({
        "id": core.serialization.string(),
        "date": core.serialization.string(),
        "datetime": core.serialization.date()
    });

export declare namespace Moment {
    interface Raw {
        "id": string;
        "date": string;
        "datetime": string;
    }
}


/// File: /src/serialization/resources/types/types/Movie.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";
import { MovieId } from "./MovieId";
import { Tag } from "../../commons/resources/types/types/Tag";

export const Movie: core.serialization.ObjectSchema<serializers.Movie.Raw, TestSdk.Movie> = core.serialization.object({
        "id": MovieId,
        "prequel": MovieId.optional(),
        "title": core.serialization.string(),
        "from": core.serialization.string(),
        "rating": core.serialization.number(),
        "type": core.serialization.stringLiteral("movie"),
        "tag": Tag,
        "book": core.serialization.string().optional(),
        "metadata": core.serialization.record(core.serialization.string(), core.serialization.unknown())
    });

export declare namespace Movie {
    interface Raw {
        "id": MovieId.Raw;
        "prequel"?: MovieId.Raw | null;
        "title": string;
        "from": string;
        "rating": number;
        "type": "movie";
        "tag": Tag.Raw;
        "book"?: string | null;
        "metadata": Record<string, unknown>;
    }
}


/// File: /src/serialization/resources/types/types/MovieId.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";

export const MovieId: core.serialization.Schema<serializers.MovieId.Raw, TestSdk.MovieId> = core.serialization.string();

export declare namespace MovieId {
    type Raw = string;
}


/// File: /src/serialization/resources/types/types/Node.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";

export const Node: core.serialization.ObjectSchema<serializers.Node.Raw, TestSdk.Node> = core.serialization.object({
        "name": core.serialization.string(),
        "nodes": core.serialization.list(core.serialization.lazyObject(async () => (await import("../../..")).Node)).optional(),
        "trees": core.serialization.list(core.serialization.lazyObject(async () => (await import("../../..")).Tree)).optional()
    });

export declare namespace Node {
    interface Raw {
        "name": string;
        "nodes"?: serializers.Node.Raw[] | null;
        "trees"?: serializers.Tree.Raw[] | null;
    }
}


/// File: /src/serialization/resources/types/types/Request.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";

export const Request: core.serialization.ObjectSchema<serializers.Request.Raw, TestSdk.Request> = core.serialization.object({
        "request": core.serialization.unknown()
    });

export declare namespace Request {
    interface Raw {
        "request"?: unknown;
    }
}


/// File: /src/serialization/resources/types/types/Response.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";
import { Identifier } from "../../../types/Identifier";

export const Response: core.serialization.ObjectSchema<serializers.Response.Raw, TestSdk.Response> = core.serialization.object({
        "response": core.serialization.unknown(),
        "identifiers": core.serialization.list(Identifier)
    });

export declare namespace Response {
    interface Raw {
        "response"?: unknown;
        "identifiers": Identifier.Raw[];
    }
}


/// File: /src/serialization/resources/types/types/ResponseType.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";
import { Type } from "../../../types/Type";

export const ResponseType: core.serialization.ObjectSchema<serializers.ResponseType.Raw, TestSdk.ResponseType> = core.serialization.object({
        "type": Type
    });

export declare namespace ResponseType {
    interface Raw {
        "type": Type.Raw;
    }
}


/// File: /src/serialization/resources/types/types/StuntDouble.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";

export const StuntDouble: core.serialization.ObjectSchema<serializers.StuntDouble.Raw, TestSdk.StuntDouble> = core.serialization.object({
        "name": core.serialization.string(),
        "actorOrActressId": core.serialization.string()
    });

export declare namespace StuntDouble {
    interface Raw {
        "name": string;
        "actorOrActressId": string;
    }
}


/// File: /src/serialization/resources/types/types/Test.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";

export const Test: core.serialization.Schema<serializers.Test.Raw, TestSdk.Test> = core.serialization.union("type", {
        "and": core.serialization.object({
            "value": core.serialization.boolean()
        }),
        "or": core.serialization.object({
            "value": core.serialization.boolean()
        })
    }).transform<TestSdk.Test>({
        transform: value => value,
        untransform: value => value
    });

export declare namespace Test {
    type Raw = Test.And | Test.Or;

    interface And {
        "type": "and";
        "value": boolean;
    }

    interface Or {
        "type": "or";
        "value": boolean;
    }
}


/// File: /src/serialization/resources/types/types/Tree.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../../../index";
import * as TestSdk from "../../../../api/index";
import * as core from "../../../../core";

export const Tree: core.serialization.ObjectSchema<serializers.Tree.Raw, TestSdk.Tree> = core.serialization.object({
        "nodes": core.serialization.list(core.serialization.lazyObject(async () => (await import("../../..")).Node)).optional()
    });

export declare namespace Tree {
    interface Raw {
        "nodes"?: serializers.Node.Raw[] | null;
    }
}


/// File: /src/serialization/types/BasicType.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../index";
import * as TestSdk from "../../api/index";
import * as core from "../../core";

export const BasicType: core.serialization.Schema<serializers.BasicType.Raw, TestSdk.BasicType> = core.serialization.enum_(["primitive", "literal"]);

export declare namespace BasicType {
    type Raw = "primitive" | "literal";
}


/// File: /src/serialization/types/ComplexType.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../index";
import * as TestSdk from "../../api/index";
import * as core from "../../core";

export const ComplexType: core.serialization.Schema<serializers.ComplexType.Raw, TestSdk.ComplexType> = core.serialization.enum_(["object", "union", "unknown"]);

export declare namespace ComplexType {
    type Raw = "object" | "union" | "unknown";
}


/// File: /src/serialization/types/Identifier.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../index";
import * as TestSdk from "../../api/index";
import * as core from "../../core";
import { Type } from "./Type";

export const Identifier: core.serialization.ObjectSchema<serializers.Identifier.Raw, TestSdk.Identifier> = core.serialization.object({
        "type": Type,
        "value": core.serialization.string(),
        "label": core.serialization.string()
    });

export declare namespace Identifier {
    interface Raw {
        "type": Type.Raw;
        "value": string;
        "label": string;
    }
}


/// File: /src/serialization/types/index.ts
export * from "./Type";
export * from "./Identifier";
export * from "./BasicType";
export * from "./ComplexType";


/// File: /src/serialization/types/Type.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from "../index";
import * as TestSdk from "../../api/index";
import * as core from "../../core";
import { BasicType } from "./BasicType";
import { ComplexType } from "./ComplexType";

export const Type: core.serialization.Schema<serializers.Type.Raw, TestSdk.Type> = core.serialization.undiscriminatedUnion([BasicType, ComplexType]);

export declare namespace Type {
    type Raw = BasicType.Raw | ComplexType.Raw;
}


/// File: /tests/file/notification/service.test.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TestSdkClient } from "../../../src/Client";

const client = new TestSdkClient({
    "environment": process.env.TESTS_BASE_URL || "test",
    "token": process.env.TESTS_AUTH || "test",
});

describe("Service", () => {
    test("getException", async () => {
        const response = await client.file.notification.service.getException("notification-hsy129x");
        expect(response).toEqual({
            "type": "generic",
            "exceptionType": "Unavailable",
            "exceptionMessage": "This component is unavailable!",
            "exceptionStacktrace": "<logs>",
        });
    });
});


/// File: /tests/file/service.test.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TestSdkClient } from "../../src/Client";

const client = new TestSdkClient({
    "environment": process.env.TESTS_BASE_URL || "test",
    "token": process.env.TESTS_AUTH || "test",
});

describe("Service", () => {
    test("constructor", () => {
        expect(client.file.service).toBeDefined();
    });
});


/// File: /tests/health/service.test.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TestSdkClient } from "../../src/Client";

const client = new TestSdkClient({
    "environment": process.env.TESTS_BASE_URL || "test",
    "token": process.env.TESTS_AUTH || "test",
});

describe("Service", () => {
    test("check", async () => {
        const response = await client.health.service.check("id-2sdx82h");
        expect(response).toEqual(undefined);
    });

    test("ping", async () => {
        const response = await client.health.service.ping();
        expect(response).toEqual(true);
    });
});


/// File: /tests/main.test.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TestSdkClient } from "../src/Client";

const client = new TestSdkClient({
    "environment": process.env.TESTS_BASE_URL || "test",
    "token": process.env.TESTS_AUTH || "test",
});

describe("TestSdkClient", () => {
    test("echo", async () => {
        const response = await client.echo("Hello world!\\\\n\\\\nwith\\\\n\\\\tnewlines");
        expect(response).toEqual("Hello world!\\\\n\\\\nwith\\\\n\\\\tnewlines");
    });
});


/// File: /tests/service.test.ts
/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TestSdkClient } from "../src/Client";

const client = new TestSdkClient({
    "environment": process.env.TESTS_BASE_URL || "test",
    "token": process.env.TESTS_AUTH || "test",
});

describe("Service", () => {
    test("getMovie", async () => {
        const response = await client.service.getMovie("movie-c06a4ad7");
        expect(response).toEqual({
            "id": "movie-c06a4ad7",
            "prequel": "movie-cv9b914f",
            "title": "The Boy and the Heron",
            "from": "Hayao Miyazaki",
            "rating": 8,
            "type": "movie",
            "tag": "tag-wf9as23d",
            "metadata": {
                "actors": ["Christian Bale", "Florence Pugh", "Willem Dafoe"],
                "releaseDate": "2023-12-08",
                "ratings": { "rottenTomatoes": 97, "imdb": 7.6 },
            },
        });
    });

    test("createMovie", async () => {
        const response = await client.service.createMovie({
            id: "movie-c06a4ad7",
            prequel: "movie-cv9b914f",
            title: "The Boy and the Heron",
            from: "Hayao Miyazaki",
            rating: 8,
            type: "movie",
            tag: "tag-wf9as23d",
            metadata: {
                "actors": ["Christian Bale", "Florence Pugh", "Willem Dafoe"],
                "releaseDate": "2023-12-08",
                "ratings": { "rottenTomatoes": 97, "imdb": 7.6 },
            },
        });
        expect(response).toEqual("movie-c06a4ad7");
    });

    test("getMetadata", async () => {
        const response = await client.service.getMetadata({ xApiVersion: "0.0.1", shallow: false, tag: "development" });
        expect(response).toEqual({
            "type": "html",
            "extra": { "version": "0.0.1", "tenancy": "test" },
            "tags": ["development", "public"],
            "value": "<head>...</head>",
        });
    });

    test("getResponse", async () => {
        const response = await client.service.getResponse();
        expect(response).toEqual({
            "response": "Initializing...",
            "identifiers": [{ "type": "primitive", "value": "example", "label": "Primitive" }, {
                "type": "unknown",
                "value": "{}",
                "label": "Unknown",
            }],
        });
    });
});


/// File: tests/custom.test.ts

/**
* This is a custom test file, if you wish to add more tests
* to your SDK.
* Be sure to mark this file in \`.fernignore\`.
*
* If you include example requests/responses in your fern definition,
* you will have tests automatically generated for you.
*/
describe("test", () => {
    it("default", () => {
        expect(true).toBe(true);
    });
});"
`;
