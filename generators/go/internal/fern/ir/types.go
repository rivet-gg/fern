// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"
	time "time"

	core "github.com/fern-api/fern-go/internal/fern/ir/core"
	uuid "github.com/google/uuid"
)

type ApiAuth struct {
	Docs        *string                `json:"docs,omitempty" url:"docs,omitempty"`
	Requirement AuthSchemesRequirement `json:"requirement,omitempty" url:"requirement,omitempty"`
	Schemes     []*AuthScheme          `json:"schemes,omitempty" url:"schemes,omitempty"`
}

func (a *ApiAuth) String() string {
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AuthScheme struct {
	Type   string
	Bearer *BearerAuthScheme
	Basic  *BasicAuthScheme
	Header *HeaderAuthScheme
	Oauth  *OAuthScheme
}

func NewAuthSchemeFromBearer(value *BearerAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "bearer", Bearer: value}
}

func NewAuthSchemeFromBasic(value *BasicAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "basic", Basic: value}
}

func NewAuthSchemeFromHeader(value *HeaderAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "header", Header: value}
}

func NewAuthSchemeFromOauth(value *OAuthScheme) *AuthScheme {
	return &AuthScheme{Type: "oauth", Oauth: value}
}

func (a *AuthScheme) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "bearer":
		value := new(BearerAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Bearer = value
	case "basic":
		value := new(BasicAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Basic = value
	case "header":
		value := new(HeaderAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Header = value
	case "oauth":
		value := new(OAuthScheme)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Oauth = value
	}
	return nil
}

func (a AuthScheme) MarshalJSON() ([]byte, error) {
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "bearer":
		var marshaler = struct {
			Type string `json:"_type"`
			*BearerAuthScheme
		}{
			Type:             "bearer",
			BearerAuthScheme: a.Bearer,
		}
		return json.Marshal(marshaler)
	case "basic":
		var marshaler = struct {
			Type string `json:"_type"`
			*BasicAuthScheme
		}{
			Type:            "basic",
			BasicAuthScheme: a.Basic,
		}
		return json.Marshal(marshaler)
	case "header":
		var marshaler = struct {
			Type string `json:"_type"`
			*HeaderAuthScheme
		}{
			Type:             "header",
			HeaderAuthScheme: a.Header,
		}
		return json.Marshal(marshaler)
	case "oauth":
		var marshaler = struct {
			Type string `json:"_type"`
			*OAuthScheme
		}{
			Type:        "oauth",
			OAuthScheme: a.Oauth,
		}
		return json.Marshal(marshaler)
	}
}

type AuthSchemeVisitor interface {
	VisitBearer(*BearerAuthScheme) error
	VisitBasic(*BasicAuthScheme) error
	VisitHeader(*HeaderAuthScheme) error
	VisitOauth(*OAuthScheme) error
}

func (a *AuthScheme) Accept(visitor AuthSchemeVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "bearer":
		return visitor.VisitBearer(a.Bearer)
	case "basic":
		return visitor.VisitBasic(a.Basic)
	case "header":
		return visitor.VisitHeader(a.Header)
	case "oauth":
		return visitor.VisitOauth(a.Oauth)
	}
}

type AuthSchemesRequirement string

const (
	AuthSchemesRequirementAll AuthSchemesRequirement = "ALL"
	AuthSchemesRequirementAny AuthSchemesRequirement = "ANY"
)

func NewAuthSchemesRequirementFromString(s string) (AuthSchemesRequirement, error) {
	switch s {
	case "ALL":
		return AuthSchemesRequirementAll, nil
	case "ANY":
		return AuthSchemesRequirementAny, nil
	}
	var t AuthSchemesRequirement
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthSchemesRequirement) Ptr() *AuthSchemesRequirement {
	return &a
}

type BasicAuthScheme struct {
	Docs     *string `json:"docs,omitempty" url:"docs,omitempty"`
	Username *Name   `json:"username,omitempty" url:"username,omitempty"`
	// The environment variable the SDK should use to read the username.
	UsernameEnvVar *EnvironmentVariable `json:"usernameEnvVar,omitempty" url:"usernameEnvVar,omitempty"`
	Password       *Name                `json:"password,omitempty" url:"password,omitempty"`
	// The environment variable the SDK should use to read the password.
	PasswordEnvVar *EnvironmentVariable `json:"passwordEnvVar,omitempty" url:"passwordEnvVar,omitempty"`
}

func (b *BasicAuthScheme) String() string {
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BearerAuthScheme struct {
	Docs  *string `json:"docs,omitempty" url:"docs,omitempty"`
	Token *Name   `json:"token,omitempty" url:"token,omitempty"`
	// The environment variable the SDK should use to read the token.
	TokenEnvVar *EnvironmentVariable `json:"tokenEnvVar,omitempty" url:"tokenEnvVar,omitempty"`
}

func (b *BearerAuthScheme) String() string {
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type EnvironmentVariable = string

type HeaderAuthScheme struct {
	Docs      *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Name      *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`
	Prefix    *string           `json:"prefix,omitempty" url:"prefix,omitempty"`
	// The environment variable the SDK should use to read the header.
	HeaderEnvVar *EnvironmentVariable `json:"headerEnvVar,omitempty" url:"headerEnvVar,omitempty"`
}

func (h *HeaderAuthScheme) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The properties to map to the corresponding OAuth token primitive.
type OAuthAccessTokenProperties struct {
	AccessToken  *ResponseProperty `json:"accessToken,omitempty" url:"accessToken,omitempty"`
	ExpiresIn    *ResponseProperty `json:"expiresIn,omitempty" url:"expiresIn,omitempty"`
	RefreshToken *ResponseProperty `json:"refreshToken,omitempty" url:"refreshToken,omitempty"`
}

func (o *OAuthAccessTokenProperties) String() string {
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OAuthClientCredentials struct {
	ClientIdEnvVar     *EnvironmentVariable  `json:"clientIdEnvVar,omitempty" url:"clientIdEnvVar,omitempty"`
	ClientSecretEnvVar *EnvironmentVariable  `json:"clientSecretEnvVar,omitempty" url:"clientSecretEnvVar,omitempty"`
	TokenPrefix        *string               `json:"tokenPrefix,omitempty" url:"tokenPrefix,omitempty"`
	Scopes             []string              `json:"scopes,omitempty" url:"scopes,omitempty"`
	TokenEndpoint      *OAuthTokenEndpoint   `json:"tokenEndpoint,omitempty" url:"tokenEndpoint,omitempty"`
	RefreshEndpoint    *OAuthRefreshEndpoint `json:"refreshEndpoint,omitempty" url:"refreshEndpoint,omitempty"`
}

func (o *OAuthClientCredentials) String() string {
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OAuthConfiguration struct {
	Type              string
	ClientCredentials *OAuthClientCredentials
}

func NewOAuthConfigurationFromClientCredentials(value *OAuthClientCredentials) *OAuthConfiguration {
	return &OAuthConfiguration{Type: "clientCredentials", ClientCredentials: value}
}

func (o *OAuthConfiguration) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	o.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "clientCredentials":
		value := new(OAuthClientCredentials)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.ClientCredentials = value
	}
	return nil
}

func (o OAuthConfiguration) MarshalJSON() ([]byte, error) {
	switch o.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.Type, o)
	case "clientCredentials":
		var marshaler = struct {
			Type string `json:"type"`
			*OAuthClientCredentials
		}{
			Type:                   "clientCredentials",
			OAuthClientCredentials: o.ClientCredentials,
		}
		return json.Marshal(marshaler)
	}
}

type OAuthConfigurationVisitor interface {
	VisitClientCredentials(*OAuthClientCredentials) error
}

func (o *OAuthConfiguration) Accept(visitor OAuthConfigurationVisitor) error {
	switch o.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", o.Type, o)
	case "clientCredentials":
		return visitor.VisitClientCredentials(o.ClientCredentials)
	}
}

type OAuthRefreshEndpoint struct {
	// The refrence to the refresh token endpoint (e.g. \_endpoint_auth.refreshToken).
	EndpointReference  EndpointId                   `json:"endpointReference" url:"endpointReference"`
	RequestProperties  *OAuthRefreshTokenProperties `json:"requestProperties,omitempty" url:"requestProperties,omitempty"`
	ResponseProperties *OAuthAccessTokenProperties  `json:"responseProperties,omitempty" url:"responseProperties,omitempty"`
}

func (o *OAuthRefreshEndpoint) String() string {
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The properties to map to the corresponding OAuth token primitive.
type OAuthRefreshTokenProperties struct {
	RefreshToken *RequestProperty `json:"refreshToken,omitempty" url:"refreshToken,omitempty"`
}

func (o *OAuthRefreshTokenProperties) String() string {
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// We currently assume the resultant token is leveraged as a bearer token, e.g. "Authorization Bearer"
type OAuthScheme struct {
	Docs          *string             `json:"docs,omitempty" url:"docs,omitempty"`
	Configuration *OAuthConfiguration `json:"configuration,omitempty" url:"configuration,omitempty"`
}

func (o *OAuthScheme) String() string {
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OAuthTokenEndpoint struct {
	// The refrence to the access token endpoint (e.g. \_endpoint_auth.token).
	EndpointReference  EndpointId                  `json:"endpointReference" url:"endpointReference"`
	ResponseProperties *OAuthAccessTokenProperties `json:"responseProperties,omitempty" url:"responseProperties,omitempty"`
}

func (o *OAuthTokenEndpoint) String() string {
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type Availability struct {
	Status  AvailabilityStatus `json:"status,omitempty" url:"status,omitempty"`
	Message *string            `json:"message,omitempty" url:"message,omitempty"`
}

func (a *Availability) String() string {
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AvailabilityStatus string

const (
	AvailabilityStatusInDevelopment       AvailabilityStatus = "IN_DEVELOPMENT"
	AvailabilityStatusPreRelease          AvailabilityStatus = "PRE_RELEASE"
	AvailabilityStatusGeneralAvailability AvailabilityStatus = "GENERAL_AVAILABILITY"
	AvailabilityStatusDeprecated          AvailabilityStatus = "DEPRECATED"
)

func NewAvailabilityStatusFromString(s string) (AvailabilityStatus, error) {
	switch s {
	case "IN_DEVELOPMENT":
		return AvailabilityStatusInDevelopment, nil
	case "PRE_RELEASE":
		return AvailabilityStatusPreRelease, nil
	case "GENERAL_AVAILABILITY":
		return AvailabilityStatusGeneralAvailability, nil
	case "DEPRECATED":
		return AvailabilityStatusDeprecated, nil
	}
	var t AvailabilityStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AvailabilityStatus) Ptr() *AvailabilityStatus {
	return &a
}

type Declaration struct {
	Docs         *string       `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability `json:"availability,omitempty" url:"availability,omitempty"`
}

func (d *Declaration) String() string {
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EndpointId = string

type ErrorId = string

// Defines the original string, and its escaped-equivalent (depending on the target programming language).
// This is paricularly relevant to example string literals.
//
// For example, in Python we escape strings that contain single or double quotes by using triple quotes,
// in Go we use backticks, etc.
type EscapedString struct {
	Original string `json:"original" url:"original"`
}

func (e *EscapedString) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FernFilepath struct {
	AllParts    []*Name `json:"allParts,omitempty" url:"allParts,omitempty"`
	PackagePath []*Name `json:"packagePath,omitempty" url:"packagePath,omitempty"`
	File        *Name   `json:"file,omitempty" url:"file,omitempty"`
}

func (f *FernFilepath) String() string {
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Name struct {
	OriginalName       string               `json:"originalName" url:"originalName"`
	CamelCase          *SafeAndUnsafeString `json:"camelCase,omitempty" url:"camelCase,omitempty"`
	PascalCase         *SafeAndUnsafeString `json:"pascalCase,omitempty" url:"pascalCase,omitempty"`
	SnakeCase          *SafeAndUnsafeString `json:"snakeCase,omitempty" url:"snakeCase,omitempty"`
	ScreamingSnakeCase *SafeAndUnsafeString `json:"screamingSnakeCase,omitempty" url:"screamingSnakeCase,omitempty"`
}

func (n *Name) String() string {
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NameAndWireValue struct {
	WireValue string `json:"wireValue" url:"wireValue"`
	Name      *Name  `json:"name,omitempty" url:"name,omitempty"`
}

func (n *NameAndWireValue) String() string {
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type SafeAndUnsafeString struct {
	// this name might overlap with reserved keywords of the language being generated
	UnsafeName string `json:"unsafeName" url:"unsafeName"`
	// this name will NOT overlap with reserved keywords of the language being generated
	SafeName string `json:"safeName" url:"safeName"`
}

func (s *SafeAndUnsafeString) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServiceId = string

type SubpackageId = string

type TypeId = string

type WebSocketChannelId = string

type WebhookGroupId = string

type WithDocs struct {
	Docs *string `json:"docs,omitempty" url:"docs,omitempty"`
}

func (w *WithDocs) String() string {
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WithJsonExample struct {
	JsonExample interface{} `json:"jsonExample,omitempty" url:"jsonExample,omitempty"`
}

func (w *WithJsonExample) String() string {
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type Constants struct {
	ErrorInstanceIdKey *NameAndWireValue `json:"errorInstanceIdKey,omitempty" url:"errorInstanceIdKey,omitempty"`
}

func (c *Constants) String() string {
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type EnvironmentBaseUrlId = string

type EnvironmentBaseUrlWithId struct {
	Id   EnvironmentBaseUrlId `json:"id" url:"id"`
	Name *Name                `json:"name,omitempty" url:"name,omitempty"`
}

func (e *EnvironmentBaseUrlWithId) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnvironmentId = string

type EnvironmentUrl = string

type Environments struct {
	Type             string
	SingleBaseUrl    *SingleBaseUrlEnvironments
	MultipleBaseUrls *MultipleBaseUrlsEnvironments
}

func NewEnvironmentsFromSingleBaseUrl(value *SingleBaseUrlEnvironments) *Environments {
	return &Environments{Type: "singleBaseUrl", SingleBaseUrl: value}
}

func NewEnvironmentsFromMultipleBaseUrls(value *MultipleBaseUrlsEnvironments) *Environments {
	return &Environments{Type: "multipleBaseUrls", MultipleBaseUrls: value}
}

func (e *Environments) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "singleBaseUrl":
		value := new(SingleBaseUrlEnvironments)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SingleBaseUrl = value
	case "multipleBaseUrls":
		value := new(MultipleBaseUrlsEnvironments)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.MultipleBaseUrls = value
	}
	return nil
}

func (e Environments) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "singleBaseUrl":
		var marshaler = struct {
			Type string `json:"type"`
			*SingleBaseUrlEnvironments
		}{
			Type:                      "singleBaseUrl",
			SingleBaseUrlEnvironments: e.SingleBaseUrl,
		}
		return json.Marshal(marshaler)
	case "multipleBaseUrls":
		var marshaler = struct {
			Type string `json:"type"`
			*MultipleBaseUrlsEnvironments
		}{
			Type:                         "multipleBaseUrls",
			MultipleBaseUrlsEnvironments: e.MultipleBaseUrls,
		}
		return json.Marshal(marshaler)
	}
}

type EnvironmentsVisitor interface {
	VisitSingleBaseUrl(*SingleBaseUrlEnvironments) error
	VisitMultipleBaseUrls(*MultipleBaseUrlsEnvironments) error
}

func (e *Environments) Accept(visitor EnvironmentsVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "singleBaseUrl":
		return visitor.VisitSingleBaseUrl(e.SingleBaseUrl)
	case "multipleBaseUrls":
		return visitor.VisitMultipleBaseUrls(e.MultipleBaseUrls)
	}
}

type EnvironmentsConfig struct {
	DefaultEnvironment *EnvironmentId `json:"defaultEnvironment,omitempty" url:"defaultEnvironment,omitempty"`
	Environments       *Environments  `json:"environments,omitempty" url:"environments,omitempty"`
}

func (e *EnvironmentsConfig) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type MultipleBaseUrlsEnvironment struct {
	Docs *string                                 `json:"docs,omitempty" url:"docs,omitempty"`
	Id   EnvironmentId                           `json:"id" url:"id"`
	Name *Name                                   `json:"name,omitempty" url:"name,omitempty"`
	Urls map[EnvironmentBaseUrlId]EnvironmentUrl `json:"urls,omitempty" url:"urls,omitempty"`
}

func (m *MultipleBaseUrlsEnvironment) String() string {
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MultipleBaseUrlsEnvironments struct {
	BaseUrls     []*EnvironmentBaseUrlWithId    `json:"baseUrls,omitempty" url:"baseUrls,omitempty"`
	Environments []*MultipleBaseUrlsEnvironment `json:"environments,omitempty" url:"environments,omitempty"`
}

func (m *MultipleBaseUrlsEnvironments) String() string {
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type SingleBaseUrlEnvironment struct {
	Docs *string        `json:"docs,omitempty" url:"docs,omitempty"`
	Id   EnvironmentId  `json:"id" url:"id"`
	Name *Name          `json:"name,omitempty" url:"name,omitempty"`
	Url  EnvironmentUrl `json:"url" url:"url"`
}

func (s *SingleBaseUrlEnvironment) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleBaseUrlEnvironments struct {
	Environments []*SingleBaseUrlEnvironment `json:"environments,omitempty" url:"environments,omitempty"`
}

func (s *SingleBaseUrlEnvironments) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type DeclaredErrorName struct {
	ErrorId      ErrorId       `json:"errorId" url:"errorId"`
	FernFilepath *FernFilepath `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`
	Name         *Name         `json:"name,omitempty" url:"name,omitempty"`
}

func (d *DeclaredErrorName) String() string {
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type ErrorDeclaration struct {
	Docs              *string            `json:"docs,omitempty" url:"docs,omitempty"`
	Name              *DeclaredErrorName `json:"name,omitempty" url:"name,omitempty"`
	DiscriminantValue *NameAndWireValue  `json:"discriminantValue,omitempty" url:"discriminantValue,omitempty"`
	Type              *TypeReference     `json:"type,omitempty" url:"type,omitempty"`
	StatusCode        int                `json:"statusCode" url:"statusCode"`
}

func (e *ErrorDeclaration) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorDeclarationDiscriminantValue struct {
	Type       string
	Property   *NameAndWireValue
	StatusCode interface{}
}

func NewErrorDeclarationDiscriminantValueFromProperty(value *NameAndWireValue) *ErrorDeclarationDiscriminantValue {
	return &ErrorDeclarationDiscriminantValue{Type: "property", Property: value}
}

func NewErrorDeclarationDiscriminantValueFromStatusCode(value interface{}) *ErrorDeclarationDiscriminantValue {
	return &ErrorDeclarationDiscriminantValue{Type: "statusCode", StatusCode: value}
}

func (e *ErrorDeclarationDiscriminantValue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "property":
		value := new(NameAndWireValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Property = value
	case "statusCode":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.StatusCode = value
	}
	return nil
}

func (e ErrorDeclarationDiscriminantValue) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "property":
		var marshaler = struct {
			Type string `json:"type"`
			*NameAndWireValue
		}{
			Type:             "property",
			NameAndWireValue: e.Property,
		}
		return json.Marshal(marshaler)
	case "statusCode":
		var marshaler = struct {
			Type       string      `json:"type"`
			StatusCode interface{} `json:"statusCode,omitempty"`
		}{
			Type:       "statusCode",
			StatusCode: e.StatusCode,
		}
		return json.Marshal(marshaler)
	}
}

type ErrorDeclarationDiscriminantValueVisitor interface {
	VisitProperty(*NameAndWireValue) error
	VisitStatusCode(interface{}) error
}

func (e *ErrorDeclarationDiscriminantValue) Accept(visitor ErrorDeclarationDiscriminantValueVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "property":
		return visitor.VisitProperty(e.Property)
	case "statusCode":
		return visitor.VisitStatusCode(e.StatusCode)
	}
}

type BytesRequest struct {
	IsOptional  bool    `json:"isOptional" url:"isOptional"`
	ContentType *string `json:"contentType,omitempty" url:"contentType,omitempty"`
}

func (b *BytesRequest) String() string {
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// If set, the endpoint will be generated with auto-pagination features.
//
// The page must be defined as a query parameter included in the request,
// whereas the next page and results are resolved from properties defined
// on the response.
type CursorPagination struct {
	Page    *QueryParameter   `json:"page,omitempty" url:"page,omitempty"`
	Next    *ResponseProperty `json:"next,omitempty" url:"next,omitempty"`
	Results *ResponseProperty `json:"results,omitempty" url:"results,omitempty"`
}

func (c *CursorPagination) String() string {
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DeclaredServiceName struct {
	FernFilepath *FernFilepath `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`
}

func (d *DeclaredServiceName) String() string {
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EndpointName = *Name

type ExampleCodeSample struct {
	Type     string
	Language *ExampleCodeSampleLanguage
	Sdk      *ExampleCodeSampleSdk
}

func NewExampleCodeSampleFromLanguage(value *ExampleCodeSampleLanguage) *ExampleCodeSample {
	return &ExampleCodeSample{Type: "language", Language: value}
}

func NewExampleCodeSampleFromSdk(value *ExampleCodeSampleSdk) *ExampleCodeSample {
	return &ExampleCodeSample{Type: "sdk", Sdk: value}
}

func (e *ExampleCodeSample) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "language":
		value := new(ExampleCodeSampleLanguage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Language = value
	case "sdk":
		value := new(ExampleCodeSampleSdk)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Sdk = value
	}
	return nil
}

func (e ExampleCodeSample) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "language":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleCodeSampleLanguage
		}{
			Type:                      "language",
			ExampleCodeSampleLanguage: e.Language,
		}
		return json.Marshal(marshaler)
	case "sdk":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleCodeSampleSdk
		}{
			Type:                 "sdk",
			ExampleCodeSampleSdk: e.Sdk,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleCodeSampleVisitor interface {
	VisitLanguage(*ExampleCodeSampleLanguage) error
	VisitSdk(*ExampleCodeSampleSdk) error
}

func (e *ExampleCodeSample) Accept(visitor ExampleCodeSampleVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "language":
		return visitor.VisitLanguage(e.Language)
	case "sdk":
		return visitor.VisitSdk(e.Sdk)
	}
}

// This is intended to co-exist with the auto-generated code samples.
type ExampleCodeSampleLanguage struct {
	Docs *string `json:"docs,omitempty" url:"docs,omitempty"`
	// Override the example name.
	Name     *Name  `json:"name,omitempty" url:"name,omitempty"`
	Language string `json:"language" url:"language"`
	Code     string `json:"code" url:"code"`
	// The command to install the dependencies for the code sample.
	// For example, `npm install` or `pip install -r requirements.txt`.
	Install *string `json:"install,omitempty" url:"install,omitempty"`
}

func (e *ExampleCodeSampleLanguage) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This will be used to replace the auto-generated code samples.
type ExampleCodeSampleSdk struct {
	Docs *string `json:"docs,omitempty" url:"docs,omitempty"`
	// Override the example name.
	Name *Name                `json:"name,omitempty" url:"name,omitempty"`
	Sdk  SupportedSdkLanguage `json:"sdk,omitempty" url:"sdk,omitempty"`
	Code string               `json:"code" url:"code"`
}

func (e *ExampleCodeSampleSdk) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleEndpointCall struct {
	Docs                   *string                  `json:"docs,omitempty" url:"docs,omitempty"`
	Name                   *Name                    `json:"name,omitempty" url:"name,omitempty"`
	Url                    string                   `json:"url" url:"url"`
	RootPathParameters     []*ExamplePathParameter  `json:"rootPathParameters,omitempty" url:"rootPathParameters,omitempty"`
	ServicePathParameters  []*ExamplePathParameter  `json:"servicePathParameters,omitempty" url:"servicePathParameters,omitempty"`
	EndpointPathParameters []*ExamplePathParameter  `json:"endpointPathParameters,omitempty" url:"endpointPathParameters,omitempty"`
	ServiceHeaders         []*ExampleHeader         `json:"serviceHeaders,omitempty" url:"serviceHeaders,omitempty"`
	EndpointHeaders        []*ExampleHeader         `json:"endpointHeaders,omitempty" url:"endpointHeaders,omitempty"`
	QueryParameters        []*ExampleQueryParameter `json:"queryParameters,omitempty" url:"queryParameters,omitempty"`
	Request                *ExampleRequestBody      `json:"request,omitempty" url:"request,omitempty"`
	Response               *ExampleResponse         `json:"response,omitempty" url:"response,omitempty"`
	// Hand-written code samples for this endpoint. These code samples should match the
	// example that it's attached to, so that we can spin up an API Playground with
	// the code sample that's being displayed in the API Reference.
	CodeSamples []*ExampleCodeSample `json:"codeSamples,omitempty" url:"codeSamples,omitempty"`
}

func (e *ExampleEndpointCall) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleEndpointErrorResponse struct {
	Error *DeclaredErrorName    `json:"error,omitempty" url:"error,omitempty"`
	Body  *ExampleTypeReference `json:"body,omitempty" url:"body,omitempty"`
}

func (e *ExampleEndpointErrorResponse) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleEndpointSuccessResponse struct {
	Body *ExampleTypeReference `json:"body,omitempty" url:"body,omitempty"`
}

func (e *ExampleEndpointSuccessResponse) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleHeader struct {
	Name  *NameAndWireValue     `json:"name,omitempty" url:"name,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`
}

func (e *ExampleHeader) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleInlinedRequestBody struct {
	JsonExample interface{}                          `json:"jsonExample,omitempty" url:"jsonExample,omitempty"`
	Properties  []*ExampleInlinedRequestBodyProperty `json:"properties,omitempty" url:"properties,omitempty"`
}

func (e *ExampleInlinedRequestBody) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleInlinedRequestBodyProperty struct {
	Name  *NameAndWireValue     `json:"name,omitempty" url:"name,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`
	// This property may have been brought in via extension. originalTypeDeclaration
	// is the name of the type that contains this property
	OriginalTypeDeclaration *DeclaredTypeName `json:"originalTypeDeclaration,omitempty" url:"originalTypeDeclaration,omitempty"`
}

func (e *ExampleInlinedRequestBodyProperty) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExamplePathParameter struct {
	Name  *Name                 `json:"name,omitempty" url:"name,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`
}

func (e *ExamplePathParameter) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleQueryParameter struct {
	Name  *NameAndWireValue     `json:"name,omitempty" url:"name,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`
}

func (e *ExampleQueryParameter) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleRequestBody struct {
	Type               string
	InlinedRequestBody *ExampleInlinedRequestBody
	Reference          *ExampleTypeReference
}

func NewExampleRequestBodyFromInlinedRequestBody(value *ExampleInlinedRequestBody) *ExampleRequestBody {
	return &ExampleRequestBody{Type: "inlinedRequestBody", InlinedRequestBody: value}
}

func NewExampleRequestBodyFromReference(value *ExampleTypeReference) *ExampleRequestBody {
	return &ExampleRequestBody{Type: "reference", Reference: value}
}

func (e *ExampleRequestBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "inlinedRequestBody":
		value := new(ExampleInlinedRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.InlinedRequestBody = value
	case "reference":
		value := new(ExampleTypeReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Reference = value
	}
	return nil
}

func (e ExampleRequestBody) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "inlinedRequestBody":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleInlinedRequestBody
		}{
			Type:                      "inlinedRequestBody",
			ExampleInlinedRequestBody: e.InlinedRequestBody,
		}
		return json.Marshal(marshaler)
	case "reference":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleTypeReference
		}{
			Type:                 "reference",
			ExampleTypeReference: e.Reference,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleRequestBodyVisitor interface {
	VisitInlinedRequestBody(*ExampleInlinedRequestBody) error
	VisitReference(*ExampleTypeReference) error
}

func (e *ExampleRequestBody) Accept(visitor ExampleRequestBodyVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "inlinedRequestBody":
		return visitor.VisitInlinedRequestBody(e.InlinedRequestBody)
	case "reference":
		return visitor.VisitReference(e.Reference)
	}
}

type ExampleResponse struct {
	Type  string
	Ok    *ExampleEndpointSuccessResponse
	Error *ExampleEndpointErrorResponse
}

func NewExampleResponseFromOk(value *ExampleEndpointSuccessResponse) *ExampleResponse {
	return &ExampleResponse{Type: "ok", Ok: value}
}

func NewExampleResponseFromError(value *ExampleEndpointErrorResponse) *ExampleResponse {
	return &ExampleResponse{Type: "error", Error: value}
}

func (e *ExampleResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "ok":
		value := new(ExampleEndpointSuccessResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Ok = value
	case "error":
		value := new(ExampleEndpointErrorResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Error = value
	}
	return nil
}

func (e ExampleResponse) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "ok":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleEndpointSuccessResponse
		}{
			Type:                           "ok",
			ExampleEndpointSuccessResponse: e.Ok,
		}
		return json.Marshal(marshaler)
	case "error":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleEndpointErrorResponse
		}{
			Type:                         "error",
			ExampleEndpointErrorResponse: e.Error,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleResponseVisitor interface {
	VisitOk(*ExampleEndpointSuccessResponse) error
	VisitError(*ExampleEndpointErrorResponse) error
}

func (e *ExampleResponse) Accept(visitor ExampleResponseVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "ok":
		return visitor.VisitOk(e.Ok)
	case "error":
		return visitor.VisitError(e.Error)
	}
}

type FileDownloadResponse struct {
	Docs *string `json:"docs,omitempty" url:"docs,omitempty"`
}

func (f *FileDownloadResponse) String() string {
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileProperty struct {
	Type      string
	File      *FilePropertySingle
	FileArray *FilePropertyArray
}

func NewFilePropertyFromFile(value *FilePropertySingle) *FileProperty {
	return &FileProperty{Type: "file", File: value}
}

func NewFilePropertyFromFileArray(value *FilePropertyArray) *FileProperty {
	return &FileProperty{Type: "fileArray", FileArray: value}
}

func (f *FileProperty) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	f.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "file":
		value := new(FilePropertySingle)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.File = value
	case "fileArray":
		value := new(FilePropertyArray)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.FileArray = value
	}
	return nil
}

func (f FileProperty) MarshalJSON() ([]byte, error) {
	switch f.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "file":
		var marshaler = struct {
			Type string `json:"type"`
			*FilePropertySingle
		}{
			Type:               "file",
			FilePropertySingle: f.File,
		}
		return json.Marshal(marshaler)
	case "fileArray":
		var marshaler = struct {
			Type string `json:"type"`
			*FilePropertyArray
		}{
			Type:              "fileArray",
			FilePropertyArray: f.FileArray,
		}
		return json.Marshal(marshaler)
	}
}

type FilePropertyVisitor interface {
	VisitFile(*FilePropertySingle) error
	VisitFileArray(*FilePropertyArray) error
}

func (f *FileProperty) Accept(visitor FilePropertyVisitor) error {
	switch f.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "file":
		return visitor.VisitFile(f.File)
	case "fileArray":
		return visitor.VisitFileArray(f.FileArray)
	}
}

type FilePropertyArray struct {
	Key        *NameAndWireValue `json:"key,omitempty" url:"key,omitempty"`
	IsOptional bool              `json:"isOptional" url:"isOptional"`
}

func (f *FilePropertyArray) String() string {
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FilePropertySingle struct {
	Key        *NameAndWireValue `json:"key,omitempty" url:"key,omitempty"`
	IsOptional bool              `json:"isOptional" url:"isOptional"`
}

func (f *FilePropertySingle) String() string {
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileUploadRequest struct {
	Name       *Name                        `json:"name,omitempty" url:"name,omitempty"`
	Properties []*FileUploadRequestProperty `json:"properties,omitempty" url:"properties,omitempty"`
}

func (f *FileUploadRequest) String() string {
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileUploadRequestProperty struct {
	Type         string
	File         *FileProperty
	BodyProperty *InlinedRequestBodyProperty
}

func NewFileUploadRequestPropertyFromFile(value *FileProperty) *FileUploadRequestProperty {
	return &FileUploadRequestProperty{Type: "file", File: value}
}

func NewFileUploadRequestPropertyFromBodyProperty(value *InlinedRequestBodyProperty) *FileUploadRequestProperty {
	return &FileUploadRequestProperty{Type: "bodyProperty", BodyProperty: value}
}

func (f *FileUploadRequestProperty) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	f.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "file":
		var valueUnmarshaler struct {
			File *FileProperty `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		f.File = valueUnmarshaler.File
	case "bodyProperty":
		value := new(InlinedRequestBodyProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.BodyProperty = value
	}
	return nil
}

func (f FileUploadRequestProperty) MarshalJSON() ([]byte, error) {
	switch f.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "file":
		var marshaler = struct {
			Type string        `json:"type"`
			File *FileProperty `json:"value,omitempty"`
		}{
			Type: "file",
			File: f.File,
		}
		return json.Marshal(marshaler)
	case "bodyProperty":
		var marshaler = struct {
			Type string `json:"type"`
			*InlinedRequestBodyProperty
		}{
			Type:                       "bodyProperty",
			InlinedRequestBodyProperty: f.BodyProperty,
		}
		return json.Marshal(marshaler)
	}
}

type FileUploadRequestPropertyVisitor interface {
	VisitFile(*FileProperty) error
	VisitBodyProperty(*InlinedRequestBodyProperty) error
}

func (f *FileUploadRequestProperty) Accept(visitor FileUploadRequestPropertyVisitor) error {
	switch f.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "file":
		return visitor.VisitFile(f.File)
	case "bodyProperty":
		return visitor.VisitBodyProperty(f.BodyProperty)
	}
}

type HttpEndpoint struct {
	Docs              *string                `json:"docs,omitempty" url:"docs,omitempty"`
	Availability      *Availability          `json:"availability,omitempty" url:"availability,omitempty"`
	Id                EndpointId             `json:"id" url:"id"`
	Name              EndpointName           `json:"name,omitempty" url:"name,omitempty"`
	DisplayName       *string                `json:"displayName,omitempty" url:"displayName,omitempty"`
	Method            HttpMethod             `json:"method,omitempty" url:"method,omitempty"`
	Headers           []*HttpHeader          `json:"headers,omitempty" url:"headers,omitempty"`
	BaseUrl           *EnvironmentBaseUrlId  `json:"baseUrl,omitempty" url:"baseUrl,omitempty"`
	Path              *HttpPath              `json:"path,omitempty" url:"path,omitempty"`
	FullPath          *HttpPath              `json:"fullPath,omitempty" url:"fullPath,omitempty"`
	PathParameters    []*PathParameter       `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	AllPathParameters []*PathParameter       `json:"allPathParameters,omitempty" url:"allPathParameters,omitempty"`
	QueryParameters   []*QueryParameter      `json:"queryParameters,omitempty" url:"queryParameters,omitempty"`
	RequestBody       *HttpRequestBody       `json:"requestBody,omitempty" url:"requestBody,omitempty"`
	SdkRequest        *SdkRequest            `json:"sdkRequest,omitempty" url:"sdkRequest,omitempty"`
	Response          *HttpResponse          `json:"response,omitempty" url:"response,omitempty"`
	Errors            ResponseErrors         `json:"errors,omitempty" url:"errors,omitempty"`
	Auth              bool                   `json:"auth" url:"auth"`
	Idempotent        bool                   `json:"idempotent" url:"idempotent"`
	Pagination        *Pagination            `json:"pagination,omitempty" url:"pagination,omitempty"`
	Examples          []*HttpEndpointExample `json:"examples,omitempty" url:"examples,omitempty"`
}

func (h *HttpEndpoint) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpEndpointExample struct {
	ExampleType  string
	UserProvided *ExampleEndpointCall
	Generated    *ExampleEndpointCall
}

func NewHttpEndpointExampleFromUserProvided(value *ExampleEndpointCall) *HttpEndpointExample {
	return &HttpEndpointExample{ExampleType: "userProvided", UserProvided: value}
}

func NewHttpEndpointExampleFromGenerated(value *ExampleEndpointCall) *HttpEndpointExample {
	return &HttpEndpointExample{ExampleType: "generated", Generated: value}
}

func (h *HttpEndpointExample) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ExampleType string `json:"exampleType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.ExampleType = unmarshaler.ExampleType
	switch unmarshaler.ExampleType {
	case "userProvided":
		value := new(ExampleEndpointCall)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.UserProvided = value
	case "generated":
		value := new(ExampleEndpointCall)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Generated = value
	}
	return nil
}

func (h HttpEndpointExample) MarshalJSON() ([]byte, error) {
	switch h.ExampleType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.ExampleType, h)
	case "userProvided":
		var marshaler = struct {
			ExampleType string `json:"exampleType"`
			*ExampleEndpointCall
		}{
			ExampleType:         "userProvided",
			ExampleEndpointCall: h.UserProvided,
		}
		return json.Marshal(marshaler)
	case "generated":
		var marshaler = struct {
			ExampleType string `json:"exampleType"`
			*ExampleEndpointCall
		}{
			ExampleType:         "generated",
			ExampleEndpointCall: h.Generated,
		}
		return json.Marshal(marshaler)
	}
}

type HttpEndpointExampleVisitor interface {
	VisitUserProvided(*ExampleEndpointCall) error
	VisitGenerated(*ExampleEndpointCall) error
}

func (h *HttpEndpointExample) Accept(visitor HttpEndpointExampleVisitor) error {
	switch h.ExampleType {
	default:
		return fmt.Errorf("invalid type %s in %T", h.ExampleType, h)
	case "userProvided":
		return visitor.VisitUserProvided(h.UserProvided)
	case "generated":
		return visitor.VisitGenerated(h.Generated)
	}
}

type HttpHeader struct {
	Docs         *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name         *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType    *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`
	Env          *string           `json:"env,omitempty" url:"env,omitempty"`
}

func (h *HttpHeader) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpMethod string

const (
	HttpMethodGet    HttpMethod = "GET"
	HttpMethodPost   HttpMethod = "POST"
	HttpMethodPut    HttpMethod = "PUT"
	HttpMethodPatch  HttpMethod = "PATCH"
	HttpMethodDelete HttpMethod = "DELETE"
)

func NewHttpMethodFromString(s string) (HttpMethod, error) {
	switch s {
	case "GET":
		return HttpMethodGet, nil
	case "POST":
		return HttpMethodPost, nil
	case "PUT":
		return HttpMethodPut, nil
	case "PATCH":
		return HttpMethodPatch, nil
	case "DELETE":
		return HttpMethodDelete, nil
	}
	var t HttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HttpMethod) Ptr() *HttpMethod {
	return &h
}

type HttpPath struct {
	Head  string          `json:"head" url:"head"`
	Parts []*HttpPathPart `json:"parts,omitempty" url:"parts,omitempty"`
}

func (h *HttpPath) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpPathPart struct {
	PathParameter string `json:"pathParameter" url:"pathParameter"`
	Tail          string `json:"tail" url:"tail"`
}

func (h *HttpPathPart) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpRequestBody struct {
	Type               string
	InlinedRequestBody *InlinedRequestBody
	Reference          *HttpRequestBodyReference
	FileUpload         *FileUploadRequest
	Bytes              *BytesRequest
}

func NewHttpRequestBodyFromInlinedRequestBody(value *InlinedRequestBody) *HttpRequestBody {
	return &HttpRequestBody{Type: "inlinedRequestBody", InlinedRequestBody: value}
}

func NewHttpRequestBodyFromReference(value *HttpRequestBodyReference) *HttpRequestBody {
	return &HttpRequestBody{Type: "reference", Reference: value}
}

func NewHttpRequestBodyFromFileUpload(value *FileUploadRequest) *HttpRequestBody {
	return &HttpRequestBody{Type: "fileUpload", FileUpload: value}
}

func NewHttpRequestBodyFromBytes(value *BytesRequest) *HttpRequestBody {
	return &HttpRequestBody{Type: "bytes", Bytes: value}
}

func (h *HttpRequestBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "inlinedRequestBody":
		value := new(InlinedRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.InlinedRequestBody = value
	case "reference":
		value := new(HttpRequestBodyReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Reference = value
	case "fileUpload":
		value := new(FileUploadRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.FileUpload = value
	case "bytes":
		value := new(BytesRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Bytes = value
	}
	return nil
}

func (h HttpRequestBody) MarshalJSON() ([]byte, error) {
	switch h.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "inlinedRequestBody":
		var marshaler = struct {
			Type string `json:"type"`
			*InlinedRequestBody
		}{
			Type:               "inlinedRequestBody",
			InlinedRequestBody: h.InlinedRequestBody,
		}
		return json.Marshal(marshaler)
	case "reference":
		var marshaler = struct {
			Type string `json:"type"`
			*HttpRequestBodyReference
		}{
			Type:                     "reference",
			HttpRequestBodyReference: h.Reference,
		}
		return json.Marshal(marshaler)
	case "fileUpload":
		var marshaler = struct {
			Type string `json:"type"`
			*FileUploadRequest
		}{
			Type:              "fileUpload",
			FileUploadRequest: h.FileUpload,
		}
		return json.Marshal(marshaler)
	case "bytes":
		var marshaler = struct {
			Type string `json:"type"`
			*BytesRequest
		}{
			Type:         "bytes",
			BytesRequest: h.Bytes,
		}
		return json.Marshal(marshaler)
	}
}

type HttpRequestBodyVisitor interface {
	VisitInlinedRequestBody(*InlinedRequestBody) error
	VisitReference(*HttpRequestBodyReference) error
	VisitFileUpload(*FileUploadRequest) error
	VisitBytes(*BytesRequest) error
}

func (h *HttpRequestBody) Accept(visitor HttpRequestBodyVisitor) error {
	switch h.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "inlinedRequestBody":
		return visitor.VisitInlinedRequestBody(h.InlinedRequestBody)
	case "reference":
		return visitor.VisitReference(h.Reference)
	case "fileUpload":
		return visitor.VisitFileUpload(h.FileUpload)
	case "bytes":
		return visitor.VisitBytes(h.Bytes)
	}
}

type HttpRequestBodyReference struct {
	Docs            *string        `json:"docs,omitempty" url:"docs,omitempty"`
	RequestBodyType *TypeReference `json:"requestBodyType,omitempty" url:"requestBodyType,omitempty"`
	ContentType     *string        `json:"contentType,omitempty" url:"contentType,omitempty"`
}

func (h *HttpRequestBodyReference) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HttpResponse struct {
	Type         string
	Json         *JsonResponse
	FileDownload *FileDownloadResponse
	Text         *TextResponse
	Streaming    *StreamingResponse
}

func NewHttpResponseFromJson(value *JsonResponse) *HttpResponse {
	return &HttpResponse{Type: "json", Json: value}
}

func NewHttpResponseFromFileDownload(value *FileDownloadResponse) *HttpResponse {
	return &HttpResponse{Type: "fileDownload", FileDownload: value}
}

func NewHttpResponseFromText(value *TextResponse) *HttpResponse {
	return &HttpResponse{Type: "text", Text: value}
}

func NewHttpResponseFromStreaming(value *StreamingResponse) *HttpResponse {
	return &HttpResponse{Type: "streaming", Streaming: value}
}

func (h *HttpResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "json":
		var valueUnmarshaler struct {
			Json *JsonResponse `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		h.Json = valueUnmarshaler.Json
	case "fileDownload":
		value := new(FileDownloadResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.FileDownload = value
	case "text":
		value := new(TextResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Text = value
	case "streaming":
		var valueUnmarshaler struct {
			Streaming *StreamingResponse `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		h.Streaming = valueUnmarshaler.Streaming
	}
	return nil
}

func (h HttpResponse) MarshalJSON() ([]byte, error) {
	switch h.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "json":
		var marshaler = struct {
			Type string        `json:"type"`
			Json *JsonResponse `json:"value,omitempty"`
		}{
			Type: "json",
			Json: h.Json,
		}
		return json.Marshal(marshaler)
	case "fileDownload":
		var marshaler = struct {
			Type string `json:"type"`
			*FileDownloadResponse
		}{
			Type:                 "fileDownload",
			FileDownloadResponse: h.FileDownload,
		}
		return json.Marshal(marshaler)
	case "text":
		var marshaler = struct {
			Type string `json:"type"`
			*TextResponse
		}{
			Type:         "text",
			TextResponse: h.Text,
		}
		return json.Marshal(marshaler)
	case "streaming":
		var marshaler = struct {
			Type      string             `json:"type"`
			Streaming *StreamingResponse `json:"value,omitempty"`
		}{
			Type:      "streaming",
			Streaming: h.Streaming,
		}
		return json.Marshal(marshaler)
	}
}

type HttpResponseVisitor interface {
	VisitJson(*JsonResponse) error
	VisitFileDownload(*FileDownloadResponse) error
	VisitText(*TextResponse) error
	VisitStreaming(*StreamingResponse) error
}

func (h *HttpResponse) Accept(visitor HttpResponseVisitor) error {
	switch h.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "json":
		return visitor.VisitJson(h.Json)
	case "fileDownload":
		return visitor.VisitFileDownload(h.FileDownload)
	case "text":
		return visitor.VisitText(h.Text)
	case "streaming":
		return visitor.VisitStreaming(h.Streaming)
	}
}

type HttpService struct {
	Availability   *Availability        `json:"availability,omitempty" url:"availability,omitempty"`
	Name           *DeclaredServiceName `json:"name,omitempty" url:"name,omitempty"`
	DisplayName    *string              `json:"displayName,omitempty" url:"displayName,omitempty"`
	BasePath       *HttpPath            `json:"basePath,omitempty" url:"basePath,omitempty"`
	Endpoints      []*HttpEndpoint      `json:"endpoints,omitempty" url:"endpoints,omitempty"`
	Headers        []*HttpHeader        `json:"headers,omitempty" url:"headers,omitempty"`
	PathParameters []*PathParameter     `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
}

func (h *HttpService) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type InlinedRequestBody struct {
	Name        *Name                         `json:"name,omitempty" url:"name,omitempty"`
	Extends     []*DeclaredTypeName           `json:"extends,omitempty" url:"extends,omitempty"`
	Properties  []*InlinedRequestBodyProperty `json:"properties,omitempty" url:"properties,omitempty"`
	ContentType *string                       `json:"contentType,omitempty" url:"contentType,omitempty"`
	// Whether to allow extra properties on the request.
	ExtraProperties bool `json:"extra-properties" url:"extra-properties"`
}

func (i *InlinedRequestBody) String() string {
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InlinedRequestBodyProperty struct {
	Docs      *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Name      *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`
}

func (i *InlinedRequestBodyProperty) String() string {
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type JsonResponse struct {
	Type                     string
	Response                 *JsonResponseBody
	NestedPropertyAsResponse *JsonResponseBodyWithProperty
}

func NewJsonResponseFromResponse(value *JsonResponseBody) *JsonResponse {
	return &JsonResponse{Type: "response", Response: value}
}

func NewJsonResponseFromNestedPropertyAsResponse(value *JsonResponseBodyWithProperty) *JsonResponse {
	return &JsonResponse{Type: "nestedPropertyAsResponse", NestedPropertyAsResponse: value}
}

func (j *JsonResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	j.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "response":
		value := new(JsonResponseBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Response = value
	case "nestedPropertyAsResponse":
		value := new(JsonResponseBodyWithProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.NestedPropertyAsResponse = value
	}
	return nil
}

func (j JsonResponse) MarshalJSON() ([]byte, error) {
	switch j.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.Type, j)
	case "response":
		var marshaler = struct {
			Type string `json:"type"`
			*JsonResponseBody
		}{
			Type:             "response",
			JsonResponseBody: j.Response,
		}
		return json.Marshal(marshaler)
	case "nestedPropertyAsResponse":
		var marshaler = struct {
			Type string `json:"type"`
			*JsonResponseBodyWithProperty
		}{
			Type:                         "nestedPropertyAsResponse",
			JsonResponseBodyWithProperty: j.NestedPropertyAsResponse,
		}
		return json.Marshal(marshaler)
	}
}

type JsonResponseVisitor interface {
	VisitResponse(*JsonResponseBody) error
	VisitNestedPropertyAsResponse(*JsonResponseBodyWithProperty) error
}

func (j *JsonResponse) Accept(visitor JsonResponseVisitor) error {
	switch j.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", j.Type, j)
	case "response":
		return visitor.VisitResponse(j.Response)
	case "nestedPropertyAsResponse":
		return visitor.VisitNestedPropertyAsResponse(j.NestedPropertyAsResponse)
	}
}

type JsonResponseBody struct {
	Docs             *string        `json:"docs,omitempty" url:"docs,omitempty"`
	ResponseBodyType *TypeReference `json:"responseBodyType,omitempty" url:"responseBodyType,omitempty"`
}

func (j *JsonResponseBody) String() string {
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JsonResponseBodyWithProperty struct {
	Docs             *string        `json:"docs,omitempty" url:"docs,omitempty"`
	ResponseBodyType *TypeReference `json:"responseBodyType,omitempty" url:"responseBodyType,omitempty"`
	// If set, the SDK will return this property from
	// the response, rather than the response itself.
	//
	// This is particularly useful for JSON API structures
	// (e.g. configure 'data' to return 'response.data').
	ResponseProperty *ObjectProperty `json:"responseProperty,omitempty" url:"responseProperty,omitempty"`
}

func (j *JsonResponseBodyWithProperty) String() string {
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JsonStreamChunk struct {
	Docs       *string        `json:"docs,omitempty" url:"docs,omitempty"`
	Payload    *TypeReference `json:"payload,omitempty" url:"payload,omitempty"`
	Terminator *string        `json:"terminator,omitempty" url:"terminator,omitempty"`
}

func (j *JsonStreamChunk) String() string {
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// The page must be defined as a query parameter included in the request,
// whereas the results are resolved from properties defined on the response.
//
// The page index is auto-incremented between every additional page request.
type OffsetPagination struct {
	Page    *QueryParameter   `json:"page,omitempty" url:"page,omitempty"`
	Results *ResponseProperty `json:"results,omitempty" url:"results,omitempty"`
}

func (o *OffsetPagination) String() string {
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// If set, the endpoint will be generated with auto-pagination features.
type Pagination struct {
	Type   string
	Cursor *CursorPagination
	Offset *OffsetPagination
}

func NewPaginationFromCursor(value *CursorPagination) *Pagination {
	return &Pagination{Type: "cursor", Cursor: value}
}

func NewPaginationFromOffset(value *OffsetPagination) *Pagination {
	return &Pagination{Type: "offset", Offset: value}
}

func (p *Pagination) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "cursor":
		value := new(CursorPagination)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Cursor = value
	case "offset":
		value := new(OffsetPagination)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Offset = value
	}
	return nil
}

func (p Pagination) MarshalJSON() ([]byte, error) {
	switch p.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "cursor":
		var marshaler = struct {
			Type string `json:"type"`
			*CursorPagination
		}{
			Type:             "cursor",
			CursorPagination: p.Cursor,
		}
		return json.Marshal(marshaler)
	case "offset":
		var marshaler = struct {
			Type string `json:"type"`
			*OffsetPagination
		}{
			Type:             "offset",
			OffsetPagination: p.Offset,
		}
		return json.Marshal(marshaler)
	}
}

type PaginationVisitor interface {
	VisitCursor(*CursorPagination) error
	VisitOffset(*OffsetPagination) error
}

func (p *Pagination) Accept(visitor PaginationVisitor) error {
	switch p.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "cursor":
		return visitor.VisitCursor(p.Cursor)
	case "offset":
		return visitor.VisitOffset(p.Offset)
	}
}

type PathParameter struct {
	Docs      *string               `json:"docs,omitempty" url:"docs,omitempty"`
	Name      *Name                 `json:"name,omitempty" url:"name,omitempty"`
	ValueType *TypeReference        `json:"valueType,omitempty" url:"valueType,omitempty"`
	Location  PathParameterLocation `json:"location,omitempty" url:"location,omitempty"`
	Variable  *VariableId           `json:"variable,omitempty" url:"variable,omitempty"`
}

func (p *PathParameter) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PathParameterLocation string

const (
	PathParameterLocationRoot     PathParameterLocation = "ROOT"
	PathParameterLocationService  PathParameterLocation = "SERVICE"
	PathParameterLocationEndpoint PathParameterLocation = "ENDPOINT"
)

func NewPathParameterLocationFromString(s string) (PathParameterLocation, error) {
	switch s {
	case "ROOT":
		return PathParameterLocationRoot, nil
	case "SERVICE":
		return PathParameterLocationService, nil
	case "ENDPOINT":
		return PathParameterLocationEndpoint, nil
	}
	var t PathParameterLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PathParameterLocation) Ptr() *PathParameterLocation {
	return &p
}

type QueryParameter struct {
	Docs          *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability  *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name          *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType     *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`
	AllowMultiple bool              `json:"allowMultiple" url:"allowMultiple"`
}

func (q *QueryParameter) String() string {
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

// A property associated with an endpoint's request.
type RequestProperty struct {
	// If empty, the property is defined at the top-level.
	// Otherwise, the property is defined on the nested object identified
	// by the path.
	PropertyPath []*Name               `json:"propertyPath,omitempty" url:"propertyPath,omitempty"`
	Property     *RequestPropertyValue `json:"property,omitempty" url:"property,omitempty"`
}

func (r *RequestProperty) String() string {
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RequestPropertyValue struct {
	Type  string
	Query *QueryParameter
	Body  *ObjectProperty
}

func NewRequestPropertyValueFromQuery(value *QueryParameter) *RequestPropertyValue {
	return &RequestPropertyValue{Type: "query", Query: value}
}

func NewRequestPropertyValueFromBody(value *ObjectProperty) *RequestPropertyValue {
	return &RequestPropertyValue{Type: "body", Body: value}
}

func (r *RequestPropertyValue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "query":
		value := new(QueryParameter)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Query = value
	case "body":
		value := new(ObjectProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Body = value
	}
	return nil
}

func (r RequestPropertyValue) MarshalJSON() ([]byte, error) {
	switch r.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "query":
		var marshaler = struct {
			Type string `json:"type"`
			*QueryParameter
		}{
			Type:           "query",
			QueryParameter: r.Query,
		}
		return json.Marshal(marshaler)
	case "body":
		var marshaler = struct {
			Type string `json:"type"`
			*ObjectProperty
		}{
			Type:           "body",
			ObjectProperty: r.Body,
		}
		return json.Marshal(marshaler)
	}
}

type RequestPropertyValueVisitor interface {
	VisitQuery(*QueryParameter) error
	VisitBody(*ObjectProperty) error
}

func (r *RequestPropertyValue) Accept(visitor RequestPropertyValueVisitor) error {
	switch r.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "query":
		return visitor.VisitQuery(r.Query)
	case "body":
		return visitor.VisitBody(r.Body)
	}
}

type ResponseError struct {
	Docs  *string            `json:"docs,omitempty" url:"docs,omitempty"`
	Error *DeclaredErrorName `json:"error,omitempty" url:"error,omitempty"`
}

func (r *ResponseError) String() string {
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseErrors = []*ResponseError

// A property associated with a paginated endpoint's request or response.
type ResponseProperty struct {
	// If empty, the property is defined at the top-level.
	// Otherwise, the property is defined on the nested object identified
	// by the path.
	PropertyPath []*Name         `json:"propertyPath,omitempty" url:"propertyPath,omitempty"`
	Property     *ObjectProperty `json:"property,omitempty" url:"property,omitempty"`
}

func (r *ResponseProperty) String() string {
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SdkRequest struct {
	RequestParameterName *Name            `json:"requestParameterName,omitempty" url:"requestParameterName,omitempty"`
	Shape                *SdkRequestShape `json:"shape,omitempty" url:"shape,omitempty"`
}

func (s *SdkRequest) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SdkRequestBodyType struct {
	Type          string
	TypeReference *HttpRequestBodyReference
	Bytes         *BytesRequest
}

func NewSdkRequestBodyTypeFromTypeReference(value *HttpRequestBodyReference) *SdkRequestBodyType {
	return &SdkRequestBodyType{Type: "typeReference", TypeReference: value}
}

func NewSdkRequestBodyTypeFromBytes(value *BytesRequest) *SdkRequestBodyType {
	return &SdkRequestBodyType{Type: "bytes", Bytes: value}
}

func (s *SdkRequestBodyType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "typeReference":
		value := new(HttpRequestBodyReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.TypeReference = value
	case "bytes":
		value := new(BytesRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Bytes = value
	}
	return nil
}

func (s SdkRequestBodyType) MarshalJSON() ([]byte, error) {
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "typeReference":
		var marshaler = struct {
			Type string `json:"type"`
			*HttpRequestBodyReference
		}{
			Type:                     "typeReference",
			HttpRequestBodyReference: s.TypeReference,
		}
		return json.Marshal(marshaler)
	case "bytes":
		var marshaler = struct {
			Type string `json:"type"`
			*BytesRequest
		}{
			Type:         "bytes",
			BytesRequest: s.Bytes,
		}
		return json.Marshal(marshaler)
	}
}

type SdkRequestBodyTypeVisitor interface {
	VisitTypeReference(*HttpRequestBodyReference) error
	VisitBytes(*BytesRequest) error
}

func (s *SdkRequestBodyType) Accept(visitor SdkRequestBodyTypeVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "typeReference":
		return visitor.VisitTypeReference(s.TypeReference)
	case "bytes":
		return visitor.VisitBytes(s.Bytes)
	}
}

type SdkRequestShape struct {
	Type            string
	JustRequestBody *SdkRequestBodyType
	Wrapper         *SdkRequestWrapper
}

func NewSdkRequestShapeFromJustRequestBody(value *SdkRequestBodyType) *SdkRequestShape {
	return &SdkRequestShape{Type: "justRequestBody", JustRequestBody: value}
}

func NewSdkRequestShapeFromWrapper(value *SdkRequestWrapper) *SdkRequestShape {
	return &SdkRequestShape{Type: "wrapper", Wrapper: value}
}

func (s *SdkRequestShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "justRequestBody":
		var valueUnmarshaler struct {
			JustRequestBody *SdkRequestBodyType `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.JustRequestBody = valueUnmarshaler.JustRequestBody
	case "wrapper":
		value := new(SdkRequestWrapper)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Wrapper = value
	}
	return nil
}

func (s SdkRequestShape) MarshalJSON() ([]byte, error) {
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "justRequestBody":
		var marshaler = struct {
			Type            string              `json:"type"`
			JustRequestBody *SdkRequestBodyType `json:"value,omitempty"`
		}{
			Type:            "justRequestBody",
			JustRequestBody: s.JustRequestBody,
		}
		return json.Marshal(marshaler)
	case "wrapper":
		var marshaler = struct {
			Type string `json:"type"`
			*SdkRequestWrapper
		}{
			Type:              "wrapper",
			SdkRequestWrapper: s.Wrapper,
		}
		return json.Marshal(marshaler)
	}
}

type SdkRequestShapeVisitor interface {
	VisitJustRequestBody(*SdkRequestBodyType) error
	VisitWrapper(*SdkRequestWrapper) error
}

func (s *SdkRequestShape) Accept(visitor SdkRequestShapeVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "justRequestBody":
		return visitor.VisitJustRequestBody(s.JustRequestBody)
	case "wrapper":
		return visitor.VisitWrapper(s.Wrapper)
	}
}

type SdkRequestWrapper struct {
	WrapperName *Name `json:"wrapperName,omitempty" url:"wrapperName,omitempty"`
	BodyKey     *Name `json:"bodyKey,omitempty" url:"bodyKey,omitempty"`
}

func (s *SdkRequestWrapper) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SseStreamChunk struct {
	Docs       *string        `json:"docs,omitempty" url:"docs,omitempty"`
	Payload    *TypeReference `json:"payload,omitempty" url:"payload,omitempty"`
	Terminator *string        `json:"terminator,omitempty" url:"terminator,omitempty"`
}

func (s *SseStreamChunk) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StreamingResponse struct {
	Type string
	Json *JsonStreamChunk
	Text *TextStreamChunk
	Sse  *SseStreamChunk
}

func NewStreamingResponseFromJson(value *JsonStreamChunk) *StreamingResponse {
	return &StreamingResponse{Type: "json", Json: value}
}

func NewStreamingResponseFromText(value *TextStreamChunk) *StreamingResponse {
	return &StreamingResponse{Type: "text", Text: value}
}

func NewStreamingResponseFromSse(value *SseStreamChunk) *StreamingResponse {
	return &StreamingResponse{Type: "sse", Sse: value}
}

func (s *StreamingResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "json":
		value := new(JsonStreamChunk)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Json = value
	case "text":
		value := new(TextStreamChunk)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Text = value
	case "sse":
		value := new(SseStreamChunk)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Sse = value
	}
	return nil
}

func (s StreamingResponse) MarshalJSON() ([]byte, error) {
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "json":
		var marshaler = struct {
			Type string `json:"type"`
			*JsonStreamChunk
		}{
			Type:            "json",
			JsonStreamChunk: s.Json,
		}
		return json.Marshal(marshaler)
	case "text":
		var marshaler = struct {
			Type string `json:"type"`
			*TextStreamChunk
		}{
			Type:            "text",
			TextStreamChunk: s.Text,
		}
		return json.Marshal(marshaler)
	case "sse":
		var marshaler = struct {
			Type string `json:"type"`
			*SseStreamChunk
		}{
			Type:           "sse",
			SseStreamChunk: s.Sse,
		}
		return json.Marshal(marshaler)
	}
}

type StreamingResponseVisitor interface {
	VisitJson(*JsonStreamChunk) error
	VisitText(*TextStreamChunk) error
	VisitSse(*SseStreamChunk) error
}

func (s *StreamingResponse) Accept(visitor StreamingResponseVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "json":
		return visitor.VisitJson(s.Json)
	case "text":
		return visitor.VisitText(s.Text)
	case "sse":
		return visitor.VisitSse(s.Sse)
	}
}

type SupportedSdkLanguage string

const (
	SupportedSdkLanguageCurl       SupportedSdkLanguage = "curl"
	SupportedSdkLanguagePython     SupportedSdkLanguage = "python"
	SupportedSdkLanguageJavascript SupportedSdkLanguage = "javascript"
	SupportedSdkLanguageTypescript SupportedSdkLanguage = "typescript"
	SupportedSdkLanguageGo         SupportedSdkLanguage = "go"
	SupportedSdkLanguageRuby       SupportedSdkLanguage = "ruby"
	SupportedSdkLanguageCsharp     SupportedSdkLanguage = "csharp"
	SupportedSdkLanguageJava       SupportedSdkLanguage = "java"
)

func NewSupportedSdkLanguageFromString(s string) (SupportedSdkLanguage, error) {
	switch s {
	case "curl":
		return SupportedSdkLanguageCurl, nil
	case "python":
		return SupportedSdkLanguagePython, nil
	case "javascript":
		return SupportedSdkLanguageJavascript, nil
	case "typescript":
		return SupportedSdkLanguageTypescript, nil
	case "go":
		return SupportedSdkLanguageGo, nil
	case "ruby":
		return SupportedSdkLanguageRuby, nil
	case "csharp":
		return SupportedSdkLanguageCsharp, nil
	case "java":
		return SupportedSdkLanguageJava, nil
	}
	var t SupportedSdkLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SupportedSdkLanguage) Ptr() *SupportedSdkLanguage {
	return &s
}

type TextResponse struct {
	Docs *string `json:"docs,omitempty" url:"docs,omitempty"`
}

func (t *TextResponse) String() string {
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TextStreamChunk struct {
	Docs *string `json:"docs,omitempty" url:"docs,omitempty"`
}

func (t *TextStreamChunk) String() string {
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ErrorDiscriminationByPropertyStrategy struct {
	Discriminant    *NameAndWireValue `json:"discriminant,omitempty" url:"discriminant,omitempty"`
	ContentProperty *NameAndWireValue `json:"contentProperty,omitempty" url:"contentProperty,omitempty"`
}

func (e *ErrorDiscriminationByPropertyStrategy) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorDiscriminationStrategy struct {
	Type       string
	StatusCode interface{}
	Property   *ErrorDiscriminationByPropertyStrategy
}

func NewErrorDiscriminationStrategyFromStatusCode(value interface{}) *ErrorDiscriminationStrategy {
	return &ErrorDiscriminationStrategy{Type: "statusCode", StatusCode: value}
}

func NewErrorDiscriminationStrategyFromProperty(value *ErrorDiscriminationByPropertyStrategy) *ErrorDiscriminationStrategy {
	return &ErrorDiscriminationStrategy{Type: "property", Property: value}
}

func (e *ErrorDiscriminationStrategy) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "statusCode":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.StatusCode = value
	case "property":
		value := new(ErrorDiscriminationByPropertyStrategy)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Property = value
	}
	return nil
}

func (e ErrorDiscriminationStrategy) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "statusCode":
		var marshaler = struct {
			Type       string      `json:"type"`
			StatusCode interface{} `json:"statusCode,omitempty"`
		}{
			Type:       "statusCode",
			StatusCode: e.StatusCode,
		}
		return json.Marshal(marshaler)
	case "property":
		var marshaler = struct {
			Type string `json:"type"`
			*ErrorDiscriminationByPropertyStrategy
		}{
			Type:                                  "property",
			ErrorDiscriminationByPropertyStrategy: e.Property,
		}
		return json.Marshal(marshaler)
	}
}

type ErrorDiscriminationStrategyVisitor interface {
	VisitStatusCode(interface{}) error
	VisitProperty(*ErrorDiscriminationByPropertyStrategy) error
}

func (e *ErrorDiscriminationStrategy) Accept(visitor ErrorDiscriminationStrategyVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "statusCode":
		return visitor.VisitStatusCode(e.StatusCode)
	case "property":
		return visitor.VisitProperty(e.Property)
	}
}

// Complete representation of the API schema
type IntermediateRepresentation struct {
	// This is the human readable unique id for the API.
	ApiName        *Name    `json:"apiName,omitempty" url:"apiName,omitempty"`
	ApiDisplayName *string  `json:"apiDisplayName,omitempty" url:"apiDisplayName,omitempty"`
	ApiDocs        *string  `json:"apiDocs,omitempty" url:"apiDocs,omitempty"`
	Auth           *ApiAuth `json:"auth,omitempty" url:"auth,omitempty"`
	// API Wide headers that are sent on every request
	Headers []*HttpHeader `json:"headers,omitempty" url:"headers,omitempty"`
	// Headers that are sent for idempotent endpoints
	IdempotencyHeaders []*HttpHeader `json:"idempotencyHeaders,omitempty" url:"idempotencyHeaders,omitempty"`
	// The types described by this API
	Types map[TypeId]*TypeDeclaration `json:"types,omitempty" url:"types,omitempty"`
	// The services exposed by this API
	Services map[ServiceId]*HttpService `json:"services,omitempty" url:"services,omitempty"`
	// The webhooks sent by this API
	WebhookGroups map[WebhookGroupId]WebhookGroup `json:"webhookGroups,omitempty" url:"webhookGroups,omitempty"`
	// The websocket channels served by this API
	WebsocketChannels           map[WebSocketChannelId]*WebSocketChannel `json:"websocketChannels,omitempty" url:"websocketChannels,omitempty"`
	Errors                      map[ErrorId]*ErrorDeclaration            `json:"errors,omitempty" url:"errors,omitempty"`
	Subpackages                 map[SubpackageId]*Subpackage             `json:"subpackages,omitempty" url:"subpackages,omitempty"`
	RootPackage                 *Package                                 `json:"rootPackage,omitempty" url:"rootPackage,omitempty"`
	Constants                   *Constants                               `json:"constants,omitempty" url:"constants,omitempty"`
	Environments                *EnvironmentsConfig                      `json:"environments,omitempty" url:"environments,omitempty"`
	BasePath                    *HttpPath                                `json:"basePath,omitempty" url:"basePath,omitempty"`
	PathParameters              []*PathParameter                         `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	ErrorDiscriminationStrategy *ErrorDiscriminationStrategy             `json:"errorDiscriminationStrategy,omitempty" url:"errorDiscriminationStrategy,omitempty"`
	SdkConfig                   *SdkConfig                               `json:"sdkConfig,omitempty" url:"sdkConfig,omitempty"`
	Variables                   []*VariableDeclaration                   `json:"variables,omitempty" url:"variables,omitempty"`
	ServiceTypeReferenceInfo    *ServiceTypeReferenceInfo                `json:"serviceTypeReferenceInfo,omitempty" url:"serviceTypeReferenceInfo,omitempty"`
}

func (i *IntermediateRepresentation) String() string {
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Package struct {
	Docs               *string                  `json:"docs,omitempty" url:"docs,omitempty"`
	FernFilepath       *FernFilepath            `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`
	Service            *ServiceId               `json:"service,omitempty" url:"service,omitempty"`
	Types              []TypeId                 `json:"types,omitempty" url:"types,omitempty"`
	Errors             []ErrorId                `json:"errors,omitempty" url:"errors,omitempty"`
	Webhooks           *WebhookGroupId          `json:"webhooks,omitempty" url:"webhooks,omitempty"`
	Websocket          *WebSocketChannelId      `json:"websocket,omitempty" url:"websocket,omitempty"`
	Subpackages        []SubpackageId           `json:"subpackages,omitempty" url:"subpackages,omitempty"`
	HasEndpointsInTree bool                     `json:"hasEndpointsInTree" url:"hasEndpointsInTree"`
	NavigationConfig   *PackageNavigationConfig `json:"navigationConfig,omitempty" url:"navigationConfig,omitempty"`
}

func (p *Package) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PackageNavigationConfig struct {
	PointsTo SubpackageId `json:"pointsTo" url:"pointsTo"`
}

func (p *PackageNavigationConfig) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PlatformHeaders struct {
	Language   string `json:"language" url:"language"`
	SdkName    string `json:"sdkName" url:"sdkName"`
	SdkVersion string `json:"sdkVersion" url:"sdkVersion"`
}

func (p *PlatformHeaders) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type SdkConfig struct {
	IsAuthMandatory          bool             `json:"isAuthMandatory" url:"isAuthMandatory"`
	HasStreamingEndpoints    bool             `json:"hasStreamingEndpoints" url:"hasStreamingEndpoints"`
	HasFileDownloadEndpoints bool             `json:"hasFileDownloadEndpoints" url:"hasFileDownloadEndpoints"`
	PlatformHeaders          *PlatformHeaders `json:"platformHeaders,omitempty" url:"platformHeaders,omitempty"`
}

func (s *SdkConfig) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServiceTypeReferenceInfo struct {
	// Types referenced by exactly one service.
	TypesReferencedOnlyByService map[ServiceId][]TypeId `json:"typesReferencedOnlyByService,omitempty" url:"typesReferencedOnlyByService,omitempty"`
	// Types referenced by either zero or multiple services.
	SharedTypes []TypeId `json:"sharedTypes,omitempty" url:"sharedTypes,omitempty"`
}

func (s *ServiceTypeReferenceInfo) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Subpackage struct {
	Docs               *string                  `json:"docs,omitempty" url:"docs,omitempty"`
	FernFilepath       *FernFilepath            `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`
	Service            *ServiceId               `json:"service,omitempty" url:"service,omitempty"`
	Types              []TypeId                 `json:"types,omitempty" url:"types,omitempty"`
	Errors             []ErrorId                `json:"errors,omitempty" url:"errors,omitempty"`
	Webhooks           *WebhookGroupId          `json:"webhooks,omitempty" url:"webhooks,omitempty"`
	Websocket          *WebSocketChannelId      `json:"websocket,omitempty" url:"websocket,omitempty"`
	Subpackages        []SubpackageId           `json:"subpackages,omitempty" url:"subpackages,omitempty"`
	HasEndpointsInTree bool                     `json:"hasEndpointsInTree" url:"hasEndpointsInTree"`
	NavigationConfig   *PackageNavigationConfig `json:"navigationConfig,omitempty" url:"navigationConfig,omitempty"`
	Name               *Name                    `json:"name,omitempty" url:"name,omitempty"`
}

func (s *Subpackage) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type AliasTypeDeclaration struct {
	AliasOf      *TypeReference         `json:"aliasOf,omitempty" url:"aliasOf,omitempty"`
	ResolvedType *ResolvedTypeReference `json:"resolvedType,omitempty" url:"resolvedType,omitempty"`
}

func (a *AliasTypeDeclaration) String() string {
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ContainerType struct {
	Type     string
	List     *TypeReference
	Map      *MapType
	Optional *TypeReference
	Set      *TypeReference
	Literal  *Literal
}

func NewContainerTypeFromList(value *TypeReference) *ContainerType {
	return &ContainerType{Type: "list", List: value}
}

func NewContainerTypeFromMap(value *MapType) *ContainerType {
	return &ContainerType{Type: "map", Map: value}
}

func NewContainerTypeFromOptional(value *TypeReference) *ContainerType {
	return &ContainerType{Type: "optional", Optional: value}
}

func NewContainerTypeFromSet(value *TypeReference) *ContainerType {
	return &ContainerType{Type: "set", Set: value}
}

func NewContainerTypeFromLiteral(value *Literal) *ContainerType {
	return &ContainerType{Type: "literal", Literal: value}
}

func (c *ContainerType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "list":
		var valueUnmarshaler struct {
			List *TypeReference `json:"list,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.List = valueUnmarshaler.List
	case "map":
		value := new(MapType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Map = value
	case "optional":
		var valueUnmarshaler struct {
			Optional *TypeReference `json:"optional,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Optional = valueUnmarshaler.Optional
	case "set":
		var valueUnmarshaler struct {
			Set *TypeReference `json:"set,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Set = valueUnmarshaler.Set
	case "literal":
		var valueUnmarshaler struct {
			Literal *Literal `json:"literal,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Literal = valueUnmarshaler.Literal
	}
	return nil
}

func (c ContainerType) MarshalJSON() ([]byte, error) {
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "list":
		var marshaler = struct {
			Type string         `json:"_type"`
			List *TypeReference `json:"list,omitempty"`
		}{
			Type: "list",
			List: c.List,
		}
		return json.Marshal(marshaler)
	case "map":
		var marshaler = struct {
			Type string `json:"_type"`
			*MapType
		}{
			Type:    "map",
			MapType: c.Map,
		}
		return json.Marshal(marshaler)
	case "optional":
		var marshaler = struct {
			Type     string         `json:"_type"`
			Optional *TypeReference `json:"optional,omitempty"`
		}{
			Type:     "optional",
			Optional: c.Optional,
		}
		return json.Marshal(marshaler)
	case "set":
		var marshaler = struct {
			Type string         `json:"_type"`
			Set  *TypeReference `json:"set,omitempty"`
		}{
			Type: "set",
			Set:  c.Set,
		}
		return json.Marshal(marshaler)
	case "literal":
		var marshaler = struct {
			Type    string   `json:"_type"`
			Literal *Literal `json:"literal,omitempty"`
		}{
			Type:    "literal",
			Literal: c.Literal,
		}
		return json.Marshal(marshaler)
	}
}

type ContainerTypeVisitor interface {
	VisitList(*TypeReference) error
	VisitMap(*MapType) error
	VisitOptional(*TypeReference) error
	VisitSet(*TypeReference) error
	VisitLiteral(*Literal) error
}

func (c *ContainerType) Accept(visitor ContainerTypeVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "list":
		return visitor.VisitList(c.List)
	case "map":
		return visitor.VisitMap(c.Map)
	case "optional":
		return visitor.VisitOptional(c.Optional)
	case "set":
		return visitor.VisitSet(c.Set)
	case "literal":
		return visitor.VisitLiteral(c.Literal)
	}
}

type DeclaredTypeName struct {
	TypeId       TypeId        `json:"typeId" url:"typeId"`
	FernFilepath *FernFilepath `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`
	Name         *Name         `json:"name,omitempty" url:"name,omitempty"`
}

func (d *DeclaredTypeName) String() string {
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EnumTypeDeclaration struct {
	Values []*EnumValue `json:"values,omitempty" url:"values,omitempty"`
}

func (e *EnumTypeDeclaration) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumValue struct {
	Docs         *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name         *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
}

func (e *EnumValue) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleAliasType struct {
	Value *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`
}

func (e *ExampleAliasType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleContainer struct {
	Type     string
	List     []*ExampleTypeReference
	Set      []*ExampleTypeReference
	Optional *ExampleTypeReference
	Map      []*ExampleKeyValuePair
}

func NewExampleContainerFromList(value []*ExampleTypeReference) *ExampleContainer {
	return &ExampleContainer{Type: "list", List: value}
}

func NewExampleContainerFromSet(value []*ExampleTypeReference) *ExampleContainer {
	return &ExampleContainer{Type: "set", Set: value}
}

func NewExampleContainerFromOptional(value *ExampleTypeReference) *ExampleContainer {
	return &ExampleContainer{Type: "optional", Optional: value}
}

func NewExampleContainerFromMap(value []*ExampleKeyValuePair) *ExampleContainer {
	return &ExampleContainer{Type: "map", Map: value}
}

func (e *ExampleContainer) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "list":
		var valueUnmarshaler struct {
			List []*ExampleTypeReference `json:"list,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.List = valueUnmarshaler.List
	case "set":
		var valueUnmarshaler struct {
			Set []*ExampleTypeReference `json:"set,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Set = valueUnmarshaler.Set
	case "optional":
		var valueUnmarshaler struct {
			Optional *ExampleTypeReference `json:"optional,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Optional = valueUnmarshaler.Optional
	case "map":
		var valueUnmarshaler struct {
			Map []*ExampleKeyValuePair `json:"map,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Map = valueUnmarshaler.Map
	}
	return nil
}

func (e ExampleContainer) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "list":
		var marshaler = struct {
			Type string                  `json:"type"`
			List []*ExampleTypeReference `json:"list,omitempty"`
		}{
			Type: "list",
			List: e.List,
		}
		return json.Marshal(marshaler)
	case "set":
		var marshaler = struct {
			Type string                  `json:"type"`
			Set  []*ExampleTypeReference `json:"set,omitempty"`
		}{
			Type: "set",
			Set:  e.Set,
		}
		return json.Marshal(marshaler)
	case "optional":
		var marshaler = struct {
			Type     string                `json:"type"`
			Optional *ExampleTypeReference `json:"optional,omitempty"`
		}{
			Type:     "optional",
			Optional: e.Optional,
		}
		return json.Marshal(marshaler)
	case "map":
		var marshaler = struct {
			Type string                 `json:"type"`
			Map  []*ExampleKeyValuePair `json:"map,omitempty"`
		}{
			Type: "map",
			Map:  e.Map,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleContainerVisitor interface {
	VisitList([]*ExampleTypeReference) error
	VisitSet([]*ExampleTypeReference) error
	VisitOptional(*ExampleTypeReference) error
	VisitMap([]*ExampleKeyValuePair) error
}

func (e *ExampleContainer) Accept(visitor ExampleContainerVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "list":
		return visitor.VisitList(e.List)
	case "set":
		return visitor.VisitSet(e.Set)
	case "optional":
		return visitor.VisitOptional(e.Optional)
	case "map":
		return visitor.VisitMap(e.Map)
	}
}

type ExampleEnumType struct {
	Value *NameAndWireValue `json:"value,omitempty" url:"value,omitempty"`
}

func (e *ExampleEnumType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleKeyValuePair struct {
	Key   *ExampleTypeReference `json:"key,omitempty" url:"key,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`
}

func (e *ExampleKeyValuePair) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleNamedType struct {
	TypeName *DeclaredTypeName `json:"typeName,omitempty" url:"typeName,omitempty"`
	Shape    *ExampleTypeShape `json:"shape,omitempty" url:"shape,omitempty"`
}

func (e *ExampleNamedType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleObjectProperty struct {
	Name  *NameAndWireValue     `json:"name,omitempty" url:"name,omitempty"`
	Value *ExampleTypeReference `json:"value,omitempty" url:"value,omitempty"`
	// This property may have been brought in via extension. originalTypeDeclaration
	// is the name of the type that contains this property.
	OriginalTypeDeclaration *DeclaredTypeName `json:"originalTypeDeclaration,omitempty" url:"originalTypeDeclaration,omitempty"`
}

func (e *ExampleObjectProperty) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleObjectType struct {
	Properties []*ExampleObjectProperty `json:"properties,omitempty" url:"properties,omitempty"`
}

func (e *ExampleObjectType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleObjectTypeWithTypeId struct {
	TypeId TypeId             `json:"typeId" url:"typeId"`
	Object *ExampleObjectType `json:"object,omitempty" url:"object,omitempty"`
}

func (e *ExampleObjectTypeWithTypeId) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExamplePrimitive struct {
	Type     string
	Integer  int
	Double   float64
	String   *EscapedString
	Boolean  bool
	Long     int64
	Datetime time.Time
	Date     time.Time
	Uuid     uuid.UUID
}

func NewExamplePrimitiveFromInteger(value int) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "integer", Integer: value}
}

func NewExamplePrimitiveFromDouble(value float64) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "double", Double: value}
}

func NewExamplePrimitiveFromString(value *EscapedString) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "string", String: value}
}

func NewExamplePrimitiveFromBoolean(value bool) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "boolean", Boolean: value}
}

func NewExamplePrimitiveFromLong(value int64) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "long", Long: value}
}

func NewExamplePrimitiveFromDatetime(value time.Time) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "datetime", Datetime: value}
}

func NewExamplePrimitiveFromDate(value time.Time) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "date", Date: value}
}

func NewExamplePrimitiveFromUuid(value uuid.UUID) *ExamplePrimitive {
	return &ExamplePrimitive{Type: "uuid", Uuid: value}
}

func (e *ExamplePrimitive) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "integer":
		var valueUnmarshaler struct {
			Integer int `json:"integer"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Integer = valueUnmarshaler.Integer
	case "double":
		var valueUnmarshaler struct {
			Double float64 `json:"double"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Double = valueUnmarshaler.Double
	case "string":
		var valueUnmarshaler struct {
			String *EscapedString `json:"string,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.String = valueUnmarshaler.String
	case "boolean":
		var valueUnmarshaler struct {
			Boolean bool `json:"boolean"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Boolean = valueUnmarshaler.Boolean
	case "long":
		var valueUnmarshaler struct {
			Long int64 `json:"long"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Long = valueUnmarshaler.Long
	case "datetime":
		var valueUnmarshaler struct {
			Datetime *core.DateTime `json:"datetime"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Datetime = valueUnmarshaler.Datetime.Time()
	case "date":
		var valueUnmarshaler struct {
			Date *core.Date `json:"date" format:"date"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Date = valueUnmarshaler.Date.Time()
	case "uuid":
		var valueUnmarshaler struct {
			Uuid uuid.UUID `json:"uuid"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Uuid = valueUnmarshaler.Uuid
	}
	return nil
}

func (e ExamplePrimitive) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "integer":
		var marshaler = struct {
			Type    string `json:"type"`
			Integer int    `json:"integer"`
		}{
			Type:    "integer",
			Integer: e.Integer,
		}
		return json.Marshal(marshaler)
	case "double":
		var marshaler = struct {
			Type   string  `json:"type"`
			Double float64 `json:"double"`
		}{
			Type:   "double",
			Double: e.Double,
		}
		return json.Marshal(marshaler)
	case "string":
		var marshaler = struct {
			Type   string         `json:"type"`
			String *EscapedString `json:"string,omitempty"`
		}{
			Type:   "string",
			String: e.String,
		}
		return json.Marshal(marshaler)
	case "boolean":
		var marshaler = struct {
			Type    string `json:"type"`
			Boolean bool   `json:"boolean"`
		}{
			Type:    "boolean",
			Boolean: e.Boolean,
		}
		return json.Marshal(marshaler)
	case "long":
		var marshaler = struct {
			Type string `json:"type"`
			Long int64  `json:"long"`
		}{
			Type: "long",
			Long: e.Long,
		}
		return json.Marshal(marshaler)
	case "datetime":
		var marshaler = struct {
			Type     string         `json:"type"`
			Datetime *core.DateTime `json:"datetime"`
		}{
			Type:     "datetime",
			Datetime: core.NewDateTime(e.Datetime),
		}
		return json.Marshal(marshaler)
	case "date":
		var marshaler = struct {
			Type string     `json:"type"`
			Date *core.Date `json:"date" format:"date"`
		}{
			Type: "date",
			Date: core.NewDate(e.Date),
		}
		return json.Marshal(marshaler)
	case "uuid":
		var marshaler = struct {
			Type string    `json:"type"`
			Uuid uuid.UUID `json:"uuid"`
		}{
			Type: "uuid",
			Uuid: e.Uuid,
		}
		return json.Marshal(marshaler)
	}
}

type ExamplePrimitiveVisitor interface {
	VisitInteger(int) error
	VisitDouble(float64) error
	VisitString(*EscapedString) error
	VisitBoolean(bool) error
	VisitLong(int64) error
	VisitDatetime(time.Time) error
	VisitDate(time.Time) error
	VisitUuid(uuid.UUID) error
}

func (e *ExamplePrimitive) Accept(visitor ExamplePrimitiveVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "integer":
		return visitor.VisitInteger(e.Integer)
	case "double":
		return visitor.VisitDouble(e.Double)
	case "string":
		return visitor.VisitString(e.String)
	case "boolean":
		return visitor.VisitBoolean(e.Boolean)
	case "long":
		return visitor.VisitLong(e.Long)
	case "datetime":
		return visitor.VisitDatetime(e.Datetime)
	case "date":
		return visitor.VisitDate(e.Date)
	case "uuid":
		return visitor.VisitUuid(e.Uuid)
	}
}

type ExampleSingleUnionType struct {
	WireDiscriminantValue *NameAndWireValue                 `json:"wireDiscriminantValue,omitempty" url:"wireDiscriminantValue,omitempty"`
	Shape                 *ExampleSingleUnionTypeProperties `json:"shape,omitempty" url:"shape,omitempty"`
}

func (e *ExampleSingleUnionType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleSingleUnionTypeProperties struct {
	Type                   string
	SamePropertiesAsObject *ExampleObjectTypeWithTypeId
	SingleProperty         *ExampleTypeReference
	NoProperties           interface{}
}

func NewExampleSingleUnionTypePropertiesFromSamePropertiesAsObject(value *ExampleObjectTypeWithTypeId) *ExampleSingleUnionTypeProperties {
	return &ExampleSingleUnionTypeProperties{Type: "samePropertiesAsObject", SamePropertiesAsObject: value}
}

func NewExampleSingleUnionTypePropertiesFromSingleProperty(value *ExampleTypeReference) *ExampleSingleUnionTypeProperties {
	return &ExampleSingleUnionTypeProperties{Type: "singleProperty", SingleProperty: value}
}

func NewExampleSingleUnionTypePropertiesFromNoProperties(value interface{}) *ExampleSingleUnionTypeProperties {
	return &ExampleSingleUnionTypeProperties{Type: "noProperties", NoProperties: value}
}

func (e *ExampleSingleUnionTypeProperties) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "samePropertiesAsObject":
		value := new(ExampleObjectTypeWithTypeId)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SamePropertiesAsObject = value
	case "singleProperty":
		value := new(ExampleTypeReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SingleProperty = value
	case "noProperties":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.NoProperties = value
	}
	return nil
}

func (e ExampleSingleUnionTypeProperties) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "samePropertiesAsObject":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleObjectTypeWithTypeId
		}{
			Type:                        "samePropertiesAsObject",
			ExampleObjectTypeWithTypeId: e.SamePropertiesAsObject,
		}
		return json.Marshal(marshaler)
	case "singleProperty":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleTypeReference
		}{
			Type:                 "singleProperty",
			ExampleTypeReference: e.SingleProperty,
		}
		return json.Marshal(marshaler)
	case "noProperties":
		var marshaler = struct {
			Type         string      `json:"type"`
			NoProperties interface{} `json:"noProperties,omitempty"`
		}{
			Type:         "noProperties",
			NoProperties: e.NoProperties,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleSingleUnionTypePropertiesVisitor interface {
	VisitSamePropertiesAsObject(*ExampleObjectTypeWithTypeId) error
	VisitSingleProperty(*ExampleTypeReference) error
	VisitNoProperties(interface{}) error
}

func (e *ExampleSingleUnionTypeProperties) Accept(visitor ExampleSingleUnionTypePropertiesVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "samePropertiesAsObject":
		return visitor.VisitSamePropertiesAsObject(e.SamePropertiesAsObject)
	case "singleProperty":
		return visitor.VisitSingleProperty(e.SingleProperty)
	case "noProperties":
		return visitor.VisitNoProperties(e.NoProperties)
	}
}

type ExampleType struct {
	JsonExample interface{}       `json:"jsonExample,omitempty" url:"jsonExample,omitempty"`
	Docs        *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Name        *Name             `json:"name,omitempty" url:"name,omitempty"`
	Shape       *ExampleTypeShape `json:"shape,omitempty" url:"shape,omitempty"`
}

func (e *ExampleType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleTypeReference struct {
	JsonExample interface{}                `json:"jsonExample,omitempty" url:"jsonExample,omitempty"`
	Shape       *ExampleTypeReferenceShape `json:"shape,omitempty" url:"shape,omitempty"`
}

func (e *ExampleTypeReference) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleTypeReferenceShape struct {
	Type      string
	Primitive *ExamplePrimitive
	Container *ExampleContainer
	Unknown   interface{}
	Named     *ExampleNamedType
}

func NewExampleTypeReferenceShapeFromPrimitive(value *ExamplePrimitive) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "primitive", Primitive: value}
}

func NewExampleTypeReferenceShapeFromContainer(value *ExampleContainer) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "container", Container: value}
}

func NewExampleTypeReferenceShapeFromUnknown(value interface{}) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "unknown", Unknown: value}
}

func NewExampleTypeReferenceShapeFromNamed(value *ExampleNamedType) *ExampleTypeReferenceShape {
	return &ExampleTypeReferenceShape{Type: "named", Named: value}
}

func (e *ExampleTypeReferenceShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "primitive":
		var valueUnmarshaler struct {
			Primitive *ExamplePrimitive `json:"primitive,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Primitive = valueUnmarshaler.Primitive
	case "container":
		var valueUnmarshaler struct {
			Container *ExampleContainer `json:"container,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Container = valueUnmarshaler.Container
	case "unknown":
		var valueUnmarshaler struct {
			Unknown interface{} `json:"unknown,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Unknown = valueUnmarshaler.Unknown
	case "named":
		value := new(ExampleNamedType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Named = value
	}
	return nil
}

func (e ExampleTypeReferenceShape) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "primitive":
		var marshaler = struct {
			Type      string            `json:"type"`
			Primitive *ExamplePrimitive `json:"primitive,omitempty"`
		}{
			Type:      "primitive",
			Primitive: e.Primitive,
		}
		return json.Marshal(marshaler)
	case "container":
		var marshaler = struct {
			Type      string            `json:"type"`
			Container *ExampleContainer `json:"container,omitempty"`
		}{
			Type:      "container",
			Container: e.Container,
		}
		return json.Marshal(marshaler)
	case "unknown":
		var marshaler = struct {
			Type    string      `json:"type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    "unknown",
			Unknown: e.Unknown,
		}
		return json.Marshal(marshaler)
	case "named":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleNamedType
		}{
			Type:             "named",
			ExampleNamedType: e.Named,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleTypeReferenceShapeVisitor interface {
	VisitPrimitive(*ExamplePrimitive) error
	VisitContainer(*ExampleContainer) error
	VisitUnknown(interface{}) error
	VisitNamed(*ExampleNamedType) error
}

func (e *ExampleTypeReferenceShape) Accept(visitor ExampleTypeReferenceShapeVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "primitive":
		return visitor.VisitPrimitive(e.Primitive)
	case "container":
		return visitor.VisitContainer(e.Container)
	case "unknown":
		return visitor.VisitUnknown(e.Unknown)
	case "named":
		return visitor.VisitNamed(e.Named)
	}
}

type ExampleTypeShape struct {
	Type                 string
	Alias                *ExampleAliasType
	Enum                 *ExampleEnumType
	Object               *ExampleObjectType
	Union                *ExampleUnionType
	UndiscriminatedUnion *ExampleUndiscriminatedUnionType
}

func NewExampleTypeShapeFromAlias(value *ExampleAliasType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "alias", Alias: value}
}

func NewExampleTypeShapeFromEnum(value *ExampleEnumType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "enum", Enum: value}
}

func NewExampleTypeShapeFromObject(value *ExampleObjectType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "object", Object: value}
}

func NewExampleTypeShapeFromUnion(value *ExampleUnionType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "union", Union: value}
}

func NewExampleTypeShapeFromUndiscriminatedUnion(value *ExampleUndiscriminatedUnionType) *ExampleTypeShape {
	return &ExampleTypeShape{Type: "undiscriminatedUnion", UndiscriminatedUnion: value}
}

func (e *ExampleTypeShape) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "alias":
		value := new(ExampleAliasType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Alias = value
	case "enum":
		value := new(ExampleEnumType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Enum = value
	case "object":
		value := new(ExampleObjectType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Object = value
	case "union":
		value := new(ExampleUnionType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Union = value
	case "undiscriminatedUnion":
		value := new(ExampleUndiscriminatedUnionType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.UndiscriminatedUnion = value
	}
	return nil
}

func (e ExampleTypeShape) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "alias":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleAliasType
		}{
			Type:             "alias",
			ExampleAliasType: e.Alias,
		}
		return json.Marshal(marshaler)
	case "enum":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleEnumType
		}{
			Type:            "enum",
			ExampleEnumType: e.Enum,
		}
		return json.Marshal(marshaler)
	case "object":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleObjectType
		}{
			Type:              "object",
			ExampleObjectType: e.Object,
		}
		return json.Marshal(marshaler)
	case "union":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleUnionType
		}{
			Type:             "union",
			ExampleUnionType: e.Union,
		}
		return json.Marshal(marshaler)
	case "undiscriminatedUnion":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleUndiscriminatedUnionType
		}{
			Type:                            "undiscriminatedUnion",
			ExampleUndiscriminatedUnionType: e.UndiscriminatedUnion,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleTypeShapeVisitor interface {
	VisitAlias(*ExampleAliasType) error
	VisitEnum(*ExampleEnumType) error
	VisitObject(*ExampleObjectType) error
	VisitUnion(*ExampleUnionType) error
	VisitUndiscriminatedUnion(*ExampleUndiscriminatedUnionType) error
}

func (e *ExampleTypeShape) Accept(visitor ExampleTypeShapeVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "alias":
		return visitor.VisitAlias(e.Alias)
	case "enum":
		return visitor.VisitEnum(e.Enum)
	case "object":
		return visitor.VisitObject(e.Object)
	case "union":
		return visitor.VisitUnion(e.Union)
	case "undiscriminatedUnion":
		return visitor.VisitUndiscriminatedUnion(e.UndiscriminatedUnion)
	}
}

type ExampleUndiscriminatedUnionType struct {
	// The zero-based index of the undiscriminated union variant.
	// For the following undiscriminated union
	//
	// ```
	// MyUnion:
	//
	//	discriminated: false
	//	union:
	//	  - string
	//	  - integer
	//
	// ```
	//
	// a string example would have an index 0 and an integer example
	// would have an index 1.
	Index           int                   `json:"index" url:"index"`
	SingleUnionType *ExampleTypeReference `json:"singleUnionType,omitempty" url:"singleUnionType,omitempty"`
}

func (e *ExampleUndiscriminatedUnionType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleUnionType struct {
	Discriminant    *NameAndWireValue       `json:"discriminant,omitempty" url:"discriminant,omitempty"`
	SingleUnionType *ExampleSingleUnionType `json:"singleUnionType,omitempty" url:"singleUnionType,omitempty"`
}

func (e *ExampleUnionType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type Literal struct {
	Type    string
	String  string
	Boolean bool
}

func NewLiteralFromString(value string) *Literal {
	return &Literal{Type: "string", String: value}
}

func NewLiteralFromBoolean(value bool) *Literal {
	return &Literal{Type: "boolean", Boolean: value}
}

func (l *Literal) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	l.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "string":
		var valueUnmarshaler struct {
			String string `json:"string"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		l.String = valueUnmarshaler.String
	case "boolean":
		var valueUnmarshaler struct {
			Boolean bool `json:"boolean"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		l.Boolean = valueUnmarshaler.Boolean
	}
	return nil
}

func (l Literal) MarshalJSON() ([]byte, error) {
	switch l.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.Type, l)
	case "string":
		var marshaler = struct {
			Type   string `json:"type"`
			String string `json:"string"`
		}{
			Type:   "string",
			String: l.String,
		}
		return json.Marshal(marshaler)
	case "boolean":
		var marshaler = struct {
			Type    string `json:"type"`
			Boolean bool   `json:"boolean"`
		}{
			Type:    "boolean",
			Boolean: l.Boolean,
		}
		return json.Marshal(marshaler)
	}
}

type LiteralVisitor interface {
	VisitString(string) error
	VisitBoolean(bool) error
}

func (l *Literal) Accept(visitor LiteralVisitor) error {
	switch l.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", l.Type, l)
	case "string":
		return visitor.VisitString(l.String)
	case "boolean":
		return visitor.VisitBoolean(l.Boolean)
	}
}

type MapType struct {
	KeyType   *TypeReference `json:"keyType,omitempty" url:"keyType,omitempty"`
	ValueType *TypeReference `json:"valueType,omitempty" url:"valueType,omitempty"`
}

func (m *MapType) String() string {
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ObjectProperty struct {
	Docs         *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name         *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType    *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`
}

func (o *ObjectProperty) String() string {
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type ObjectTypeDeclaration struct {
	// A list of other types to inherit from
	Extends    []*DeclaredTypeName `json:"extends,omitempty" url:"extends,omitempty"`
	Properties []*ObjectProperty   `json:"properties,omitempty" url:"properties,omitempty"`
	// Whether to allow extra properties on the object.
	ExtraProperties bool `json:"extra-properties" url:"extra-properties"`
}

func (o *ObjectTypeDeclaration) String() string {
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PrimitiveType string

const (
	PrimitiveTypeInteger PrimitiveType = "INTEGER"
	PrimitiveTypeDouble  PrimitiveType = "DOUBLE"
	PrimitiveTypeString  PrimitiveType = "STRING"
	PrimitiveTypeBoolean PrimitiveType = "BOOLEAN"
	// Within the range -2^53 to 2^53
	PrimitiveTypeLong     PrimitiveType = "LONG"
	PrimitiveTypeDateTime PrimitiveType = "DATE_TIME"
	PrimitiveTypeDate     PrimitiveType = "DATE"
	PrimitiveTypeUuid     PrimitiveType = "UUID"
	PrimitiveTypeBase64   PrimitiveType = "BASE_64"
)

func NewPrimitiveTypeFromString(s string) (PrimitiveType, error) {
	switch s {
	case "INTEGER":
		return PrimitiveTypeInteger, nil
	case "DOUBLE":
		return PrimitiveTypeDouble, nil
	case "STRING":
		return PrimitiveTypeString, nil
	case "BOOLEAN":
		return PrimitiveTypeBoolean, nil
	case "LONG":
		return PrimitiveTypeLong, nil
	case "DATE_TIME":
		return PrimitiveTypeDateTime, nil
	case "DATE":
		return PrimitiveTypeDate, nil
	case "UUID":
		return PrimitiveTypeUuid, nil
	case "BASE_64":
		return PrimitiveTypeBase64, nil
	}
	var t PrimitiveType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PrimitiveType) Ptr() *PrimitiveType {
	return &p
}

type ResolvedNamedType struct {
	Name  *DeclaredTypeName `json:"name,omitempty" url:"name,omitempty"`
	Shape ShapeType         `json:"shape,omitempty" url:"shape,omitempty"`
}

func (r *ResolvedNamedType) String() string {
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolvedTypeReference struct {
	Type      string
	Container *ContainerType
	Named     *ResolvedNamedType
	Primitive PrimitiveType
	Unknown   interface{}
}

func NewResolvedTypeReferenceFromContainer(value *ContainerType) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "container", Container: value}
}

func NewResolvedTypeReferenceFromNamed(value *ResolvedNamedType) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "named", Named: value}
}

func NewResolvedTypeReferenceFromPrimitive(value PrimitiveType) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "primitive", Primitive: value}
}

func NewResolvedTypeReferenceFromUnknown(value interface{}) *ResolvedTypeReference {
	return &ResolvedTypeReference{Type: "unknown", Unknown: value}
}

func (r *ResolvedTypeReference) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "container":
		var valueUnmarshaler struct {
			Container *ContainerType `json:"container,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.Container = valueUnmarshaler.Container
	case "named":
		value := new(ResolvedNamedType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Named = value
	case "primitive":
		var valueUnmarshaler struct {
			Primitive PrimitiveType `json:"primitive,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.Primitive = valueUnmarshaler.Primitive
	case "unknown":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Unknown = value
	}
	return nil
}

func (r ResolvedTypeReference) MarshalJSON() ([]byte, error) {
	switch r.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "container":
		var marshaler = struct {
			Type      string         `json:"_type"`
			Container *ContainerType `json:"container,omitempty"`
		}{
			Type:      "container",
			Container: r.Container,
		}
		return json.Marshal(marshaler)
	case "named":
		var marshaler = struct {
			Type string `json:"_type"`
			*ResolvedNamedType
		}{
			Type:              "named",
			ResolvedNamedType: r.Named,
		}
		return json.Marshal(marshaler)
	case "primitive":
		var marshaler = struct {
			Type      string        `json:"_type"`
			Primitive PrimitiveType `json:"primitive,omitempty"`
		}{
			Type:      "primitive",
			Primitive: r.Primitive,
		}
		return json.Marshal(marshaler)
	case "unknown":
		var marshaler = struct {
			Type    string      `json:"_type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    "unknown",
			Unknown: r.Unknown,
		}
		return json.Marshal(marshaler)
	}
}

type ResolvedTypeReferenceVisitor interface {
	VisitContainer(*ContainerType) error
	VisitNamed(*ResolvedNamedType) error
	VisitPrimitive(PrimitiveType) error
	VisitUnknown(interface{}) error
}

func (r *ResolvedTypeReference) Accept(visitor ResolvedTypeReferenceVisitor) error {
	switch r.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "container":
		return visitor.VisitContainer(r.Container)
	case "named":
		return visitor.VisitNamed(r.Named)
	case "primitive":
		return visitor.VisitPrimitive(r.Primitive)
	case "unknown":
		return visitor.VisitUnknown(r.Unknown)
	}
}

type ShapeType string

const (
	ShapeTypeEnum                 ShapeType = "ENUM"
	ShapeTypeObject               ShapeType = "OBJECT"
	ShapeTypeUnion                ShapeType = "UNION"
	ShapeTypeUndiscriminatedUnion ShapeType = "UNDISCRIMINATED_UNION"
)

func NewShapeTypeFromString(s string) (ShapeType, error) {
	switch s {
	case "ENUM":
		return ShapeTypeEnum, nil
	case "OBJECT":
		return ShapeTypeObject, nil
	case "UNION":
		return ShapeTypeUnion, nil
	case "UNDISCRIMINATED_UNION":
		return ShapeTypeUndiscriminatedUnion, nil
	}
	var t ShapeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShapeType) Ptr() *ShapeType {
	return &s
}

type SingleUnionType struct {
	Docs              *string                    `json:"docs,omitempty" url:"docs,omitempty"`
	DiscriminantValue *NameAndWireValue          `json:"discriminantValue,omitempty" url:"discriminantValue,omitempty"`
	Shape             *SingleUnionTypeProperties `json:"shape,omitempty" url:"shape,omitempty"`
}

func (s *SingleUnionType) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleUnionTypeProperties struct {
	PropertiesType         string
	SamePropertiesAsObject *DeclaredTypeName
	SingleProperty         *SingleUnionTypeProperty
	NoProperties           interface{}
}

func NewSingleUnionTypePropertiesFromSamePropertiesAsObject(value *DeclaredTypeName) *SingleUnionTypeProperties {
	return &SingleUnionTypeProperties{PropertiesType: "samePropertiesAsObject", SamePropertiesAsObject: value}
}

func NewSingleUnionTypePropertiesFromSingleProperty(value *SingleUnionTypeProperty) *SingleUnionTypeProperties {
	return &SingleUnionTypeProperties{PropertiesType: "singleProperty", SingleProperty: value}
}

func NewSingleUnionTypePropertiesFromNoProperties(value interface{}) *SingleUnionTypeProperties {
	return &SingleUnionTypeProperties{PropertiesType: "noProperties", NoProperties: value}
}

func (s *SingleUnionTypeProperties) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		PropertiesType string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.PropertiesType = unmarshaler.PropertiesType
	switch unmarshaler.PropertiesType {
	case "samePropertiesAsObject":
		value := new(DeclaredTypeName)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SamePropertiesAsObject = value
	case "singleProperty":
		value := new(SingleUnionTypeProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SingleProperty = value
	case "noProperties":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.NoProperties = value
	}
	return nil
}

func (s SingleUnionTypeProperties) MarshalJSON() ([]byte, error) {
	switch s.PropertiesType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.PropertiesType, s)
	case "samePropertiesAsObject":
		var marshaler = struct {
			PropertiesType string `json:"_type"`
			*DeclaredTypeName
		}{
			PropertiesType:   "samePropertiesAsObject",
			DeclaredTypeName: s.SamePropertiesAsObject,
		}
		return json.Marshal(marshaler)
	case "singleProperty":
		var marshaler = struct {
			PropertiesType string `json:"_type"`
			*SingleUnionTypeProperty
		}{
			PropertiesType:          "singleProperty",
			SingleUnionTypeProperty: s.SingleProperty,
		}
		return json.Marshal(marshaler)
	case "noProperties":
		var marshaler = struct {
			PropertiesType string      `json:"_type"`
			NoProperties   interface{} `json:"noProperties,omitempty"`
		}{
			PropertiesType: "noProperties",
			NoProperties:   s.NoProperties,
		}
		return json.Marshal(marshaler)
	}
}

type SingleUnionTypePropertiesVisitor interface {
	VisitSamePropertiesAsObject(*DeclaredTypeName) error
	VisitSingleProperty(*SingleUnionTypeProperty) error
	VisitNoProperties(interface{}) error
}

func (s *SingleUnionTypeProperties) Accept(visitor SingleUnionTypePropertiesVisitor) error {
	switch s.PropertiesType {
	default:
		return fmt.Errorf("invalid type %s in %T", s.PropertiesType, s)
	case "samePropertiesAsObject":
		return visitor.VisitSamePropertiesAsObject(s.SamePropertiesAsObject)
	case "singleProperty":
		return visitor.VisitSingleProperty(s.SingleProperty)
	case "noProperties":
		return visitor.VisitNoProperties(s.NoProperties)
	}
}

type SingleUnionTypeProperty struct {
	Name *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	Type *TypeReference    `json:"type,omitempty" url:"type,omitempty"`
}

func (s *SingleUnionTypeProperty) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Type struct {
	Type                 string
	Alias                *AliasTypeDeclaration
	Enum                 *EnumTypeDeclaration
	Object               *ObjectTypeDeclaration
	Union                *UnionTypeDeclaration
	UndiscriminatedUnion *UndiscriminatedUnionTypeDeclaration
}

func NewTypeFromAlias(value *AliasTypeDeclaration) *Type {
	return &Type{Type: "alias", Alias: value}
}

func NewTypeFromEnum(value *EnumTypeDeclaration) *Type {
	return &Type{Type: "enum", Enum: value}
}

func NewTypeFromObject(value *ObjectTypeDeclaration) *Type {
	return &Type{Type: "object", Object: value}
}

func NewTypeFromUnion(value *UnionTypeDeclaration) *Type {
	return &Type{Type: "union", Union: value}
}

func NewTypeFromUndiscriminatedUnion(value *UndiscriminatedUnionTypeDeclaration) *Type {
	return &Type{Type: "undiscriminatedUnion", UndiscriminatedUnion: value}
}

func (t *Type) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "alias":
		value := new(AliasTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Alias = value
	case "enum":
		value := new(EnumTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Enum = value
	case "object":
		value := new(ObjectTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Object = value
	case "union":
		value := new(UnionTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Union = value
	case "undiscriminatedUnion":
		value := new(UndiscriminatedUnionTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.UndiscriminatedUnion = value
	}
	return nil
}

func (t Type) MarshalJSON() ([]byte, error) {
	switch t.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "alias":
		var marshaler = struct {
			Type string `json:"_type"`
			*AliasTypeDeclaration
		}{
			Type:                 "alias",
			AliasTypeDeclaration: t.Alias,
		}
		return json.Marshal(marshaler)
	case "enum":
		var marshaler = struct {
			Type string `json:"_type"`
			*EnumTypeDeclaration
		}{
			Type:                "enum",
			EnumTypeDeclaration: t.Enum,
		}
		return json.Marshal(marshaler)
	case "object":
		var marshaler = struct {
			Type string `json:"_type"`
			*ObjectTypeDeclaration
		}{
			Type:                  "object",
			ObjectTypeDeclaration: t.Object,
		}
		return json.Marshal(marshaler)
	case "union":
		var marshaler = struct {
			Type string `json:"_type"`
			*UnionTypeDeclaration
		}{
			Type:                 "union",
			UnionTypeDeclaration: t.Union,
		}
		return json.Marshal(marshaler)
	case "undiscriminatedUnion":
		var marshaler = struct {
			Type string `json:"_type"`
			*UndiscriminatedUnionTypeDeclaration
		}{
			Type:                                "undiscriminatedUnion",
			UndiscriminatedUnionTypeDeclaration: t.UndiscriminatedUnion,
		}
		return json.Marshal(marshaler)
	}
}

type TypeVisitor interface {
	VisitAlias(*AliasTypeDeclaration) error
	VisitEnum(*EnumTypeDeclaration) error
	VisitObject(*ObjectTypeDeclaration) error
	VisitUnion(*UnionTypeDeclaration) error
	VisitUndiscriminatedUnion(*UndiscriminatedUnionTypeDeclaration) error
}

func (t *Type) Accept(visitor TypeVisitor) error {
	switch t.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "alias":
		return visitor.VisitAlias(t.Alias)
	case "enum":
		return visitor.VisitEnum(t.Enum)
	case "object":
		return visitor.VisitObject(t.Object)
	case "union":
		return visitor.VisitUnion(t.Union)
	case "undiscriminatedUnion":
		return visitor.VisitUndiscriminatedUnion(t.UndiscriminatedUnion)
	}
}

// A type, which is a name and a shape
type TypeDeclaration struct {
	Docs         *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name         *DeclaredTypeName `json:"name,omitempty" url:"name,omitempty"`
	Shape        *Type             `json:"shape,omitempty" url:"shape,omitempty"`
	Examples     []*ExampleType    `json:"examples,omitempty" url:"examples,omitempty"`
	// All other named types that this type references (directly or indirectly)
	ReferencedTypes []TypeId `json:"referencedTypes,omitempty" url:"referencedTypes,omitempty"`
}

func (t *TypeDeclaration) String() string {
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TypeReference struct {
	Type      string
	Container *ContainerType
	Named     *DeclaredTypeName
	Primitive PrimitiveType
	Unknown   interface{}
}

func NewTypeReferenceFromContainer(value *ContainerType) *TypeReference {
	return &TypeReference{Type: "container", Container: value}
}

func NewTypeReferenceFromNamed(value *DeclaredTypeName) *TypeReference {
	return &TypeReference{Type: "named", Named: value}
}

func NewTypeReferenceFromPrimitive(value PrimitiveType) *TypeReference {
	return &TypeReference{Type: "primitive", Primitive: value}
}

func NewTypeReferenceFromUnknown(value interface{}) *TypeReference {
	return &TypeReference{Type: "unknown", Unknown: value}
}

func (t *TypeReference) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "container":
		var valueUnmarshaler struct {
			Container *ContainerType `json:"container,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Container = valueUnmarshaler.Container
	case "named":
		value := new(DeclaredTypeName)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Named = value
	case "primitive":
		var valueUnmarshaler struct {
			Primitive PrimitiveType `json:"primitive,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Primitive = valueUnmarshaler.Primitive
	case "unknown":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Unknown = value
	}
	return nil
}

func (t TypeReference) MarshalJSON() ([]byte, error) {
	switch t.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "container":
		var marshaler = struct {
			Type      string         `json:"_type"`
			Container *ContainerType `json:"container,omitempty"`
		}{
			Type:      "container",
			Container: t.Container,
		}
		return json.Marshal(marshaler)
	case "named":
		var marshaler = struct {
			Type string `json:"_type"`
			*DeclaredTypeName
		}{
			Type:             "named",
			DeclaredTypeName: t.Named,
		}
		return json.Marshal(marshaler)
	case "primitive":
		var marshaler = struct {
			Type      string        `json:"_type"`
			Primitive PrimitiveType `json:"primitive,omitempty"`
		}{
			Type:      "primitive",
			Primitive: t.Primitive,
		}
		return json.Marshal(marshaler)
	case "unknown":
		var marshaler = struct {
			Type    string      `json:"_type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    "unknown",
			Unknown: t.Unknown,
		}
		return json.Marshal(marshaler)
	}
}

type TypeReferenceVisitor interface {
	VisitContainer(*ContainerType) error
	VisitNamed(*DeclaredTypeName) error
	VisitPrimitive(PrimitiveType) error
	VisitUnknown(interface{}) error
}

func (t *TypeReference) Accept(visitor TypeReferenceVisitor) error {
	switch t.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "container":
		return visitor.VisitContainer(t.Container)
	case "named":
		return visitor.VisitNamed(t.Named)
	case "primitive":
		return visitor.VisitPrimitive(t.Primitive)
	case "unknown":
		return visitor.VisitUnknown(t.Unknown)
	}
}

type UndiscriminatedUnionMember struct {
	Docs *string        `json:"docs,omitempty" url:"docs,omitempty"`
	Type *TypeReference `json:"type,omitempty" url:"type,omitempty"`
}

func (u *UndiscriminatedUnionMember) String() string {
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UndiscriminatedUnionTypeDeclaration struct {
	Members []*UndiscriminatedUnionMember `json:"members,omitempty" url:"members,omitempty"`
}

func (u *UndiscriminatedUnionTypeDeclaration) String() string {
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UnionTypeDeclaration struct {
	Discriminant *NameAndWireValue `json:"discriminant,omitempty" url:"discriminant,omitempty"`
	// A list of other types to inherit from
	Extends        []*DeclaredTypeName `json:"extends,omitempty" url:"extends,omitempty"`
	Types          []*SingleUnionType  `json:"types,omitempty" url:"types,omitempty"`
	BaseProperties []*ObjectProperty   `json:"baseProperties,omitempty" url:"baseProperties,omitempty"`
}

func (u *UnionTypeDeclaration) String() string {
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type VariableDeclaration struct {
	Docs *string        `json:"docs,omitempty" url:"docs,omitempty"`
	Id   VariableId     `json:"id" url:"id"`
	Name *Name          `json:"name,omitempty" url:"name,omitempty"`
	Type *TypeReference `json:"type,omitempty" url:"type,omitempty"`
}

func (v *VariableDeclaration) String() string {
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VariableId = string

type InlinedWebhookPayload struct {
	Name       *Name                            `json:"name,omitempty" url:"name,omitempty"`
	Extends    []*DeclaredTypeName              `json:"extends,omitempty" url:"extends,omitempty"`
	Properties []*InlinedWebhookPayloadProperty `json:"properties,omitempty" url:"properties,omitempty"`
}

func (i *InlinedWebhookPayload) String() string {
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InlinedWebhookPayloadProperty struct {
	Docs      *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Name      *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`
}

func (i *InlinedWebhookPayloadProperty) String() string {
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Webhook struct {
	Docs         *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name         WebhookName       `json:"name,omitempty" url:"name,omitempty"`
	DisplayName  *string           `json:"displayName,omitempty" url:"displayName,omitempty"`
	Method       WebhookHttpMethod `json:"method,omitempty" url:"method,omitempty"`
	Headers      []*HttpHeader     `json:"headers,omitempty" url:"headers,omitempty"`
	Payload      *WebhookPayload   `json:"payload,omitempty" url:"payload,omitempty"`
}

func (w *Webhook) String() string {
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebhookGroup = []*Webhook

type WebhookHttpMethod string

const (
	WebhookHttpMethodGet  WebhookHttpMethod = "GET"
	WebhookHttpMethodPost WebhookHttpMethod = "POST"
)

func NewWebhookHttpMethodFromString(s string) (WebhookHttpMethod, error) {
	switch s {
	case "GET":
		return WebhookHttpMethodGet, nil
	case "POST":
		return WebhookHttpMethodPost, nil
	}
	var t WebhookHttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookHttpMethod) Ptr() *WebhookHttpMethod {
	return &w
}

type WebhookName = *Name

type WebhookPayload struct {
	Type           string
	InlinedPayload *InlinedWebhookPayload
	Reference      *WebhookPayloadReference
}

func NewWebhookPayloadFromInlinedPayload(value *InlinedWebhookPayload) *WebhookPayload {
	return &WebhookPayload{Type: "inlinedPayload", InlinedPayload: value}
}

func NewWebhookPayloadFromReference(value *WebhookPayloadReference) *WebhookPayload {
	return &WebhookPayload{Type: "reference", Reference: value}
}

func (w *WebhookPayload) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	w.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "inlinedPayload":
		value := new(InlinedWebhookPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.InlinedPayload = value
	case "reference":
		value := new(WebhookPayloadReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Reference = value
	}
	return nil
}

func (w WebhookPayload) MarshalJSON() ([]byte, error) {
	switch w.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", w.Type, w)
	case "inlinedPayload":
		var marshaler = struct {
			Type string `json:"type"`
			*InlinedWebhookPayload
		}{
			Type:                  "inlinedPayload",
			InlinedWebhookPayload: w.InlinedPayload,
		}
		return json.Marshal(marshaler)
	case "reference":
		var marshaler = struct {
			Type string `json:"type"`
			*WebhookPayloadReference
		}{
			Type:                    "reference",
			WebhookPayloadReference: w.Reference,
		}
		return json.Marshal(marshaler)
	}
}

type WebhookPayloadVisitor interface {
	VisitInlinedPayload(*InlinedWebhookPayload) error
	VisitReference(*WebhookPayloadReference) error
}

func (w *WebhookPayload) Accept(visitor WebhookPayloadVisitor) error {
	switch w.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", w.Type, w)
	case "inlinedPayload":
		return visitor.VisitInlinedPayload(w.InlinedPayload)
	case "reference":
		return visitor.VisitReference(w.Reference)
	}
}

type WebhookPayloadReference struct {
	Docs        *string        `json:"docs,omitempty" url:"docs,omitempty"`
	PayloadType *TypeReference `json:"payloadType,omitempty" url:"payloadType,omitempty"`
}

func (w *WebhookPayloadReference) String() string {
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type ExampleWebSocketMessage struct {
	Type WebSocketMessageId           `json:"type" url:"type"`
	Body *ExampleWebSocketMessageBody `json:"body,omitempty" url:"body,omitempty"`
}

func (e *ExampleWebSocketMessage) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExampleWebSocketMessageBody struct {
	Type        string
	InlinedBody *ExampleInlinedRequestBody
	Reference   *ExampleTypeReference
}

func NewExampleWebSocketMessageBodyFromInlinedBody(value *ExampleInlinedRequestBody) *ExampleWebSocketMessageBody {
	return &ExampleWebSocketMessageBody{Type: "inlinedBody", InlinedBody: value}
}

func NewExampleWebSocketMessageBodyFromReference(value *ExampleTypeReference) *ExampleWebSocketMessageBody {
	return &ExampleWebSocketMessageBody{Type: "reference", Reference: value}
}

func (e *ExampleWebSocketMessageBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "inlinedBody":
		value := new(ExampleInlinedRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.InlinedBody = value
	case "reference":
		value := new(ExampleTypeReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Reference = value
	}
	return nil
}

func (e ExampleWebSocketMessageBody) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "inlinedBody":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleInlinedRequestBody
		}{
			Type:                      "inlinedBody",
			ExampleInlinedRequestBody: e.InlinedBody,
		}
		return json.Marshal(marshaler)
	case "reference":
		var marshaler = struct {
			Type string `json:"type"`
			*ExampleTypeReference
		}{
			Type:                 "reference",
			ExampleTypeReference: e.Reference,
		}
		return json.Marshal(marshaler)
	}
}

type ExampleWebSocketMessageBodyVisitor interface {
	VisitInlinedBody(*ExampleInlinedRequestBody) error
	VisitReference(*ExampleTypeReference) error
}

func (e *ExampleWebSocketMessageBody) Accept(visitor ExampleWebSocketMessageBodyVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "inlinedBody":
		return visitor.VisitInlinedBody(e.InlinedBody)
	case "reference":
		return visitor.VisitReference(e.Reference)
	}
}

type ExampleWebSocketSession struct {
	Docs            *string                    `json:"docs,omitempty" url:"docs,omitempty"`
	Name            *Name                      `json:"name,omitempty" url:"name,omitempty"`
	Url             string                     `json:"url" url:"url"`
	PathParameters  []*ExamplePathParameter    `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	Headers         []*ExampleHeader           `json:"headers,omitempty" url:"headers,omitempty"`
	QueryParameters []*ExampleQueryParameter   `json:"queryParameters,omitempty" url:"queryParameters,omitempty"`
	Messages        []*ExampleWebSocketMessage `json:"messages,omitempty" url:"messages,omitempty"`
}

func (e *ExampleWebSocketSession) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type InlinedWebSocketMessageBody struct {
	Name       *Name                                  `json:"name,omitempty" url:"name,omitempty"`
	Extends    []*DeclaredTypeName                    `json:"extends,omitempty" url:"extends,omitempty"`
	Properties []*InlinedWebSocketMessageBodyProperty `json:"properties,omitempty" url:"properties,omitempty"`
}

func (i *InlinedWebSocketMessageBody) String() string {
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InlinedWebSocketMessageBodyProperty struct {
	Docs      *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Name      *NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	ValueType *TypeReference    `json:"valueType,omitempty" url:"valueType,omitempty"`
}

func (i *InlinedWebSocketMessageBodyProperty) String() string {
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type WebSocketChannel struct {
	Docs            *string           `json:"docs,omitempty" url:"docs,omitempty"`
	Availability    *Availability     `json:"availability,omitempty" url:"availability,omitempty"`
	Name            WebSocketName     `json:"name,omitempty" url:"name,omitempty"`
	DisplayName     *string           `json:"displayName,omitempty" url:"displayName,omitempty"`
	Path            *HttpPath         `json:"path,omitempty" url:"path,omitempty"`
	Auth            bool              `json:"auth" url:"auth"`
	Headers         []*HttpHeader     `json:"headers,omitempty" url:"headers,omitempty"`
	QueryParameters []*QueryParameter `json:"queryParameters,omitempty" url:"queryParameters,omitempty"`
	PathParameters  []*PathParameter  `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	// The messages that can be sent and received on this channel
	Messages []*WebSocketMessage        `json:"messages,omitempty" url:"messages,omitempty"`
	Examples []*ExampleWebSocketSession `json:"examples,omitempty" url:"examples,omitempty"`
}

func (w *WebSocketChannel) String() string {
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebSocketMessage struct {
	Docs         *string                `json:"docs,omitempty" url:"docs,omitempty"`
	Availability *Availability          `json:"availability,omitempty" url:"availability,omitempty"`
	Type         WebSocketMessageId     `json:"type" url:"type"`
	DisplayName  *string                `json:"displayName,omitempty" url:"displayName,omitempty"`
	Origin       WebSocketMessageOrigin `json:"origin,omitempty" url:"origin,omitempty"`
	Body         *WebSocketMessageBody  `json:"body,omitempty" url:"body,omitempty"`
}

func (w *WebSocketMessage) String() string {
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebSocketMessageBody struct {
	Type        string
	InlinedBody *InlinedWebSocketMessageBody
	Reference   *WebSocketMessageBodyReference
}

func NewWebSocketMessageBodyFromInlinedBody(value *InlinedWebSocketMessageBody) *WebSocketMessageBody {
	return &WebSocketMessageBody{Type: "inlinedBody", InlinedBody: value}
}

func NewWebSocketMessageBodyFromReference(value *WebSocketMessageBodyReference) *WebSocketMessageBody {
	return &WebSocketMessageBody{Type: "reference", Reference: value}
}

func (w *WebSocketMessageBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	w.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "inlinedBody":
		value := new(InlinedWebSocketMessageBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.InlinedBody = value
	case "reference":
		value := new(WebSocketMessageBodyReference)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		w.Reference = value
	}
	return nil
}

func (w WebSocketMessageBody) MarshalJSON() ([]byte, error) {
	switch w.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", w.Type, w)
	case "inlinedBody":
		var marshaler = struct {
			Type string `json:"type"`
			*InlinedWebSocketMessageBody
		}{
			Type:                        "inlinedBody",
			InlinedWebSocketMessageBody: w.InlinedBody,
		}
		return json.Marshal(marshaler)
	case "reference":
		var marshaler = struct {
			Type string `json:"type"`
			*WebSocketMessageBodyReference
		}{
			Type:                          "reference",
			WebSocketMessageBodyReference: w.Reference,
		}
		return json.Marshal(marshaler)
	}
}

type WebSocketMessageBodyVisitor interface {
	VisitInlinedBody(*InlinedWebSocketMessageBody) error
	VisitReference(*WebSocketMessageBodyReference) error
}

func (w *WebSocketMessageBody) Accept(visitor WebSocketMessageBodyVisitor) error {
	switch w.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", w.Type, w)
	case "inlinedBody":
		return visitor.VisitInlinedBody(w.InlinedBody)
	case "reference":
		return visitor.VisitReference(w.Reference)
	}
}

type WebSocketMessageBodyReference struct {
	Docs     *string        `json:"docs,omitempty" url:"docs,omitempty"`
	BodyType *TypeReference `json:"bodyType,omitempty" url:"bodyType,omitempty"`
}

func (w *WebSocketMessageBodyReference) String() string {
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebSocketMessageId = string

type WebSocketMessageOrigin string

const (
	WebSocketMessageOriginClient WebSocketMessageOrigin = "client"
	WebSocketMessageOriginServer WebSocketMessageOrigin = "server"
)

func NewWebSocketMessageOriginFromString(s string) (WebSocketMessageOrigin, error) {
	switch s {
	case "client":
		return WebSocketMessageOriginClient, nil
	case "server":
		return WebSocketMessageOriginServer, nil
	}
	var t WebSocketMessageOrigin
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebSocketMessageOrigin) Ptr() *WebSocketMessageOrigin {
	return &w
}

type WebSocketName = *Name
